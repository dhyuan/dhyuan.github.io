<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>浅流</title>
  <meta name="author" content="Dahui">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="浅流"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">浅流</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-spring/Authentication-in-Spring-Security" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.280Z"><a href="/2025/01/26/spring/Authentication-in-Spring-Security/">2025-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/26/spring/Authentication-in-Spring-Security/">Authentication in Spring Security</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>关于Spring Security里的Authentication，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html">官方文档</a>总结的不错。理解这些classes的作用与关系是正确使用Spring Security Authentication的前提。</p>
<p>认证的方式不同，认证逻辑就不同，这样每个认证方式都会有对应的fitler实现。执行认证的大致流程以 AbstractAuthenticationProcessingFilter 为例描述一下。不同类别的 Authentication Filter 的处理略有差异，但大体逻辑差不多:<br><img src="/2025/01/25/spring/Authentication-in-Spring-Security/abstractauthenticationprocessingfilter.png"></p>
<ol>
<li>Authentication Filter 接收请求 http request。</li>
<li>从request中获取凭证(credential)等数据，封装在<strong>Authentication</strong>对象中，比如：OAuth2LoginAuthenticationToken， UsernamePasswordAuthenticationToken等。</li>
<li>用<strong>AuthenticationManager</strong>向对其传入的Authentication 进行实际的认证工作。</li>
<li>认证成功的处理，比如保存设置了授权信息的Authentication到<strong>SecurityContext</strong>中。</li>
<li>失败进行处理。</li>
</ol>
<h2 id="1-Authentication-Filter-接收请求"><a href="#1-Authentication-Filter-接收请求" class="headerlink" title="1) Authentication Filter 接收请求"></a>1) Authentication Filter 接收请求</h2><p>当用户发送了http request进行认证，将被负责authentication的filter处理。这些filters实际的认证工作大多数（不是全部）都是由 AuthenticationManager 完成的。比如，像AbstractPreAuthenticatedProcessingFilter这些类本身就是接收的是第三方已经认证的请求，所以无需AuthenticationManager。 另外像AnonymousAuthenticationFilter也无需AuthenticationManager的参与。<br>所以虽然都是认证，但是因为不同场景处理的逻辑不同，所以与AuthenticationFilter相关类的父类并不相同。大致可以分成以下三类。</p>
<h3 id="1）继承自-AbstractAuthenticationProcessingFilter-的authentication-fitler-class-有3个。"><a href="#1）继承自-AbstractAuthenticationProcessingFilter-的authentication-fitler-class-有3个。" class="headerlink" title="1）继承自 AbstractAuthenticationProcessingFilter 的authentication fitler class 有3个。"></a>1）继承自 AbstractAuthenticationProcessingFilter 的authentication fitler class 有3个。</h3><p>public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter<br>public class OAuth2LoginAuthenticationFilter extends AbstractAuthenticationProcessingFilter<br>public class Saml2WebSsoAuthenticationFilter extends AbstractAuthenticationProcessingFilter<br><img src="/2025/01/25/spring/Authentication-in-Spring-Security/subclasses-of-AbstractAuthenticatedProcessingFilter.jpeg" alt="AbstractAuthenticationProcessingFilter"></p>
<h3 id="2）继承自-AbstractPreAuthenticatedProcessingFilter-的类有5个。"><a href="#2）继承自-AbstractPreAuthenticatedProcessingFilter-的类有5个。" class="headerlink" title="2）继承自 AbstractPreAuthenticatedProcessingFilter 的类有5个。"></a>2）继承自 AbstractPreAuthenticatedProcessingFilter 的类有5个。</h3><p>public class RequestHeaderAuthenticationFilter extends AbstractPreAuthenticatedProcessingFilter<br>public class RequestAttributeAuthenticationFilter extends AbstractPreAuthenticatedProcessingFilter<br><img src="/2025/01/25/spring/Authentication-in-Spring-Security/subclasses-of-AbstractPreAuthenticatedProcessingFilter.jpg" alt="AbstractPreAuthenticatedProcessingFilter"></p>
<h3 id="3）其它分别直接继承-OncePerRequestFilter-和-GenericFilterBean，比如："><a href="#3）其它分别直接继承-OncePerRequestFilter-和-GenericFilterBean，比如：" class="headerlink" title="3）其它分别直接继承 OncePerRequestFilter 和 GenericFilterBean，比如："></a>3）其它分别直接继承 OncePerRequestFilter 和 GenericFilterBean，比如：</h3><p>OncePerRequestFilter 较 GenericFilterBean可以保证只被filters处理一次。</p>
<pre><code>public class BearerTokenAuthenticationFilter extends OncePerRequestFilter
public class BasicAuthenticationFilter extends OncePerRequestFilter

public class AnonymousAuthenticationFilter extends GenericFilterBean
public class RememberMeAuthenticationFilter extends GenericFilterBean
</code></pre>
<h2 id="2）Request-to-Authentication"><a href="#2）Request-to-Authentication" class="headerlink" title="2）Request to Authentication"></a>2）Request to Authentication</h2><p>Authentication这个类在认证前主要用于承载认证需要的凭证信息，比如用户名密码。authentication 对象也就等同于一个authentication request的event，并包含请求者进行认证所必须的信息。<br><img src="/2025/01/25/spring/Authentication-in-Spring-Security/Authentication.jpg"></p>
<h2 id="3）AuthenticationManager"><a href="#3）AuthenticationManager" class="headerlink" title="3）AuthenticationManager"></a>3）AuthenticationManager</h2><p>authentication对象会传递给<strong>AuthenticationManager</strong> 的方法authenticate()做认证。<br>AuthenticationManager是个interface，它的实现类如下图片所示。<br><img src="/2025/01/25/spring/Authentication-in-Spring-Security/implements_of_AuthenticationManager.jpg"></p>
<p>在认证后，principal的授权信息会被写在authentication对象的authorities字段。下图摘自《Spring Security in Action》，使用username password做认证。<br><img src="/2025/01/25/spring/Authentication-in-Spring-Security/fg3.1_of_SpringSecurityInAction.jpg"></p>
<p>如上图所示的，具体的认证工作是委托给<strong>AuthenticationProvider</strong>完成的。在Spring Security的代码实现中，也并不是由AuthenticationManager直接包含一组AuthenticationProvider的方式完成，中间还有一个叫做<strong>ProviderManager</strong>的类，下面列出它的两个关键字段体会下。 </p>
<pre><code>public class ProviderManager implements AuthenticationManager, MessageSourceAware, InitializingBean &#123;

    private List&lt;AuthenticationProvider&gt; providers = Collections.emptyList();

    private AuthenticationManager parent;
    ... ...
&#125;
</code></pre>
<p>可以看到ProviderManager包含的不是一个provider而是a list of providers。通过提供一组providers就向用户提供了更多灵活控制的可能性。当然随之而来的就是这里就需要明确定义providers的认证结果以谁为准的规则。源码authenticate()的doc说得很明白：</p>
<blockquote>
<p>Attempts to authenticate the passed Authentication object.<br>The list of AuthenticationProviders will be successively tried until an AuthenticationProvider indicates it is capable of authenticating the type of Authentication object passed. Authentication will then be attempted with that AuthenticationProvider.<br>If more than one AuthenticationProvider supports the passed Authentication object, the first one able to successfully authenticate the Authentication object determines the result, overriding any possible AuthenticationException thrown by earlier supporting AuthenticationProviders. On successful authentication, no subsequent AuthenticationProviders will be tried. If authentication was not successful by any supporting AuthenticationProvider the last thrown AuthenticationException will be rethrown.</p>
</blockquote>
<p>让我们对比一下AuthenticationManger和AuthenticationProvider这两个interface的定义。看了下面的定义，你会不会问一个问题：既然两个接口有一个一摸一样的方法authentication()，为什么不让AuthenticationProvider继承AuthenticationManager？ 我想或许是为了明确两个类的职责吧。<br><img src="/2025/01/25/spring/Authentication-in-Spring-Security/AuthenticationManager.jpg"><br><img src="/2025/01/25/spring/Authentication-in-Spring-Security/AuthenticationProvider.jpg"></p>
<p>以图形的方式看看它们的关系：<br><img src="/2025/01/25/spring/Authentication-in-Spring-Security/authentication-mgr-and-providers.png"></p>
<p>如果我们要实现某个特殊的在Spring里没有的认证方式，我们就需要实现自定的AuthenticationProvider并通过覆盖WebSecurityConfigurerAdapter里的configure()方法实现。 </p>
<pre><code>@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter &#123;

@Autowired
private AuthenticationProvider authenticationProvider;

@Override
protected void configure(AuthenticationManagerBuilder auth) &#123;
    auth.authenticationProvider(authenticationProvider);
&#125;
</code></pre>
<p>不过这个类已经被官方API文档标为Deprecated，并推荐使用HttpSecurity定义SecurityFilterChain的方式或者通过WebSecurityCustomizer来配置WebSecurity。参考源码：<br><img src="/2025/01/25/spring/Authentication-in-Spring-Security/registerAuthenticationProvider.jpeg"></p>
<p>到这里我们应该已经知道具体的认证逻辑都在AuthenticationProvider里。想知道Spring Security提供了哪些开箱即用的provider吗？见下图，一共17个。<br><img src="/2025/01/25/spring/Authentication-in-Spring-Security/authenticationProviders.jpg"></p>
<p>再捋一下与认证相关的类，就结束这篇吧。虽然没有涉及过多细节，相信理解了这些脉略应该也能在copy-past代码的时候点点头了。。。<br>SecurityContextHolder：保存SecurityContext的地方。<br>SecurityContextHolderStrategy：定义SecurityContext在线程中共享的策略模式。如果要跨线越Spring管理的线程，请参考 。。。。<br>SecurityContext - 认证成功后Authentication对象就放在这里。<br>Authentication - 存放要认证的信息以及被 AuthenticationManager 认证后的结果，认证成功后被放入SecurityContext。<br>GrantedAuthority - 请求认证的principal认证成功后被赋予的权限(i.e. roles, scopes, etc.)<br>AuthenticationManager - authentication相关的filter调用这个对象做认证。<br>AbstractAuthenticationProcessingFilter：各个认证相关filter的父类。<br>ProviderManager - AuthenticationManager的一个实现.<br>AuthenticationProvider - 由ProviderManager 用来做具体的认证。<br>AuthenticationEntryPoint: 用于询问并接收用户的credentials，可以是重定向到一个网页或者发送http WWW-Authenticate response。</p>
<p>我想现在我们看到下面这些类时，就应该能够大致知道/理解他们在Spring Security Authentication类图里的位置了吧？<br>UserDetails, User<br>UserDetailsService, UserDetailsManager, JdbcUserDetailsManager<br>PasswordEncoder<br>如果没有，一定是我还没描述清楚。 </p>
<br/>

<hr>
<p><em>References:</em><br>[1]: <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html">https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html</a><br>[2]: 《Spring Security in Action》  </p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-notes/cas/Run-up-Apereo-CAS-locally" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.276Z"><a href="/2025/01/26/notes/cas/Run-up-Apereo-CAS-locally/">2025-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/26/notes/cas/Run-up-Apereo-CAS-locally/">Apereo CAS 之 在本地运行</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>Apereo CAS，是CAS协议<code>official reference implementation</code>，也差不多是当前开源的SSO解决方案最好、最成熟的一个了。<br>当前版本是6.5，<a target="_blank" rel="noopener" href="https://github.com/apereo/cas-overlay-template/tree/6.5%E3%80%82">https://github.com/apereo/cas-overlay-template/tree/6.5。</a></p>
<p>本以为按照<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/installation/WAR-Overlay-Installation.html">Apereo CAS的官方安装指南</a>能够很容易把cas server在本地跑起来，但最后发现这个文档实操性略差。这里略过基础概念，直接记录一下本地运行的步骤。</p>
<p>没必要下载源码修改代码、配置然后build出自己的安装包，按照官方文档推荐直接使用“WAR Overlay Installation”的方式安装。</p>
<h3 id="1）下载overlay框架代码，使用6-5分支代码。"><a href="#1）下载overlay框架代码，使用6-5分支代码。" class="headerlink" title="1）下载overlay框架代码，使用6.5分支代码。"></a>1）下载overlay框架代码，使用6.5分支代码。</h3><pre><code>git clone https://github.com/apereo/cas-overlay-template.git cas-server
git checkout -b 6.5 origin/6.5
</code></pre>
<p>Overlays这个方式是通过maven-war-plugin实现的： <a target="_blank" rel="noopener" href="https://maven.apache.org/plugins/maven-war-plugin/overlays.html%EF%BC%8C">https://maven.apache.org/plugins/maven-war-plugin/overlays.html，</a><br>gradle的实现：<a target="_blank" rel="noopener" href="https://docs.freefair.io/gradle-plugins/current/reference/#_io_freefair_war_overlay">https://docs.freefair.io/gradle-plugins/current/reference/#_io_freefair_war_overlay</a><br>在这个cas项目里可参看 ./gradle/springboot.gradle 里bootWar部分。</p>
<h3 id="2）gradle-perperties"><a href="#2）gradle-perperties" class="headerlink" title="2）gradle.perperties"></a>2）gradle.perperties</h3><p>这利用这个overlays项目运行CAS之前，可浏览一下gradle.properties文件定义的各个属性。其中，<br><strong>appServer</strong> 用于定义Apereo CAS server使用哪个内置server（Tomcat、Jetty…），如果只生成war部署到外部已存在的servlet contaier则无需定义此项。<br><strong>certDir、serverKeyStore、exportedServerCert、storeType</strong> 这些选项用于定义https所用的证书。</p>
<h3 id="3）gradle-tasks-gradle"><a href="#3）gradle-tasks-gradle" class="headerlink" title="3）gradle/tasks.gradle"></a>3）gradle/tasks.gradle</h3><p><code>./gradlew tasks</code> 运行会显示可执行的tasks，其中一部分task被定义于 gradle/tasks.gradle 文件中。</p>
<pre><code>CAS tasks
---------
casVersion - Display the current CAS version
copyCasConfiguration - Copy the CAS configuration from this project to /etc/cas/config
createKeystore - Create CAS keystore
createTheme - Create theme directory structure in the overlay
... ...
</code></pre>
<p>其中 createKeystore 用于生成https所用的证书。<br><code>sudo ./gradlew createKeystore</code></p>
<p>如果需要修改keystore的密码，可以执行：<br><code>keytool -storepasswd -keystore /etc/cas/thekeystore</code></p>
<p>生成https需要的PK和证书后，需要把CA导入到JDK的的ca根证书库中。</p>
<pre><code>cd /etc/cas
sudo keytool -import -alias cas_cert -storepass changeit -file cas.crt -keystore  /Library/Java/JavaVirtualMachines/temurin-11.jdk/Contents/Home/lib/security/cacerts
</code></pre>
<p>查看ca keystore<br><code>sudo keytools -list -storepass changeit  -keystore  /Library/Java/JavaVirtualMachines/temurin-11.jdk/Contents/Home/lib/security/cacerts</code></p>
<p>从ca keystore中删除cascert<br><code>sudo keytool -delete  -alias cas_cert  -keystore  /Library/Java/JavaVirtualMachines/temurin-11.jdk/Contents/Home/lib/security/cacerts  -storepass changeit</code></p>
<h3 id="4）cas的配置文件"><a href="#4）cas的配置文件" class="headerlink" title="4）cas的配置文件"></a>4）cas的配置文件</h3><p>把项目中的 etc/cas/config 目录下的默认配置内容copy到 /etc/cas/config 中。可以手工copy文件，也可以通过gradle task, <code>./gradlew copyCasConfiguration</code></p>
<p>默认的内置的用户名密码是 casuser/Mellon，可以通过修改/etc/cas/config/cas.properties <code>cas.authn.accept.users=casuser::password</code> 进行定义。</p>
<p>配置登录用户在Apereo里属于<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/authentication/Configuring-Authentication-Components.html">CAS Authentication 的范畴</a>。</p>
<h3 id="5）Build-and-Run"><a href="#5）Build-and-Run" class="headerlink" title="5）Build and Run"></a>5）Build and Run</h3><pre><code>./gradlew clean build
java -jar ./build/libs/cas.war
</code></pre>
<p>在浏览器中访问 <a target="_blank" rel="noopener" href="https://localhost:8443/cas">https://localhost:8443/cas</a> 进入CAS系统。</p>
<h3 id="6"><a href="#6" class="headerlink" title="6)"></a>6)</h3><p>如果在日志里发现提示<code>The generated key MUST be added to CAS settings</code>， 则可按照提示把cas.tgc.crypto.encryption.key，cas.tgc.crypto.signing.key 加入到etc/cas/config/cas.properties 文件。</p>
<pre><code>    2022-08-29 23:29:34,160 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Secret key for encryption is not defined for [Ticket-granting Cookie]; CAS will attempt to auto-generate the encryption key&gt;
    2022-08-29 23:29:34,168 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Generated encryption key [rAHG_XeYnE-DbLtE77fngWAMtbB5lpIXYKbI_nSiD8I] of size [256] for [Ticket-granting Cookie]. The generated key MUST be added to CAS settings:

            cas.tgc.crypto.encryption.key=rAHG_XeYnE-DbLtE77fngWAMtbB5lpIXYKbI_nSiD8I

    &gt;
    2022-08-29 23:29:34,170 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Secret key for signing is not defined for [Ticket-granting Cookie]. CAS will attempt to auto-generate the signing key&gt;
    2022-08-29 23:29:34,170 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Generated signing key [cOlc7xQB5UJTwYrVmA30aQehEkxbSkcyHmE8vRkPHboRZkTn2rBJ8pUUPZfTJt7H8e3ecpitvuH2prrLxfIVxg] of size [512] for [Ticket-granting Cookie]. The generated key MUST be added to CAS settings:

            cas.tgc.crypto.signing.key=cOlc7xQB5UJTwYrVmA30aQehEkxbSkcyHmE8vRkPHboRZkTn2rBJ8pUUPZfTJt7H8e3ecpitvuH2prrLxfIVxg
</code></pre>
<br/>

<hr>
<p><em>Reference:</em><br>[1]: <a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/index.html">https://apereo.github.io/cas/6.5.x/index.html</a><br>[2]: <a target="_blank" rel="noopener" href="https://github.com/apereo/cas-overlay-template/tree/6.5">https://github.com/apereo/cas-overlay-template/tree/6.5</a><br>[3]: <a target="_blank" rel="noopener" href="https://medium.com/swlh/install-cas-server-with-db-authentication-8ff52234f52">https://medium.com/swlh/install-cas-server-with-db-authentication-8ff52234f52</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-notes/cas/enable-OAuth-support-for-Apereo-CAS" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.276Z"><a href="/2025/01/26/notes/cas/enable-OAuth-support-for-Apereo-CAS/">2025-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/26/notes/cas/enable-OAuth-support-for-Apereo-CAS/">Apereo CAS 之 支持OAuth2</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>Apereo CAS 通过使用bridge模式来支持多个协议：CAS、SAML2、OAuth2、OpenID Connect等。<br>CAS可部署软件包中已经包含了可以使用SAML2、OAuth2等协议的plugin/bridges/modules，这些plugins模块都是和CAS通信。 可参考：<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/protocol/Protocol-Overview.html%E3%80%82">https://apereo.github.io/cas/6.5.x/protocol/Protocol-Overview.html。</a> </p>
<p><code>The right-hand side of that equation is always CAS when you consider, as an example, the following authentication flow with an OAuth2-enabled client application:</code></p>
<ol>
<li>The CAS deployment has turned on the OAuth2 plugin.</li>
<li>An OAuth2 authorization request is submitted to the relevant CAS endpoint.</li>
<li>The OAuth2 plugin verifies the request and translates it to a CAS authentication request!</li>
<li>The authentication request is routed to the relevant CAS login endpoint.</li>
<li>User authenticates and CAS routes the flow back to the OAuth2 plugin, having issued a service ticket for the plugin.</li>
<li>The OAuth2 plugin attempts to validate that ticket to retrieve the necessary user profile and attributes.</li>
<li>The OAuth2 plugin then proceeds to issue the right OAuth2 response by translating and transforming the profile and validated assertions into what the client application may need.</li>
</ol>
<h3 id="1-添加依赖库"><a href="#1-添加依赖库" class="headerlink" title="1. 添加依赖库"></a>1. 添加依赖库</h3><pre><code>implementation &quot;org.apereo.cas:cas-server-support-oauth-webflow&quot;
</code></pre>
<h3 id="2-Enable-Actuator-Endpoints-（Optional）"><a href="#2-Enable-Actuator-Endpoints-（Optional）" class="headerlink" title="2. Enable Actuator Endpoints （Optional）"></a>2. Enable Actuator Endpoints （Optional）</h3><p>添加依赖，并设置开放oauthd的actuator端点。</p>
<pre><code>implementation &quot;org.apereo.cas:cas-server-support-reports&quot;

management.endpoint.oauthTokens.enabled=true
management.endpoints.web.exposure.include=oauthTokens
cas.monitor.endpoints.endpoint.oauthTokens.access=PERMIT
</code></pre>
<p>通过访问 <a target="_blank" rel="noopener" href="https://localhost:8443/cas/actuator/">https://localhost:8443/cas/actuator/</a> 应该可以看到OAuth相关endpoints。</p>
<h3 id="3-定义一个OAuth-Client"><a href="#3-定义一个OAuth-Client" class="headerlink" title="3. 定义一个OAuth Client"></a>3. 定义一个OAuth Client</h3><p>可以通过设置</p>
<pre><code>cas.service-registry.json.location=classpath:/services
cas.service-registry.core.init-from-json=true
</code></pre>
<p>在 cas-overlay-template的 resources/services 下定义文件 OAuth2DemoClient-2001.json 包含以下内容来把这个OAuth2 Client ‘OAuth2DemoClient’ 自动导入到MongoDB 的 cas_serviceregistry collection。</p>
<pre><code>&#123;
  &quot;@class&quot; : &quot;org.apereo.cas.support.oauth.services.OAuthRegisteredService&quot;,
  &quot;clientId&quot;: &quot;oauth2DemoClientID&quot;,
  &quot;clientSecret&quot;: &quot;clientSecret&quot;,
  &quot;serviceId&quot; : &quot;^(https|imaps)://&lt;redirect-uri&gt;.*&quot;,
  &quot;name&quot; : &quot;OAuth2DemoClient&quot;,
  &quot;id&quot; : 2001,
  &quot;supportedGrantTypes&quot;: [ &quot;java.util.HashSet&quot;, [ &quot;password&quot;, &quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;] ],
  &quot;supportedResponseTypes&quot;: [ &quot;java.util.HashSet&quot;, [ &quot;token&quot;, &quot;code&quot;, &quot;device_code&quot;] ]
&#125;
</code></pre>
<p>grant是获得AccessToken的方式/方法，这篇文章对此进行了详细介绍：<a target="_blank" rel="noopener" href="https://alexbilbie.com/guide-to-oauth-2-grants/%E3%80%82">https://alexbilbie.com/guide-to-oauth-2-grants/。</a></p>
<h3 id="4-重启、查看"><a href="#4-重启、查看" class="headerlink" title="4. 重启、查看"></a>4. 重启、查看</h3><p>运行 <code>./gradlew clean copyCasConfiguration build run </code> 后，查看 <code>db.getCollection(&#39;cas_serviceregistry&#39;).find(&#123;&#125;)</code> 应该可以看到id为2001的 OAutho client定义。</p>
<p>通过CAS Management UI也可以看到刚刚添加的‘OAuth2DemoClient’：<br><img src="/2025/01/25/notes/cas/enable-OAuth-support-for-Apereo-CAS/OAuth2Client_view.jpg" alt="An OAuth Client/Service"></p>
<p>至此，我们以及把Apereo CAS配置成支持OAuth2协议。</p>
<br/>

<hr>
<p><em>Reference:</em><br>[1]: <a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/protocol/Protocol-Overview.html">https://apereo.github.io/cas/6.5.x/protocol/Protocol-Overview.html</a><br>[2]: <a target="_blank" rel="noopener" href="https://alexbilbie.com/guide-to-oauth-2-grants/">https://alexbilbie.com/guide-to-oauth-2-grants/</a><br>[3]: <a target="_blank" rel="noopener" href="https://dacurry-tns.github.io/deploying-apereo-cas/building_server_service-registry_configure-the-service-registry.html">https://dacurry-tns.github.io/deploying-apereo-cas/building_server_service-registry_configure-the-service-registry.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-notes/test/Performance-Test-101" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.276Z"><a href="/2025/01/26/notes/test/Performance-Test-101/">2025-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/26/notes/test/Performance-Test-101/">Performance Test 101</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>无论是哪种测试：单元测试、集成测试、回归测试等，目的都是找到breaking points、消除性能瓶颈。</p>
<p>对于Performance Test来说，我们希望在期望的负载下验证我们的系统是否在 <strong>速度</strong>、 <strong>伸缩性</strong>、 <strong>稳定性</strong> 方面满足系统对性能的需求。一般来说我们希望系统能在RPS和latency之间达到一个不错的平衡。  </p>
<p>最最基础的两个指标：</p>
<p><strong>RPS</strong> (request per sec):<br>每秒系统可接受/处理的请求数。值得注意的时，虽然请求可被接收或者处理，但是处理的结果可能是正常启动的value也有可能因为系统压力的原因而是Error。</p>
<p>这篇文章讲了<a target="_blank" rel="noopener" href="https://medium.com/@novyludek/virtual-users-vs-rps-77627b384127">RPS和Virtual User的概念</a> ，可以帮助理解为什么不是RPS越高越好而是RPS与Latence之间的平衡。其中讲到Virutal User的生命周期是到测试结束，这一点对我们理解和写测试代码挺重要的。<br><code>The typical virtual user life cycle looks like this — it picks up the scripted tasks and performs them, once it finishes all of them it will start the loop again. And it keeps it going until the test is terminated.</code></p>
<p>这个和 <a target="_blank" rel="noopener" href="https://docs.locust.io/en/stable/quickstart.html#locust-s-web-interface">Locust 文档</a> 中描述的行为是一致的:  <code>This user will make HTTP requests to /hello, and then /world, again and again. </code></p>
<p><strong>Latency</strong>:<br>从请求被创建出来发送到接收的endpint开始到收到response的这个段时间。</p>
<h2 id="1-性能测试类型"><a href="#1-性能测试类型" class="headerlink" title="1. 性能测试类型"></a>1. 性能测试类型</h2><p>这里列出的类型分类是从稍微具体一点的关注点来分类的。我们做性能测试就是希望在下面几个方面得到系统当前的处理能力，以及它的breaking points。</p>
<ul>
<li><p>负载测试 Load Test</p>
</li>
<li><p>压力测试 Stress Test</p>
</li>
<li><p>耐久/疲劳测试 Endurance Test</p>
</li>
<li><p>尖峰测试 Spike Test</p>
</li>
<li><p>容量 Volume Test</p>
</li>
<li><p>伸缩测试 Scaliability Test</p>
</li>
</ul>
<p><em>Load testing</em> – checks the application’s ability to perform under anticipated user loads. The objective is to identify performance bottlenecks before the software application goes live.  </p>
<p><em>Stress testing</em> – involves testing an application under extreme workloads to see how it handles high traffic or data processing. The objective is to identify the breaking point of an application.  </p>
<p><em>Endurance testing</em> – is done to make sure the software can handle the expected load over a long period of time.  </p>
<p><em>Spike testing</em> – tests the software’s reaction to sudden large spikes in the load generated by users.  </p>
<p><em>Volume testing</em> – Under Volume Testing large no. of. Data is populated in a database and the overall software system’s behavior is monitored. The objective is to check software application’s performance under varying database volumes.  </p>
<p><em>Scalability testing</em> – The objective of scalability testing is to determine the software application’s effectiveness in “scaling up” to support an increase in user load. It helps plan capacity addition to your software system.</p>
<h2 id="2-性能测试的三个方面"><a href="#2-性能测试的三个方面" class="headerlink" title="2. 性能测试的三个方面"></a>2. 性能测试的三个方面</h2><p>上面列出的几个测试关注点，都可以放到这三点：速度、伸缩性、稳定性。<br>速度: 负载测试, 压力测试<br>伸缩: 压力测试, Spike Test, Volume Test, Scaliability Test<br>稳定性: Endurance testing</p>
<h3 id="1-有多快？——-速度"><a href="#1-有多快？——-速度" class="headerlink" title="1. 有多快？—— 速度"></a>1. 有多快？—— 速度</h3><p>常用指标：</p>
<ul>
<li>加载时长 Load time</li>
<li>响应时长 Response time</li>
<li>RPS</li>
<li>每秒网络字节数 Network bytes total per second</li>
<li>网络输出队列长度 Network output queue length</li>
<li>…</li>
</ul>
<p>只看平均值是没有太多意义的，要看百分比分布。</p>
<h3 id="2-还能有多快？-——-伸缩性"><a href="#2-还能有多快？-——-伸缩性" class="headerlink" title="2. 还能有多快？ —— 伸缩性"></a>2. 还能有多快？ —— 伸缩性</h3><p>这里的scalability是说在外部请求不断增加的情况下，系统的资源分配是否能支持这些增加的负载。同样我们也期望当外部负载变小时，系统占用的资源也能够释放出来。<br>这里的memeory footprint、CPU usage、bandwidth usage都是系统垂直伸缩的指标。<br>如果系统支持水平伸缩，那么就要看系统是否能够在输入负载增加的情况下，系统是否能够通过水平扩展节点来保持期望的处理速度。</p>
<p>常用指标：</p>
<ul>
<li>内存</li>
<li>带宽</li>
<li>CPU</li>
<li>并发用户数</li>
<li>系统处理节点</li>
<li>… …</li>
</ul>
<h3 id="3-可以持续多久？——-稳定性"><a href="#3-可以持续多久？——-稳定性" class="headerlink" title="3. 可以持续多久？—— 稳定性"></a>3. 可以持续多久？—— 稳定性</h3><p>持续的给系统一定的输入负载，看看系统是否能够正常处理请求。一般来说，通过这种持续性测试可以发现系统是否能够对使用后的资源进行了释放，比如内存泄露的情况。<br>如果使用Gatling，对应如下语句进行stability的测试。</p>
<pre><code>jumpToRps(20),
holdFor(Duration.ofSeconds(30)),
</code></pre>
<p>常用指标：</p>
<ul>
<li>Page faults </li>
<li>Committed memory</li>
<li>Maximum active sessions</li>
<li>Thread counts</li>
<li>Transactions passed or failed</li>
<li>Error rate</li>
</ul>
<h2 id="3-性能测试步骤"><a href="#3-性能测试步骤" class="headerlink" title="3. 性能测试步骤"></a>3. 性能测试步骤</h2><h3 id="1-Identify-your-testing-environment"><a href="#1-Identify-your-testing-environment" class="headerlink" title="1. Identify your testing environment"></a>1. Identify your testing environment</h3><p>软硬件环境、网络配置、测试工具。</p>
<h3 id="2-Identify-the-performance-acceptance-criteria"><a href="#2-Identify-the-performance-acceptance-criteria" class="headerlink" title="2. Identify the performance acceptance criteria"></a>2. Identify the performance acceptance criteria</h3><p>针对 吞吐量、响应时间、资源占用等，设定被测程序可接受的性能指标。比如：</p>
<ul>
<li>1000个用户同时访问网站时，响应时间不超过4s。</li>
<li>应用崩溃前可处理器的最大并发用户数。</li>
<li>在峰值负载的情况下，CPU、内存的使用情况</li>
<li>测试应用在低、一般、大、超大负载情况下应用的响应时间、吞吐量。</li>
</ul>
<h3 id="3-规划设计性能测试方案"><a href="#3-规划设计性能测试方案" class="headerlink" title="3. 规划设计性能测试方案"></a>3. 规划设计性能测试方案</h3><p>对于测试指标因为人力、需求的不同，也没必要面面俱到， 根据需要和场景重点设计需要的测试类型：比如 Load Test, Endurance Test等</p>
<h3 id="4-配置测试环境"><a href="#4-配置测试环境" class="headerlink" title="4. 配置测试环境"></a>4. 配置测试环境</h3><h3 id="5-实现并运行测试"><a href="#5-实现并运行测试" class="headerlink" title="5. 实现并运行测试"></a>5. 实现并运行测试</h3><h3 id="6-Analyze，Tune，Retest"><a href="#6-Analyze，Tune，Retest" class="headerlink" title="6. Analyze，Tune，Retest"></a>6. Analyze，Tune，Retest</h3><br/>

<hr>
<p>Reference:<br>[1]: <a target="_blank" rel="noopener" href="https://www.guru99.com/performance-testing.html">https://www.guru99.com/performance-testing.html</a><br>[2]: <a target="_blank" rel="noopener" href="https://www.onpathtesting.com/blog/performance-testing-metrics">https://www.onpathtesting.com/blog/performance-testing-metrics</a><br>[3]: <a target="_blank" rel="noopener" href="https://nbomber.com/docs/loadtesting-basics/">https://nbomber.com/docs/loadtesting-basics/</a><br>[4]: <a target="_blank" rel="noopener" href="https://medium.com/@novyludek/virtual-users-vs-rps-77627b384127">https://medium.com/@novyludek/virtual-users-vs-rps-77627b384127</a>  </p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-mongo/setupMongoForLocalDevEnv" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.275Z"><a href="/2025/01/26/mongo/setupMongoForLocalDevEnv/">2025-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/26/mongo/setupMongoForLocalDevEnv/">为本地Mac开发环境设置mongo服务</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="1）安装"><a href="#1）安装" class="headerlink" title="1）安装"></a>1）安装</h3><p>Mac上通过brew安装Mongo 参考：<a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/#std-label-install">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/#std-label-install</a></p>
<pre><code>brew tap mongodb/brew
brew install mongodb-community@5.0

brew services start/restart/stop mongodb-community@5.0
brew services list
</code></pre>
<p>通过brew安装后，MongoDB的配置文件在 /usr/local/etc/mongod.conf，可根据实际情况设置端口、认证、复制集等。</p>
<pre><code>net:
  port: 27117
  bindIp: 0.0.0.0
replication:
  replSetName: rs0
</code></pre>
<h3 id="2-设置密码登录"><a href="#2-设置密码登录" class="headerlink" title="2) 设置密码登录"></a>2) 设置密码登录</h3><p>创建超级用户、普通用户：<br>    mongosh</p>
<pre><code>use admin
db.createUser(
  &#123;
    user: &quot;root&quot;,
    pwd: &quot;password&quot;, 
    roles: [
      &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125;
    ]
  &#125;
)

// 创建用户test，对数据库testDB1、testDB2读写的权限，其authorizaiton的DB是testDB1。
use testDB1
db.createUser(
  &#123;
    user: &quot;testuser&quot;,
    pwd: &quot;123&quot;, 
    roles: [
      &#123; role: &quot;readWrite&quot;, db: &quot;testDB&quot; &#125;,
      &#123; role: &quot;readWrite&quot;, db: &quot;testDB2&quot; &#125;
    ]
  &#125;
)
</code></pre>
<p>给 root 用户设置clusterManager角色，这样才可以使用rs.initiate()、rs.conf()与复制集相关的命令。</p>
<pre><code>use admin
db.grantRolesToUser(
  &quot;root&quot;,
  [ &quot;clusterManager&quot; ]
)
</code></pre>
<p>这个dbAdminAnyDatabase 角色似乎很‘方便’。</p>
<pre><code>db.grantRolesToUser(&quot;yourUser&quot;, [&#123;&quot;role&quot;: &quot;dbAdminAnyDatabase&quot;, &quot;db&quot;: &quot;admin&quot;&#125;])
</code></pre>
<h3 id="3）设置复制集。"><a href="#3）设置复制集。" class="headerlink" title="3）设置复制集。"></a>3）设置复制集。</h3><p>复制集需要安全通行。首先生成mongodb私钥<br>Reference：<a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/tutorial/enforce-keyfile-access-control-in-existing-replica-set/">https://docs.mongodb.com/manual/tutorial/enforce-keyfile-access-control-in-existing-replica-set/</a></p>
<pre><code>openssl rand -base64 756 &gt; KEY_PATH/mongo_server.key
</code></pre>
<p>修改配置设置keyFile：</p>
<pre><code>security:
  keyFile: KEY_PATH/mongo_server.key
  authorization: enabled
</code></pre>
<p>强制设置本地节点复制集名称。</p>
<pre><code>replication:
  replSetName: rs0
</code></pre>
<p>重启mongo</p>
<pre><code>brew services restart mongodb-community
</code></pre>
<p>进入mongosh，执行rs.initiate()初始化数据集：</p>
<pre><code>rs.initiate()
rs.conf()
</code></pre>
<h3 id="4）强制设置master复制集。"><a href="#4）强制设置master复制集。" class="headerlink" title="4）强制设置master复制集。"></a>4）强制设置master复制集。</h3><p>遇到的问题及解决：开始在端口为27017的情况下按照 <a target="_blank" rel="noopener" href="https://mongoing.com/docs/tutorial/convert-standalone-to-replica-set.html">https://mongoing.com/docs/tutorial/convert-standalone-to-replica-set.html</a> 介绍的方式把单节点的mongo服务转变为单复制集的方式运行。</p>
<p>接着又更改了mongo服务的端口为27117，这样之前的复制集节点就不对了。<br>先加上当前27117端口的mongo服务作为一个复制集。</p>
<pre><code>rs.add(&quot;127.0.0.1:27117&quot;)
</code></pre>
<p>查看复制集配置</p>
<pre><code>rs0 [direct: primary] test&gt; cfg = rs.conf()
&#123;
  _id: &#39;rs0&#39;,
  version: 4,
  term: 30,
  members: [
    &#123;
      _id: 0,
      host: &#39;127.0.0.1:27017&#39;,
      arbiterOnly: false,
      buildIndexes: true,
      hidden: false,
      priority: 1,
      tags: &#123;&#125;,
      secondaryDelaySecs: Long(&quot;0&quot;),
      votes: 1
    &#125;,
    &#123;
      _id: 1,
      host: &#39;127.0.0.1:27117&#39;,
      arbiterOnly: false,
      buildIndexes: true,
      hidden: false,
      priority: 1,
      tags: &#123;&#125;,
      secondaryDelaySecs: Long(&quot;0&quot;),
      votes: 1
    &#125;
  ],
  protocolVersion: Long(&quot;1&quot;),
  writeConcernMajorityJournalDefault: true,
  settings: &#123;
    chainingAllowed: true,
    heartbeatIntervalMillis: 2000,
    heartbeatTimeoutSecs: 10,
    electionTimeoutMillis: 10000,
    catchUpTimeoutMillis: -1,
    catchUpTakeoverDelayMillis: 30000,
    getLastErrorModes: &#123;&#125;,
    getLastErrorDefaults: &#123; w: 1, wtimeout: 0 &#125;,
    replicaSetId: ObjectId(&quot;616d08c744db747bb7e580b8&quot;)
  &#125;
&#125;
</code></pre>
<p>删除第一节点，</p>
<pre><code>cfg.members.splice(0,1)
</code></pre>
<p>强制执行重新配置</p>
<pre><code>rs.reconfig(cfg, &#123;force : true&#125;)
</code></pre>
<h3 id="5）设置复制集。"><a href="#5）设置复制集。" class="headerlink" title="5）设置复制集。"></a>5）设置复制集。</h3><p>通过用户名密码登录</p>
<pre><code>mongosh --port 27117 -u testuser -p 123 --authenticationDatabase  test 
</code></pre>
<h3 id="6）Mac环境设置-maxfile-limit"><a href="#6）Mac环境设置-maxfile-limit" class="headerlink" title="6）Mac环境设置 maxfile limit"></a>6）Mac环境设置 maxfile limit</h3><p>查看当前设置：</p>
<pre><code>launchctl limit maxfiles
</code></pre>
<p>如果soft limit是256，则执行下面命令扩大。否则mongo server可用的线程将受限。</p>
<pre><code>sudo launchctl limit maxfiles 65536 200000
</code></pre>
<p>因为机器重启后以上更改会失效，所以还需要添加以上命令到开机脚本中。因为使用到了sudo，可使用 visudo 修改设置免密码。</p>
<pre><code>%admin          ALL = (ALL) NOPASSWD: ALL
</code></pre>
<h3 id="7）mongo-conf"><a href="#7）mongo-conf" class="headerlink" title="7）mongo.conf"></a>7）mongo.conf</h3><p>mongo.conf 大致如此：<br>如果需要设置MongoDB无需认证登录的话，需要authrozation、keyFile这两个字段同时注释掉。·</p>
<pre><code>systemLog:
  destination: file
  path: /usr/local/var/log/mongodb/mongo.log
  logAppend: true
storage:
  dbPath: /usr/local/var/mongodb
net:
  bindIp: 127.0.0.1
  port: 27017
  maxIncomingConnections: 4096
security:
  keyFile: /YOURPATH/mongo_server.key
  authorization: enabled
replication:
  replSetName: rs0
</code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-mongo/mongodb-script-collection-fields-size-quantile-analysis" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.275Z"><a href="/2025/01/26/mongo/mongodb-script-collection-fields-size-quantile-analysis/">2025-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/26/mongo/mongodb-script-collection-fields-size-quantile-analysis/">MongoDB脚本：集合中字段数据大小的分位数统计</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="查询某个collection-的文档大小分布"><a href="#查询某个collection-的文档大小分布" class="headerlink" title="查询某个collection 的文档大小分布"></a>查询某个collection 的文档大小分布</h3><p>日常开发中，有时需要了解数据分布的一些特点，比如这个colllection里documents的平均大小、全部大小等，来调整程序的设计。<br>对于系统中已经存在大量数据的情况，这种提前分析数据分布模式的工作套路（最佳实践）可以帮助我们有的放矢的进行设计，避免不必要的过度设计或者进行更细致的设计。</p>
<p>如果想获得某个collection相关的各种存储统计信息，可以使用 **<a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v6.0/reference/method/db.collection.stats/">stats</a>、<a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v6.0/reference/operator/aggregation/collStats/">collStats</a>**。</p>
<p>如果想获取总计、平均等简单的统计信息，可以参考这里：<a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/core/aggregation-pipeline/#std-label-aggregation-pipeline%E3%80%82">https://www.mongodb.com/docs/manual/core/aggregation-pipeline/#std-label-aggregation-pipeline。</a></p>
<p>下面的命令可以显示 COLLECTION 中满足条件status=’active’，字段FIELD_A， FIELD_B的数据大小的Quantile analysis。<br>如果去掉第三行，就是对COLLECTION中所有文档数据的大小分布的统计。</p>
<pre><code>//最大的Top10和百分比分布。
db.COLLECTION.aggregate([
  &#123; $match: &#123; &quot;status&quot;: &#39;active&#39; &#125; &#125;,
  &#123; $project: &#123; _id: 1, FIELD_A: 1, FIELD_B: 1&#125; &#125;,
  &#123; $project: &#123; documentSize: &#123; $sum: &#123; $bsonSize: &quot;$$ROOT&quot; &#125; &#125; &#125; &#125;,
  &#123; $sort: &#123; documentSize: 1 &#125; &#125;,
  &#123; $group: &#123; &#39;_id&#39;: null, &#39;value&#39;: &#123; &#39;$push&#39;: &#39;$documentSize&#39; &#125; &#125; &#125;,
  &#123; $project: &#123; _id: 0, 
      &quot;Top1&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-1, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top2&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-2, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top3&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-4, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top4&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-5, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top5&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-6, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top6&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-7, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top7&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-7, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top8&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-8, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top9&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-9, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top10&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-10, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;99-9%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.999, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;99%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.99, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;95%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.95, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;90%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.90, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;50%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.50, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;25%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.25, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
    &#125; &#125;,
  ]);
  
</code></pre>
<p>对MongoDB 4.2以上版本，可以使用上述aggrigation 语法进行统计。对4.2及其以下版本，需要使用forEach语句迭代进行计算。<br>对于不支持Object.bsonsize的Mongo shell可以使用 BSON.calculateObjectSize 进行替代。</p>
<pre><code>// const BSON = require(&quot;bson&quot;);
var fieldsSize = []
var totalSize = 0
db.COLLECTION.find(&#123; &quot;status&quot;: &#39;A&#39; &#125;, &#123; FIELD_A: 1, FIELD_B: 1&#125;).forEach(function(doc)
&#123;
  var size = Object.bsonsize(doc)
//   var size = BSON.calculateObjectSize(doc)
  totalSize += size
  fieldsSize.push(size)
&#125;);
var sortedData = fieldsSize.sort(function(a, b)&#123;return a-b&#125;);
var statistic = &#123;
    &quot;Note&quot;: &quot;The Collection Fields(FIELD_A, FIELD_B) Size Statistic Reuslt&quot;,    
    &quot;numbOfDocs&quot;: sortedData.length,
    &quot;totalSize&quot;: (totalSize / 1024) + &quot;KB    &quot; +  (totalSize / (1024 * 1024)) + &quot; MB&quot;,
    &quot;AVG:&quot;: Math.round(totalSize / sortedData.length),
    &quot;MIN&quot;: sortedData[0],
    &quot;TOP1&quot;: sortedData[sortedData.length - 1],
    &quot;TOP2&quot;: sortedData[sortedData.length - 2],
    &quot;TOP3&quot;: sortedData[sortedData.length - 3],
    &quot;TOP4&quot;: sortedData[sortedData.length - 4],
    &quot;TOP5&quot;: sortedData[sortedData.length - 5],
    &quot;TOP6&quot;: sortedData[sortedData.length - 6],
    &quot;TOP7&quot;: sortedData[sortedData.length - 7],
    &quot;TOP8&quot;: sortedData[sortedData.length - 8],
    &quot;TOP9&quot;: sortedData[sortedData.length - 9],
    &quot;TOP10&quot;: sortedData[sortedData.length - 10],
    &quot;99.9%&quot;: sortedData[Math.floor(sortedData.length * 0.999)],
    &quot;99%&quot;: sortedData[Math.floor(sortedData.length * 0.99)],
    &quot;95%&quot;: sortedData[Math.floor(sortedData.length * 0.95)],
    &quot;90%&quot;: sortedData[Math.floor(sortedData.length * 0.90)],
    &quot;75%&quot;: sortedData[Math.floor(sortedData.length * 0.75)],
    &quot;50%&quot;: sortedData[Math.floor(sortedData.length * 0.5)],
    &quot;25%&quot;: sortedData[Math.floor(sortedData.length * 0.25)],
    &quot;10%&quot;: sortedData[Math.floor(sortedData.length * 0.10)]
&#125;;

print(statistic)
</code></pre>
<br/>
------

<p>_References:<br>[1]: <a target="_blank" rel="noopener" href="https://database.guide/2-ways-to-get-a-documents-size-in-mongodb/">https://database.guide/2-ways-to-get-a-documents-size-in-mongodb/</a><br>[2]: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22008822/how-to-get-the-size-of-single-document-in-mongodb">https://stackoverflow.com/questions/22008822/how-to-get-the-size-of-single-document-in-mongodb</a><br>[3]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v4.2/reference/command/collStats/">https://www.mongodb.com/docs/v4.2/reference/command/collStats/</a><br>[4]: <a target="_blank" rel="noopener" href="https://database.guide/mongodb-binarysize/">https://database.guide/mongodb-binarysize/</a><br>[5]: <a target="_blank" rel="noopener" href="https://database.guide/mongodb-object-bsonsize/">https://database.guide/mongodb-object-bsonsize/</a><br>[6]: <a target="_blank" rel="noopener" href="https://flowygo.com/en/blog/mongodb-compass-extract-statistics-using-aggregation-pipeline/">https://flowygo.com/en/blog/mongodb-compass-extract-statistics-using-aggregation-pipeline/</a><br>[7]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/aggregation/">https://www.mongodb.com/docs/manual/aggregation/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-mongo/MongoDB-User-Authentication" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.275Z"><a href="/2025/01/26/mongo/MongoDB-User-Authentication/">2025-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/26/mongo/MongoDB-User-Authentication/">MongoDB的用户管理</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>如果在配置文件中eanble了 authorization，那么用这样的配置启动MongoDB后。如果不是root用户去创建用户会遇到一些权限问题。</p>
<pre><code>security:
  authorization: enabled
</code></pre>
<p>/usr/local/opt/mongodb-community/bin/mongod –config /usr/local/etc/mongod.conf</p>
<p>如果你忘记的root用户或者其它管理员用户的密码，那么可以先以无权限控制的方式启动MongoDB：</p>
<pre><code>mongod --port 27017 --dbpath /usr/local/var/mongodb
</code></pre>
<p>再连接到MongoDB：</p>
<pre><code>mongo --port 27017
</code></pre>
<p>根据需要可以更改用户密码或者创建新用户：</p>
<pre><code>db.changeUserPassword(&quot;root&quot;, passwordPrompt())
db.changeUserPassword(&quot;root&quot;, &quot;password&quot;)

db.createUser(&#123;
    &quot;user&quot;: &quot;dahui&quot;,
    &quot;pwd&quot;: &quot;password&quot;,
    &quot;roles&quot;:
    [
        &#123;
            &quot;role&quot;: &quot;userAdminAnyDatabase&quot;,
            &quot;db&quot;: &quot;admin&quot;
        &#125;,
        &quot;readWriteAnyDatabase&quot;
    ]
&#125;);
</code></pre>
<p>添加完这种带有 userAdminAnyDatabase 角色的用户后，关闭MongoDB server：</p>
<pre><code>db.adminCommand( &#123; shutdown: 1 &#125; )
</code></pre>
<p>再以有权限控制的方式重新启动MongoDB Server。（/usr/local/etc/mongod.conf 中设置了 authorization: enabled）</p>
<pre><code>mongod --config /usr/local/etc/mongod.conf
或
mongod --auth --port 27017 --dbpath /var/lib/mongodb
</code></pre>
<p>这样使用拥有 userAdminAnyDatabase 角色的用户登录后，就可以通过使用use DB_NAME 的方式给不同的DB添加用户了。</p>
<pre><code>mongosh --port 27017 -u admin -p password --authenticationDatabase admin

mongosh &quot;mongodb://admin:password@127.0.0.1:27017/center0?authSource=admin&quot;
</code></pre>
<br/>

<hr>
<p><em>Reference:</em><br>[1]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v5.0/tutorial/enable-authentication/">https://www.mongodb.com/docs/v5.0/tutorial/enable-authentication/</a><br>[2]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/reference/method/js-user-management/">https://www.mongodb.com/docs/manual/reference/method/js-user-management/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-network/tcp_close-wait_time-wait" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.275Z"><a href="/2025/01/26/network/tcp_close-wait_time-wait/">2025-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/26/network/tcp_close-wait_time-wait/">关于TCP的好文章</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h4 id="关于挥手中的close-wait-time-wait。"><a href="#关于挥手中的close-wait-time-wait。" class="headerlink" title="关于挥手中的close-wait, time-wait。"></a>关于挥手中的close-wait, time-wait。</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&mid=402163560&idx=1&sn=5269044286ce1d142cca1b5fed3efab1&3rd=MzA3MDU4NTYzMw==&scene=6#rd">又见CLOSE_WAIT</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903734300901390">线上大量CLOSE_WAIT的原因深入分析</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/9988354.html">TCP连接的TIME_WAIT和CLOSE_WAIT 状态解说</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Jt2ss3SsE_iGJp5oW8QDSw">高性能网络 | 你所不知道的TIME_WAIT和CLOSE_WAIT</a></p>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-notes/cas/Apereo-CAS-Management-UI" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.275Z"><a href="/2025/01/26/notes/cas/Apereo-CAS-Management-UI/">2025-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/26/notes/cas/Apereo-CAS-Management-UI/">Apereo CAS 之 管理界面</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>类似cas-server，先下载cas-management-overlay代码，这里使用6.5分支。</p>
<pre><code>$ git clone https://github.com/apereo/cas-management-overlay cas-management   
$ cd cas-management   
$ git checkout -b 6.5 origin/6.5
</code></pre>
<p>cas-management应用本身也需要用户认证之后才能使用。这里使用它自己要管理的cas-server作为认证源。这时，cas-manager本身就是cas-server的一个client或者说service了。<br>因此需要首先 __把management配置为cas-server的一个client/service__。</p>
<p>Apereo支持不同的存储service注册的方式：json文件、JPA、Redis …，这里使用json文件的方式把cas-management注册为cas-server的service，即让cas-manager使用cas-server来认证用户。</p>
<h3 id="1）在cas-server的build-gradle中添加依赖。"><a href="#1）在cas-server的build-gradle中添加依赖。" class="headerlink" title="1）在cas-server的build.gradle中添加依赖。"></a>1）在cas-server的build.gradle中添加依赖。</h3><p>可参考官方文档：<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/services/Service-Management.html#storage">https://apereo.github.io/cas/6.5.x/services/Service-Management.html#storage</a></p>
<pre><code>implementation &quot;org.apereo.cas:cas-server-support-json-service-registry:$&#123;project.&#39;cas.version&#39;&#125;&quot;
</code></pre>
<h3 id="2）告诉cas-server-在哪里可以找到定义client-service的json文件"><a href="#2）告诉cas-server-在哪里可以找到定义client-service的json文件" class="headerlink" title="2）告诉cas-server 在哪里可以找到定义client/service的json文件"></a>2）告诉cas-server 在哪里可以找到定义client/service的json文件</h3><p>在文件 etc/cas/config/cas.properties 中加入如下配置：<br><code>cas.service-registry.json.location=classpath:/services</code></p>
<p>在cas-server 项目的 src/resources 目录下创建一个名为casManagement-2000.json的文体。文件名的格式是 clientName + clientId.json，具体请阅读官方文档。</p>
<pre><code>&#123;
  &quot;@class&quot; : &quot;org.apereo.cas.services.RegexRegisteredService&quot;,
  &quot;serviceId&quot; : &quot;^(https|imaps)://.*&quot;,
  &quot;name&quot; : &quot;casManagement&quot;,
  &quot;id&quot; : 2000,
  &quot;logoutType&quot; : &quot;BACK_CHANNEL&quot;,
  &quot;logoutUrl&quot; : &quot;https://localhost:8444/cas-management/logout&quot;
&#125;
</code></pre>
<h3 id="3）配置cas-management"><a href="#3）配置cas-management" class="headerlink" title="3）配置cas-management"></a>3）配置cas-management</h3><p>上面两步是配置cas-server以把cas-manager作为它的client。现在，配置cas-management。<br>编辑 cas-management 项目里的 etc/case/config/management.properties 文件，内容如下。</p>
<pre><code>cas.server.name=https://localhost:8443
cas.server.prefix=$&#123;cas.server.name&#125;/cas

server.port=8444
mgmt.server-name=https://localhost:8444
mgmt.admin-roles[0]=ROLE_ADMIN
mgmt.user-properties-file=file:/etc/cas/config/users.json

logging.config=file:/etc/cas/config/log4j2-management.xml

server.ssl.key-store=file:/etc/cas/thekeystore
server.ssl.key-store-password=changeit

# Let the cas-management to know where to find/save the registed services
cas.service-registry.json.location=file:YOUR_PATH_TO_DIR_CONTAINS_JSONFILES/services
</code></pre>
<p>需要注意的是要保证cas.server 和 mgmt server的端口不要冲突，一个是8443，一个是8444。<br>这里方便起见，cas-management和 cas-server共享了同一个keystore。</p>
<p>配置项<code>cas.service-registry.json.location</code>告诉cas-management到哪里去读写(管理)定义client/service的json文件。这个目录<br>是和cas-server的 <code>cas.service-registry.json.location=classpath:/services</code> 是一致的。</p>
<h3 id="4）-同时运行cas-server，cas-management后，访问-https-localhost-8444-cas-management"><a href="#4）-同时运行cas-server，cas-management后，访问-https-localhost-8444-cas-management" class="headerlink" title="4） 同时运行cas-server，cas-management后，访问 https://localhost:8444/cas-management/"></a>4） 同时运行cas-server，cas-management后，访问 <a target="_blank" rel="noopener" href="https://localhost:8444/cas-management/">https://localhost:8444/cas-management/</a></h3><p><img src="/2025/01/25/notes/cas/Apereo-CAS-Management-UI/apereo_cas_mgmt_ui.jpg" alt="CAS-Management-UI"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-micro_service/glimpse-of-saga" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.270Z"><a href="/2025/01/26/micro_service/glimpse-of-saga/">2025-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/26/micro_service/glimpse-of-saga/">glimpse of saga</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>项目中遇到多个微服务调用需要考虑和处理某个环节失败时的处理。虽然这里不需要很强的事务概念，但是需要对失败的动作进行重试等操作。这里的重试本质上就是rollback的另一种形式，在saga里算是“forward recovery”。<br>借机又翻看了一下相关的文章，贴到了文末。</p>
<h3 id="Saga-vs-TCC"><a href="#Saga-vs-TCC" class="headerlink" title="Saga vs TCC"></a>Saga vs TCC</h3><ol>
<li>Saga相比TCC的缺点是缺少预留动作，所以某些情况补偿的实现比较麻烦甚至无法撤销只能补救。不过没有预留动作也意味着不必担心资源释放的问题。</li>
<li>TCC最少通信次数为2n，Saga为n（n=sub-transaction的数量）。</li>
<li>第三方服务没需要提供有Try接口。<br>总体感觉下来SAGA更适合微服务的多数场景。</li>
</ol>
<h3 id="Simple-Saga"><a href="#Simple-Saga" class="headerlink" title="Simple Saga"></a>Simple Saga</h3><p>解决这类问题当然可以直接引入一些已存在的saga框架，不过这里存在学习、部署等成本。如果只是小范围的解决问题，或许可以使用下面的形式。<br><img src="/2025/01/25/micro_service/glimpse-of-saga/poc.jpg" alt="示意图"><br>上面示意图针对的场景是：服务的执行都需要较长时间、并且是异步调用。<br>如果各个服务执行时间都不长，一个调用链下来小于几百毫秒，那么直接使用reactive style的编码也应该可以。<br>因为各服务执行时间较长，所以不能使用同步调用。这里耗时指的是对于有UI的程序至少影响到到UI前的用户，如果是后台应用那么至少阻塞的时长影响到系统的资源可用性。<br>即使服务执行时间短，同步调用也会使调用链的availability降低，所以微服务的场景下使用异步调用有天然的好处。  </p>
<p>从这个示意图其实可以看作是Chris演讲中提到的最最原始的模式。可以把callback看作是saga事务参与方发送消息到message broker。而调用链的第一个节点就充当了saga的协调者。<br>各个微服务的updateStatus端点就是message的listner，只不过这里直接通过callback实现而没有利用消息队列。<br>最开始的endpoint负责生成一个transactionId并依次传递给每个下游服务，每个下游服务通过callback把自己的状态更新给上游。</p>
<ol>
<li><p>getStatus() 端点提供给UI获取当前状态。<br><img src="/2025/01/25/micro_service/glimpse-of-saga/ui_option.png" alt="UI上的状态显示"></p>
</li>
<li><p>transCheckAndAmend(trans_n) 每个服务暴露的业务方法都需要提供一个补偿方法。<br><img src="/2025/01/25/micro_service/glimpse-of-saga/tc.png" alt="Compensating transactions"></p>
</li>
<li><p>服务的入口方法其实充当了协调者, 更像orchestration的，而不是choreography的。</p>
</li>
<li><p>Timer 是个后台定时器不停的检查服务状态，如果状态不成功就调用compensating endpoint.</p>
</li>
</ol>
<p><em>Reference:</em><br>[1]: Saga的经典论文 <a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf</a><br>[2]: 《Microservice Pattern》”Chapter4, Managing transactions with sagas”<br>[3]: Chris Richardson 在2017年的演讲：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=YPbGW3Fnmbc">https://www.youtube.com/watch?v=YPbGW3Fnmbc</a>   </p>
<p>一些中文网文：<br>[3] 分布式事务：Saga模式 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4b662407c66">https://www.jianshu.com/p/e4b662407c66</a><br>[4] 七种分布式事务的解决方案 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1806989">https://cloud.tencent.com/developer/article/1806989</a><br>[5] 分布式事务六种解决方案 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/183753774">https://zhuanlan.zhihu.com/p/183753774</a>   </p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="as_sitesearch" value="dhyuan.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/AWS/">AWS</a><small>2</small></li>
  
    <li><a href="/tags/CAS/">CAS</a><small>5</small></li>
  
    <li><a href="/tags/Concurrency/">Concurrency</a><small>6</small></li>
  
    <li><a href="/tags/DevOps/">DevOps</a><small>31</small></li>
  
    <li><a href="/tags/FP/">FP</a><small>2</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
  
    <li><a href="/tags/Ingerss/">Ingerss</a><small>1</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>10</small></li>
  
    <li><a href="/tags/Kubernetes/">Kubernetes</a><small>3</small></li>
  
    <li><a href="/tags/Maven/">Maven</a><small>2</small></li>
  
    <li><a href="/tags/MicroService/">MicroService</a><small>3</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>6</small></li>
  
    <li><a href="/tags/Nginx/">Nginx</a><small>2</small></li>
  
    <li><a href="/tags/Reactive/">Reactive</a><small>8</small></li>
  
    <li><a href="/tags/SAGA/">SAGA</a><small>1</small></li>
  
    <li><a href="/tags/Scala/">Scala</a><small>7</small></li>
  
    <li><a href="/tags/Security/">Security</a><small>12</small></li>
  
    <li><a href="/tags/Spring/">Spring</a><small>14</small></li>
  
    <li><a href="/tags/android/">android</a><small>1</small></li>
  
    <li><a href="/tags/network/">network</a><small>2</small></li>
  
    <li><a href="/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><small>13</small></li>
  
    <li><a href="/tags/%E7%BD%91%E4%B8%8A%E5%A5%BD%E6%96%87/">网上好文</a><small>1</small></li>
  
  </ul>
</div>


  
  <div class="widget widget-archives">
    <h3 class="title">归档</h3>
    <div class="entry">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2025 Dahui
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
