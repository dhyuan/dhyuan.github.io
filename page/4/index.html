<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | 浅流</title>
  <meta name="author" content="Dahui">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="浅流"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">浅流</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-reactive/reactive_stream_lifecycle" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-04-13T13:09:32.000Z"><a href="/2021/04/14/reactive/reactive_stream_lifecycle/">2021-04-14</a></time>
      
      
  
    <h1 class="title"><a href="/2021/04/14/reactive/reactive_stream_lifecycle/">响应式流的生命周期</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>这里所说的响应式流的生命周期是说我们从定义响应式流到触发这个流的处理所经历的不同阶段。<br>总的来说，就是三个阶段。组装时、订阅时、运行时。</p>
<h2 id="组装时"><a href="#组装时" class="headerlink" title="组装时"></a>组装时</h2><p>这个阶段就是我们建立处理模型的阶段。基本上是解决了下面 3 个方面的问题。</p>
<h3 id="1）定义这个-reactive-stream-的数据来源是什么。Publisher"><a href="#1）定义这个-reactive-stream-的数据来源是什么。Publisher" class="headerlink" title="1）定义这个 reactive stream 的数据来源是什么。Publisher"></a>1）定义这个 reactive stream 的数据来源是什么。Publisher</h3><p>这个阶段我们通过使用诸如 just(), range(), fromArray(), push(), create(), generate()等方法来设置数据源头。</p>
<h3 id="2）这个数据流的最终订阅者是谁？Subscriber"><a href="#2）这个数据流的最终订阅者是谁？Subscriber" class="headerlink" title="2）这个数据流的最终订阅者是谁？Subscriber"></a>2）这个数据流的最终订阅者是谁？Subscriber</h3><p>我们在最下游 publisher 上通过调用 subscribe()方法把 subscriber 从下游到上游依次传递到最上游的包含数据源的 publisher。</p>
<h3 id="3）数据到达最终订阅者那里时需要做哪些转换、处理？-Operator"><a href="#3）数据到达最终订阅者那里时需要做哪些转换、处理？-Operator" class="headerlink" title="3）数据到达最终订阅者那里时需要做哪些转换、处理？ Operator"></a>3）数据到达最终订阅者那里时需要做哪些转换、处理？ Operator</h3><p>以上两个调用解决了数据来源于哪里、被谁最终接收的问题。但是在数据从上游被传递到下游的过程中，我们往往需要对数据做各种处理。这个阶段就各种 operator 大显身手的地方，比如 map(), flatMap(), filter(), reduce(), scan(), concatMap(), usingWhen()… …<br>实际上每经历一个 operator，就生成了一个新的中间级别的 publisher，这就是 reactive stream 的不可变性。</p>
<p>组装时基本就是我们写出的代码定义出的静态逻辑这部分。<br>程序运行起来，才会进入下面的两个阶段：订阅时、运行时，所以说这两个阶段是程序的动态表现。</p>
<h2 id="订阅时"><a href="#订阅时" class="headerlink" title="订阅时"></a>订阅时</h2><p>通过组装时我们定义了什么数据(publisher)经过怎样的处理(operator)最后传递给谁(subscriber)。而订阅时这个阶段，解决的问题是把调用下游 publisher 时传入的 subscriber 依次传递给上游的的 publisher。可以想象 Project Reactor 在传递 subscriber 的时候是依次进行封装之后传递的而不会是直接把下游的 subscriber 传递上去，因为以 operator 串联起来的各个 publisher 都需要“自己”的 subscriber。可以体会下这里“Subscriber 链”的概念。<br>这个传递过程很重要，因为 subscriber 中的 onSubscribe(Subscription s)提供了上游 publisher 把 Subscription 传递给下游 Subscriber 的机制。<br>因为 Subscriber 只有通过 subsciption 的 request 方法才能启动数据的流动。</p>
<h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p>经过组装时、订阅时，数据流已经“一触即发”。我们只有通过上游传递给我们的 Subscription 调用 request()方法就可以触发数据的流动了。<br>通过（在 Subscirberd 的 onSubscription(), onNext()被回调时）向 Subscription 的 request()传入不同的数字，我们分别可以实现拉模型、推模型、拉-推模型。<br>响应式流的运行时所强调的就是这种 Publisher 和 Subscriber 之间的信号交换。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-micro_service/keywords_of_cipher" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-04-08T12:50:59.000Z"><a href="/2021/04/09/micro_service/keywords_of_cipher/">2021-04-09</a></time>
      
      
  
    <h1 class="title"><a href="/2021/04/09/micro_service/keywords_of_cipher/">与加密相关的一些名词</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="1-密码学"><a href="#1-密码学" class="headerlink" title="1) 密码学"></a>1) 密码学</h2><h3 id="机密性、真实性、完整性"><a href="#机密性、真实性、完整性" class="headerlink" title="机密性、真实性、完整性"></a>机密性、真实性、完整性</h3><p>plantext 明文 cipher 密钥 ciphertext 密文</p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>将任意长度的输入转化为定长输出的算法。抗原像性、抗第二原像性、强抗碰撞性。指纹、摘要。</p>
<h3 id="消息验证代码：MAC-HMAC-Keyed-hash-Message-Authentication-Code"><a href="#消息验证代码：MAC-HMAC-Keyed-hash-Message-Authentication-Code" class="headerlink" title="消息验证代码：MAC HMAC(Keyed-hash Message Authentication Code)"></a>消息验证代码：MAC HMAC(Keyed-hash Message Authentication Code)</h3><p>MAC：核心是带密钥的 Hash 算法。<br>HMAC：两轮 Hash，其中一个是密钥是“预共享密钥”。<br>Msg + K –&gt;MAC 算法 –&gt; MAC 随消息发送<br>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/pz641/article/details/110876060">https://blog.csdn.net/pz641/article/details/110876060</a></p>
<h3 id="对称加密（私钥加密）"><a href="#对称加密（私钥加密）" class="headerlink" title="对称加密（私钥加密）"></a>对称加密（私钥加密）</h3><p>对称密钥算法相关主流协议：DES、3DES、AES、RC4。<br>序列密码(Stream Cipher)、分组密码(Block Cipher)<br>RC4 属于序列密码，AES 算是最流行的分组密码，无线安全技术 WPA2 就是使用 AES。<br>分组密码：ECB、CBC。CBC 引入了初始向量 IV 让每即使相同的输入输出也不同。（IV 与明文第一块进行异或过后加密，加密后的密文作为下一个块的 IV）</p>
<h3 id="非对称加密（公钥加密）"><a href="#非对称加密（公钥加密）" class="headerlink" title="非对称加密（公钥加密）"></a>非对称加密（公钥加密）</h3><p>公钥加密只有私钥可以解密。<br>私钥加密公钥解密。无私密性、可做数字签名。<br>RAS 使用最多的非对称加密算法。 RAS 推荐强度 2048，相当于 112 的对称加密。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>MAC 是一种电子签名，但需要双方预先设定一样的加密密码。<br>RSA 情况下的数字签名。<br>发送方<br>1）求文档 Hash 值<br>2）对 结果散列 + hash 算法 + 其它元数据 进行编码<br>3）用私钥加密编码后的数据，形成签名<br>接收方<br>1）使用相同 Hash 算法计算文档散列<br>2）用公钥解密发送方的签名，并与自己计算的进行对比。<br>RAS 只是公钥加密的一种，不同的公钥加密有不同的签名流程。</p>
<h3 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h3><p>密钥交换的目的是先得到 预主密钥。<br>密钥交换算法：RSA、DHE_RSA、。。。<br>RSA 不支持前向保密</p>
<p>下图是 Diffie-Hellman 密钥交换示意图：<br><img src="/2021/04/08/micro_service/keywords_of_cipher/DH.jpeg"></p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>证书是包含公钥、订阅人信息、证书颁发者数字签名的数字文件，是存储、传递、使用公钥的容器。</p>
<h3 id="RSA-公钥、私钥的生成"><a href="#RSA-公钥、私钥的生成" class="headerlink" title="RSA 公钥、私钥的生成"></a>RSA 公钥、私钥的生成</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41259576/article/details/91356419">https://blog.csdn.net/qq_41259576/article/details/91356419</a></p>
<h2 id="2）SSL-TLS"><a href="#2）SSL-TLS" class="headerlink" title="2）SSL/TLS"></a>2）SSL/TLS</h2><p>TLS 是一种密码学协议以保证双方会话安全。TLS 是在 TCP 协议之上、HTTP 协议之下–处于表示层。<br>TLS 主要分为两层，底层的是 TLS 记录协议，主要负责使用对称密码对消息进行加密。上层的是 TLS 握手协议，主要分为握手协议，密码规格变更协议和应用数据协议 4 个部分。</p>
<p>SSL 1.0， 2.0 1994-11 月<br>SSL 3.0 1995 年底<br>TLS 1.0 1999-1<br>TLS 1.1 2006-4<br>TLS 1.2 2008-8<br>TLS 1.3 2018-8 1）握手更快；2）淘汰了一些基元 RC4, SHA-1, DES, MD5 …<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/133375078">https://zhuanlan.zhihu.com/p/133375078</a></p>
<h3 id="握手流程"><a href="#握手流程" class="headerlink" title="握手流程"></a>握手流程</h3><p>有三种握手流程：对服务器进行身份验证的完整握手、用于恢复会话的简短握手、对服务器客户端进行双向验证的握手。<br>这里仅简短描述下“对服务器进行身份验证的完整握手”，如下图：<br><img src="/2021/04/08/micro_service/keywords_of_cipher/TLS_Handshake.png"></p>
<h4 id="1）ClientHello"><a href="#1）ClientHello" class="headerlink" title="1）ClientHello"></a>1）ClientHello</h4><p>很明显，第一条消息始于 Client。客户端需要提供自己 TLS 版本、随机数、加密套件、压缩方法、扩展信息给服务端，让服务端进行选择。</p>
<h4 id="2）ServerHello"><a href="#2）ServerHello" class="headerlink" title="2）ServerHello"></a>2）ServerHello</h4><p>这条消息是服务器根据 Client 上报的选项并结合自己的的情况把选择告诉 Client。这个消息中也包括一个随机数。注意 ClientHello、ServerHello 中的随机数不是用于生成预主密钥，而是用于防止消息伪造。</p>
<h4 id="3）Certificate"><a href="#3）Certificate" class="headerlink" title="3）Certificate"></a>3）Certificate</h4><p>这是服务器给客户端的证书链。注意，这里是证书链而不仅仅是服务器的主证书。主证书排第一个、随后依次是中间证书，根证书无需在此链中。<br>因为客户端发送的密码套件、服务器最终选择的密码套件未必需要身份认证，同时不是所有身份认证都需要证书，所以，这个消息是可选的。</p>
<h4 id="4）ServerKeyExchange"><a href="#4）ServerKeyExchange" class="headerlink" title="4）ServerKeyExchange"></a>4）ServerKeyExchange</h4><p>这个消息是为服务器为密钥交换向客户端提供数据。如是 DH 算法，那么这个参数就是 如上“Diffie-Hellman 密钥交换示意图”中所示的 g、p、A。<br>微观到代码，就是大致如下的定义：</p>
<pre><code>struct &#123;
          opaque dh_p&lt;1..2^16-1&gt;;
          opaque dh_g&lt;1..2^16-1&gt;;
          opaque dh_Ys&lt;1..2^16-1&gt;;
      &#125; ServerDHParams;     /* Ephemeral DH parameters */
</code></pre>
<p>对于需要两次消息确定预主密钥的算法，首先由服务器发起也很容易理解。因为是 Client 首先提供选项而 Server 进行选择，那么 Server 自然是首先发出 DH 密钥交换消息就是很正常的了。<br>如果协商的密钥交换算法是 RSA 密钥交换算法，那么服务器就无需发送这条消息，而是由 Client 通过在 ClientKeyExchange 中携带一个 46 字节的随机数作为预主密钥即可。</p>
<h4 id="5）ServerHelloDone"><a href="#5）ServerHelloDone" class="headerlink" title="5）ServerHelloDone"></a>5）ServerHelloDone</h4><p>这个消息表示 Server 这边的握手相关的消息都发送完了。</p>
<h4 id="6）ClientKeyExchange"><a href="#6）ClientKeyExchange" class="headerlink" title="6）ClientKeyExchange"></a>6）ClientKeyExchange</h4><p>这个消息是为了 Sever 提供密钥交换的数据。<br>如果是 RSA 密钥交换算法，Client 用 46 字节的随机数作为预主密钥发送给 Server 即可。如果是 DH 算法，就是如“Diffie-Hellman 密钥交换示意图”中所示的数字 B。<br>至此，预主密钥(premaster secret)就协商完毕了。真正用于加密的 master secret 是由预主密钥经过进一步变化而生成。</p>
<h4 id="7）ChangeCipherExchange"><a href="#7）ChangeCipherExchange" class="headerlink" title="7）ChangeCipherExchange"></a>7）ChangeCipherExchange</h4><p>这个消息表示已经生成加密密钥了，即将切换到的加密模式。</p>
<h4 id="8）Finished"><a href="#8）Finished" class="headerlink" title="8）Finished"></a>8）Finished</h4><p>这个消息表示握手结束，消息内容即将加密。这个消息中很重要的一个字段是 verify_data, 其值是用<strong>协商得到的主密钥</strong>结合<strong>协商确定的 MAC 算法</strong>对所有<strong>按序排列的握手消息</strong>进行计算得到的散列值。这里可以体会下 CilentHello、ServerHello 这些握手消息中的随机数的作用。</p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>《HTTPS 权威指南》<br>《IPSec VPN 实战指南》<br><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5246">https://tools.ietf.org/html/rfc5246</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-micro_service/http_nginx_to_https_upstream" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-04-07T12:21:32.000Z"><a href="/2021/04/08/micro_service/http_nginx_to_https_upstream/">2021-04-08</a></time>
      
      
  
    <h1 class="title"><a href="/2021/04/08/micro_service/http_nginx_to_https_upstream/">Nginx以HTTP反向代理HTTPS服务</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>简单记录一下 Nginx 作为反向代理以 HTTP 协议向下游客户端代理使用 Spring Security 实现的上游 HTTPS 服务时遇到的问题及解决办法。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>有个基于 Spring Security、Spring MVC 实现的 HTTPS Web 应用，通过 Nginx 作为反向代理向外提供服务。<br>Nginx 和 Web 应用部署在同一台机器，IP 为 10.115.6.165。Web 应用以 HTTPS 协议监听在端口 19026。<br>如果是 Windows 环境，推荐在 <a target="_blank" rel="noopener" href="http://nginx-win.ecsds.eu/">http://nginx-win.ecsds.eu/</a> 下载编译带入了更多模块的 Nginx，因为在下面我们会需要 headers more 模块中的 more_set_headers 指令。如果是 Linux 环境，也请确认 headers more 模块的 more_set_headers 指令可用。</p>
<h3 id="Nginx-以-HTTP-的方式反向代理。"><a href="#Nginx-以-HTTP-的方式反向代理。" class="headerlink" title="Nginx 以 HTTP 的方式反向代理。"></a>Nginx 以 HTTP 的方式反向代理。</h3><p>用以下配置运行 Ngnix， 使其用 HTTP 协议在 9080 端口反向代理 19026 上的 HTTPS 服务。</p>
<pre><code>server &#123;
    listen       9080;
    server_name  10.115.6.165;

    location /databoard/ &#123;
        proxy_pass  https://10.115.6.165:19026/databoard/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
        proxy_set_header REMOTE-HOST        $remote_addr;
        proxy_set_header X-Forwarded-Proto  $scheme;
        proxy_redirect off;
    &#125;
&#125;
</code></pre>
<p>但是如果我们用浏览器访问<a target="_blank" rel="noopener" href="http://10.115.6.165:9080/databoard/login%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%8F%91%E7%8E%B0%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%E7%9A%84%E4%B8%A4%E9%97%AE%E9%A2%98%EF%BC%9A">http://10.115.6.165:9080/databoard/login，就会发现如下图所示的两问题：</a><br><img src="/2021/04/07/micro_service/http_nginx_to_https_upstream/nginxSetting.png"></p>
<h4 id="1）后端服务使用-redirect-重定向导致的问题"><a href="#1）后端服务使用-redirect-重定向导致的问题" class="headerlink" title="1）后端服务使用 redirect 重定向导致的问题"></a>1）后端服务使用 redirect 重定向导致的问题</h4><p>浏览器地址栏上显示被重定向到了<a target="_blank" rel="noopener" href="https://10.115.6.165/databoard/dataCmder%E3%80%82%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%90%8E%E7%AB%AFWeb%E5%BA%94%E7%94%A8%E6%89%A7%E8%A1%8C%E4%BA%86redirect%E9%87%8D%E5%AE%9A%E5%90%91%E8%AF%AD%E5%8F%A5%EF%BC%8C%E8%80%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8D%8F%E8%AE%AE%E3%80%81%E5%9C%B0%E5%9D%80%E6%98%AF%E5%9F%BA%E4%BA%8Eweb%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%EF%BC%8C%E8%80%8Cnginx%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%81%9A%E7%89%B9%E5%88%AB%E7%9A%84%E5%A4%84%E7%90%86%E5%B0%B1%E8%BD%AC%E5%8F%91%E7%BB%99%E4%BA%86%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E7%84%B6%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E5%88%B0%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%E3%80%82%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E5%A6%82%E4%B8%8B%EF%BC%9A">https://10.115.6.165/databoard/dataCmder。这是因为后端Web应用执行了redirect重定向语句，而重定向的协议、地址是基于web应用上下文的，而nginx并没有做特别的处理就转发给了浏览器，浏览器自然不能访问到这个地址。解决办法如下：</a></p>
<pre><code>map $upstream_http_Location $location &#123;
  ~https://10.115.6.165/(?&lt;param&gt;.*) http://10.115.6.165:9080/$param;
  default $upstream_http_Location;
&#125;

server &#123;
    ... ...
    location /databoard/ &#123;
        ... ...
        more_set_headers -s &#39;301 302&#39; &#39;Location $location&#39;;
</code></pre>
<h4 id="2）Cookie-携带-Secure-属性导致浏览器不能在请求中携带-SessionID-的问题。"><a href="#2）Cookie-携带-Secure-属性导致浏览器不能在请求中携带-SessionID-的问题。" class="headerlink" title="2）Cookie 携带 Secure 属性导致浏览器不能在请求中携带 SessionID 的问题。"></a>2）Cookie 携带 Secure 属性导致浏览器不能在请求中携带 SessionID 的问题。</h4><p>有 Secure 属性的 Cookie 意味着如果浏览器不是用 HTTPS 与服务建立链接，那么这个 cookie 里的值不会随请求一起向服务器发送。所以要解决这个问题就需要在 Nginx 中把 cookie 中的 Secure 属性去掉再传给浏览器。解决办法如下：</p>
<pre><code>map $sent_http_set_cookie $resp_cookie &#123;
    ~*(?&lt;CK_WITHOUT_SECURE&gt;.+)Secure $CK_WITHOUT_SECURE;
&#125;

server &#123;
    ... ...
    location /databoard/ &#123;
        ... ...
        more_set_headers &#39;Set-Cookie: $resp_cookie&#39;;
</code></pre>
<h4 id="完整的相关配置"><a href="#完整的相关配置" class="headerlink" title="完整的相关配置"></a>完整的相关配置</h4><pre><code>map $upstream_http_Location $location &#123;
  ~https://10.115.6.165/(?&lt;param&gt;.*) http://10.115.6.165:9080/$param;
  default $upstream_http_Location;
&#125;

map $sent_http_set_cookie $resp_cookie &#123;
    ~*(?&lt;CK_WITHOUT_SECURE&gt;.+)Secure $CK_WITHOUT_SECURE;
&#125;

server &#123;
    listen       9080;
    server_name  10.115.6.165;

    location /databoard/ &#123;
        proxy_pass  https://10.115.6.165:19026/databoard/;

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
        proxy_set_header REMOTE-HOST        $remote_addr;
        proxy_set_header X-Forwarded-Proto  $scheme;
        proxy_redirect off;

        more_set_headers -s &#39;301 302&#39; &#39;Location $location&#39;;
        more_set_headers &#39;Set-Cookie: $resp_cookie&#39;;
    &#125;
&#125;
</code></pre>
<h3 id="Nginx-以-HTTPS-的方式反向代理。"><a href="#Nginx-以-HTTPS-的方式反向代理。" class="headerlink" title="Nginx 以 HTTPS 的方式反向代理。"></a>Nginx 以 HTTPS 的方式反向代理。</h3><p>如果 nginx 是以 HTTPS 协议向外提供反向代理，那么无论使用七层代理还是四层代理配置起来都很简单，如下：</p>
<h4 id="3）四层反向代理。"><a href="#3）四层反向代理。" class="headerlink" title="3）四层反向代理。"></a>3）四层反向代理。</h4><pre><code>stream &#123;
    upstream databoardServer &#123;
        hash $remote_addr consistent;
        server 10.115.6.165:19026 weight=5;
    &#125;

    server &#123;
        listen 9082;
        proxy_connect_timeout 1s;
        proxy_timeout 3s;
        proxy_pass databoardServer;
    &#125;
&#125;
</code></pre>
<h4 id="4）七层反向代理。"><a href="#4）七层反向代理。" class="headerlink" title="4）七层反向代理。"></a>4）七层反向代理。</h4><pre><code>server &#123;
    listen       443 ssl;
    server_name  10.115.6.165;
    ssl_certificate D:\\tmp\\opensslCrt\\demoAppChain.crt;
    ssl_certificate_key D:\\tmp\\opensslCrt\\demoApp.key;

    location / &#123;
        proxy_pass https://10.115.6.165:19026;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Referer https://10.115.6.165;
    &#125;
&#125;
</code></pre>
<h3 id="关于-Spring-Session-Cookie-Secure-配置"><a href="#关于-Spring-Session-Cookie-Secure-配置" class="headerlink" title="关于 Spring Session Cookie Secure 配置"></a>关于 Spring Session Cookie Secure 配置</h3><p>当时想直接配置 Spring Web 应用不让 Cookie 带上 Secure 属性，这样就不用在 Nginx 上处理 Cookie 了。于是直接修改配置 application.properties 如下，但是返回给 nginx 的 Cookie 还是带 Secure 属性。</p>
<pre><code>server.session.cookie.secure=true
</code></pre>
<p>通过跟踪 Spring 源码发现，只要应用是运行在 HTTPS 协议下的，那么就会让生成的 Cookie 是 Secure 的。<br><img src="/2021/04/07/micro_service/http_nginx_to_https_upstream/secureOverride.png"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-micro_service/secure_your_service_with_https" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-04-01T11:01:36.000Z"><a href="/2021/04/02/micro_service/secure_your_service_with_https/">2021-04-02</a></time>
      
      
  
    <h1 class="title"><a href="/2021/04/02/micro_service/secure_your_service_with_https/">创建基于HTTPS的服务</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="关于私钥、公钥的生成"><a href="#关于私钥、公钥的生成" class="headerlink" title="关于私钥、公钥的生成"></a>关于私钥、公钥的生成</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/charlesblc/p/6130433.html">https://www.cnblogs.com/charlesblc/p/6130433.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41259576/article/details/91356419">https://blog.csdn.net/qq_41259576/article/details/91356419</a></p>
<h3 id="KeyStore-vs-OpenSSL"><a href="#KeyStore-vs-OpenSSL" class="headerlink" title="KeyStore vs OpenSSL"></a>KeyStore vs OpenSSL</h3><h3 id="KeyStore-with-keytool"><a href="#KeyStore-with-keytool" class="headerlink" title="KeyStore with keytool"></a>KeyStore with keytool</h3><p>KeyStor 有三种类型（格式）：JKS， PKCS12 。。</p>
<h4 id="1-创建一个自签名证书和密钥"><a href="#1-创建一个自签名证书和密钥" class="headerlink" title="1. 创建一个自签名证书和密钥"></a>1. 创建一个自签名证书和密钥</h4><pre><code>keytool -genkeypair -keystore demoAppKeyStore.jks \
-alias demoAppServer \
-keyalg RSA \
-keysize 3072 \
-validity 36500 \
-storepass demoApp
</code></pre>
<h4 id="2-导出证书"><a href="#2-导出证书" class="headerlink" title="2. 导出证书"></a>2. 导出证书</h4><pre><code>keytool -export -alias demoAppServer -file demoApp.crt -keystore demoAppKeyStore.keystore
</code></pre>
<h4 id="1-创建一个自签名证书和密钥-1"><a href="#1-创建一个自签名证书和密钥-1" class="headerlink" title="1. 创建一个自签名证书和密钥"></a>1. 创建一个自签名证书和密钥</h4><h4 id="1-创建一个自签名证书和密钥-2"><a href="#1-创建一个自签名证书和密钥-2" class="headerlink" title="1. 创建一个自签名证书和密钥"></a>1. 创建一个自签名证书和密钥</h4><h4 id="1-创建一个自签名证书和密钥-3"><a href="#1-创建一个自签名证书和密钥-3" class="headerlink" title="1. 创建一个自签名证书和密钥"></a>1. 创建一个自签名证书和密钥</h4><p>docker run –name nginx -v ~/devEnv/dockerSrvStorage/nginx.conf:/etc/nginx/nginx.conf:ro -d nginx</p>
<h3 id="什么是跨站请求伪造"><a href="#什么是跨站请求伪造" class="headerlink" title="什么是跨站请求伪造"></a>什么是跨站请求伪造</h3><p>例子：A 是受害用户，B 是银行，C 是恶意代码。C 利用浏览器里存在的有效 A 到 B 的 session(cookie)来伪造请求。再加上利用 XSS 漏洞，用户可以子在无感知的情况下被伤害。<br>Cross-Site Scripting (XSS)</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.4.5/reference/html5/#csrf-explained">https://docs.spring.io/spring-security/site/docs/5.4.5/reference/html5/#csrf-explained</a></p>
<p>Reference:</p>
<p>What is keystore: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/23202046/what-is-keystore">https://stackoverflow.com/questions/23202046/what-is-keystore</a><br>openssl vs keystore: <a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/98282/difference-between-openssl-and-keytool">https://security.stackexchange.com/questions/98282/difference-between-openssl-and-keytool</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-micro_service/api_gateway" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-03-22T13:49:17.000Z"><a href="/2021/03/23/micro_service/api_gateway/">2021-03-23</a></time>
      
      
  
    <h1 class="title"><a href="/2021/03/23/micro_service/api_gateway/">API网关</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-micro_service/dfs" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-03-21T06:51:25.000Z"><a href="/2021/03/21/micro_service/dfs/">2021-03-21</a></time>
      
      
  
    <h1 class="title"><a href="/2021/03/21/micro_service/dfs/">文件管理服务</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>这个服务基于 FastDFS 实现文件的上传、下载、删除，文件元数据维护的功能。</p>
<p>FastDFS 官方客户端地址：<a target="_blank" rel="noopener" href="https://github.com/happyfish100/fastdfs-client-java">https://github.com/happyfish100/fastdfs-client-java</a><br>简单的关于 fastdfs-client-java 使用 demo：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1407660">https://cloud.tencent.com/developer/article/1407660</a></p>
<p>一些关于使用 FastDFS 的文档：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dingcai12003/article/details/96046404">https://blog.csdn.net/dingcai12003/article/details/96046404</a><br>有些库又做了二次封装（比如 com.github.tobato:fastdfs-client），但是感觉官方客户端库里已经有了简单的连接管理，所以小并发量使用看不到再池化的意义。</p>
<p>项目使用 Gradle 做构建工具，在 Gradle 仓库中找不到 FastDFS 的库。因此要把 mavenLocal()设置到 repositories 里。<br>如果手工安装特定 FastDFS 库到本地 maven 仓库，可以执行如下命令：</p>
<pre><code>git clone git@github.com:happyfish100/fastdfs-client-java.git
cd fastdfs-client-java
git fetch --all --tags
git checkout tags/V1.28 -b V1.28
mvn clean source:jar install
</code></pre>
<p>mkdir -p /home/devops/dockerSrvStorage/mysql<br>docker run –name mysql -e MYSQL_ROOT_PASSWORD=password -p 3306:3306 <br> –restart=always <br> -v /home/devops/dockerSrvStorage/mysql/conf.d:/etc/mysql/conf.d <br> -v /home/devops/dockerSrvStorage/mysql/logs:/logs <br> -v /home/devops/dockerSrvStorage/mysql/data/mysql:/var/lib/mysql <br> -d mysql:8.0.22 <br> –character-set-server=utf8mb4 <br> –collation-server=utf8mb4_unicode_ci</p>
<p>官方 MySQL docker 文档：<a target="_blank" rel="noopener" href="https://hub.docker.com/_/mysql">https://hub.docker.com/_/mysql</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/setup_FastDFS_dev_env" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-03-20T10:19:36.000Z"><a href="/2021/03/20/devops/setup_FastDFS_dev_env/">2021-03-20</a></time>
      
      
  
    <h1 class="title"><a href="/2021/03/20/devops/setup_FastDFS_dev_env/">在Ubuntu20上安装FastDFS环境</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>应用中一般会有文件上传、下载相关业务。这里通过使用 FastDFS 构建一个简单的分布式文件系统满足一般的需求。实际项目中分布式文件系统的选择根据业务需求、团队技术栈具体选择。</p>
<p>安装环境依旧是利用 KVM 虚拟机完成。开发环境使用 FastDFS 的单机部署就可以。生成环境使用分布式部署提高性能及可靠性。<br>单机模式就是把 tracker 和 storage 都安装在同一台机器上，虽然 IP 相同但是可以通过使用不同 port 来在单机实习集群功能。<br>分布式部署就是在不同机器安装安装不同的 Tracker、Storage 节点。</p>
<h3 id="1-构建-Ubuntu20-虚拟机，用于安装-FastDFS。"><a href="#1-构建-Ubuntu20-虚拟机，用于安装-FastDFS。" class="headerlink" title="1. 构建 Ubuntu20 虚拟机，用于安装 FastDFS。"></a>1. 构建 Ubuntu20 虚拟机，用于安装 FastDFS。</h3><h4 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h4><p>如前几篇文章一样，在 virt-infra-ansible/inventory 目录下设置 FastDFS 服务器配置。因为这是用于原型验证，所以这里硬盘配置仅仅是 20G。给每个虚拟机设置 mac 是为了对 IP 进行绑定、DNS 设置。<br>因为安装 FastDFS 需要编译环境，所以通过 virt_infra_disk_cmd 让虚拟机预先执行必要安装：</p>
<pre><code>apt -y install git gcc g++ make automake autoconf libtool pcre2-utils libpcre2-dev libpcre3 libpcre3-dev  zlib1g zlib1g-dev openssl libssh-dev wget vim
</code></pre>
<p>所以</p>
<pre><code>fastDfsServers:
  hosts:
    dfsServer0:
      ansible_python_interpreter: /usr/bin/python3
      virt_infra_networks:
        - name: br0
          type: bridge
          mac: &quot;52:54:00:81:45:10&quot;
    dfsServer1:
      ansible_python_interpreter: /usr/bin/python3
      virt_infra_networks:
        - name: br0
          type: bridge
          mac: &quot;52:54:00:81:45:11&quot;
    dfsServer2:
      ansible_python_interpreter: /usr/bin/python3
      virt_infra_networks:
        - name: br0
          type: bridge
          mac: &quot;52:54:00:81:45:12&quot;
  vars:
    virt_infra_state: running
    virt_infra_distro: ubuntu
    virt_infra_distro_image: focal-server-cloudimg-amd64.img
    virt_infra_autostart: yes
    ansible_python_interpreter: /usr/bin/python3
    virt_infra_timezone: &quot;Asia/Shanghai&quot;
    virt_infra_root_password: password
    virt_infra_disk_size: 20
    virt_infra_ram: 4094
    virt_infra_ram_max: 8192
    virt_infra_cpus: 4
    virt_infra_cpus_max: 8
    virt_infra_networks:
      - name: br0
        type: bridge
    virt_infra_disk_cmd:
      - apt update
      - apt install -y net-tools
      - apt -y install git gcc g++ make automake autoconf libtool pcre2-utils libpcre2-dev libpcre3 libpcre3-dev  zlib1g zlib1g-dev openssl libssh-dev wget vim
</code></pre>
<h4 id="一键创建虚拟机"><a href="#一键创建虚拟机" class="headerlink" title="一键创建虚拟机"></a>一键创建虚拟机</h4><p>依旧是按照老套路创建虚拟机。登录 KVM HOST，执行：</p>
<pre><code>cd virt-infra-ansible
ansible-playbook ./virt-infra.yml --limit kvmhost,fastDfsServers
</code></pre>
<h4 id="设置-DHCP-服务绑定-mac-和-IP，设置-DNS-服务绑定-IP-和域名"><a href="#设置-DHCP-服务绑定-mac-和-IP，设置-DNS-服务绑定-IP-和域名" class="headerlink" title="设置 DHCP 服务绑定 mac 和 IP，设置 DNS 服务绑定 IP 和域名"></a>设置 DHCP 服务绑定 mac 和 IP，设置 DNS 服务绑定 IP 和域名</h4><p>因为这里是直接利用无线路由提供的 DHCP 服务，为了绑定 MAC、IP 直接登录无线网关通过 Web 页面进行。</p>
<p>如上篇所述，我们的环境中已经安装了 CoreDNS 服务，所以我们可以为 fastDFS 服务器们设置域名。<br>因为 virt-infra-ansible 工具会在成功创建虚拟机后把 IP 写入 hosts 文件，所以可通过 KVM HOST 上的 hosts 文件查看刚刚创建出虚拟机的 IP。</p>
<p>登录 repositoryServer，</p>
<pre><code>cd /home/devops/dockerSrvStorage/coredns
vi hostsfile
</code></pre>
<p>添加 IP 到机器名/域名的映射。</p>
<pre><code>192.168.0.116 dfsServer0 dfsTracker
192.168.0.104 dfsServer1 dfsStorage0
192.168.0.117 dfsServer2 dfsStorage1
</code></pre>
<h3 id="2-安装-FastDFS"><a href="#2-安装-FastDFS" class="headerlink" title="2. 安装 FastDFS"></a>2. 安装 FastDFS</h3><p>参照官方安装指南 <a target="_blank" rel="noopener" href="https://github.com/happyfish100/fastdfs/wiki">https://github.com/happyfish100/fastdfs/wiki</a> 很容易安装。</p>
<p>创建文件夹 /home/fastdfs 用于保存 fastdfs 管理的文件和日志。<br>利用目录 /usr/local/src 保存需要编译的源码。<br>这里 checkout v6.07 版本的 fastDFS 进行安装，其它步骤与官方文档基本一直。</p>
<pre><code>cd /usr/local/src
git clone https://github.com/happyfish100/fastdfs.git --depth 1
cd fastdfs/
git fetch --all --tags
git checkout tags/V6.07 -b V6.07
git pull
./make.sh &amp;&amp; ./make.sh install
</code></pre>
<h3 id="3-启动-FastDFS"><a href="#3-启动-FastDFS" class="headerlink" title="3. 启动 FastDFS"></a>3. 启动 FastDFS</h3><h4 id="启动-tracke、storage-服务："><a href="#启动-tracke、storage-服务：" class="headerlink" title="启动 tracke、storage 服务："></a>启动 tracke、storage 服务：</h4><pre><code>/etc/init.d/fdfs_trackerd start
/etc/init.d/fdfs_storaged start
</code></pre>
<h4 id="查看-fastDFS-服务状态："><a href="#查看-fastDFS-服务状态：" class="headerlink" title="查看 fastDFS 服务状态："></a>查看 fastDFS 服务状态：</h4><pre><code>/usr/bin/fdfs_monitor /etc/fdfs/storage.conf
</code></pre>
<h4 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h4><p>vi /lib/systemd/system/rc-local.service 并添加如下内容：</p>
<pre><code>[Install]
WantedBy=multi-user.target
Alias=rc-local.servic
</code></pre>
<p>创建/etc/rc.local，并添加如下内容：</p>
<pre><code>touch /etc/rc.local
chmod +x /etc/rc.local

#!/bin/sh

/etc/init.d/fdfs_trackerd start
/etc/init.d/fdfs_storaged start
</code></pre>
<h3 id="4-测试-fastDFS"><a href="#4-测试-fastDFS" class="headerlink" title="4. 测试 fastDFS"></a>4. 测试 fastDFS</h3><p>修改 /etc/fdfs/client.conf 中如下配置：</p>
<pre><code>base_path=/home/fastdfs
tracker_server=dfsServer0
</code></pre>
<p>测试上传</p>
<pre><code>fdfs_upload_file /etc/fdfs/client.conf /usr/local/src/nginx-1.15.4.tar.gz
</code></pre>
<p>Reference:</p>
<p>官网：<a target="_blank" rel="noopener" href="https://github.com/happyfish100/fastdfs/">https://github.com/happyfish100/fastdfs/</a><br>一般性介绍：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1c71ae024e5e">https://www.jianshu.com/p/1c71ae024e5e</a><br>FastDFS 在 Ubuntu 的安装配置: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29133587">https://zhuanlan.zhihu.com/p/29133587</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/install_dockers_coredns_gitlab_jenkins" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-03-05T14:59:25.000Z"><a href="/2021/03/06/devops/install_dockers_coredns_gitlab_jenkins/">2021-03-06</a></time>
      
      
  
    <h1 class="title"><a href="/2021/03/06/devops/install_dockers_coredns_gitlab_jenkins/">安装CoreDNS、GitLab、Jenkins</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>在之前创建的 repository server 上安装下面的服务。</p>
<h3 id="1）搭建-CoreDNS-服务"><a href="#1）搭建-CoreDNS-服务" class="headerlink" title="1）搭建 CoreDNS 服务"></a>1）搭建 CoreDNS 服务</h3><h4 id="先从-Docer-Hub-上拉取-CoreDNS-镜像。"><a href="#先从-Docer-Hub-上拉取-CoreDNS-镜像。" class="headerlink" title="先从 Docer Hub 上拉取 CoreDNS 镜像。"></a>先从 Docer Hub 上拉取 CoreDNS 镜像。</h4><pre><code>docker pull coredns/coredns:1.8.3
</code></pre>
<h4 id="停止-Ubuntu-上默认启动的-DNS-服务。"><a href="#停止-Ubuntu-上默认启动的-DNS-服务。" class="headerlink" title="停止 Ubuntu 上默认启动的 DNS 服务。"></a>停止 Ubuntu 上默认启动的 DNS 服务。</h4><p>在下载 coredns 镜像之前先不要停止 DNS 服务，否则解析不到 docker 镜像仓库服务器。</p>
<pre><code>sudo systemctl disable systemd-resolved
sudo systemctl stop systemd-resolved
</code></pre>
<h4 id="在目录-home-devops-dockerSrvStorage-coredns-下创建-2-个文件-Corefile-hostsfile，内容如下："><a href="#在目录-home-devops-dockerSrvStorage-coredns-下创建-2-个文件-Corefile-hostsfile，内容如下：" class="headerlink" title="在目录 /home/devops/dockerSrvStorage/coredns 下创建 2 个文件 Corefile hostsfile，内容如下："></a>在目录 /home/devops/dockerSrvStorage/coredns 下创建 2 个文件 Corefile hostsfile，内容如下：</h4><p>192.168.0.1 是家里无线路由器的 IP 地址。我这里用的是 TL-WDR7650 千兆易展无线路由。</p>
<pre><code># ls
Corefile  hostsfile
# cat Corefile
.:53 &#123;
    hosts /etc/coredns/hostsfile &#123;
        fallthrough
    &#125;
    forward . 192.168.0.1:53
    log
&#125;
</code></pre>
<p>把之前创建的 Guest 虚拟机 IP 都加进来。</p>
<pre><code># cat hostsfile
devops@repositoryServer:~/dockerSrvStorage/coredns$ cat hostsfile
192.168.0.114 repositoryServer dnsServer gitlab jenkins gitlab.telbox.cn jenkins.telbox.cn
192.168.0.112 devopServer0
192.168.0.113 devopServer1
192.168.0.115 devopServer2

192.168.0.106 k8s-master-0
192.168.0.107 k8s-node-0
192.168.0.109 k8s-node-1
192.168.0.108 k8s-node-2

192.168.0.114 basehost0
192.168.0.111 ubuntu20Server
</code></pre>
<h4 id="运行-CoreDNS-镜像"><a href="#运行-CoreDNS-镜像" class="headerlink" title="运行 CoreDNS 镜像"></a>运行 CoreDNS 镜像</h4><pre><code>docker run -it -d --net=host \
--name=coredns --restart=always \
-v /home/devops/dockerSrvStorage/coredns:/etc/coredns/ \
coredns/coredns:1.8.3 \
-conf /etc/coredns/Corefile
</code></pre>
<p>备注：<br>–net=host 要指定，如果不指定，在同宿主机的容器中无法查询 DNS。如果指定了该项，则无须指定-p 选项。默认使用宿主机的端口。</p>
<p>Reference:</p>
<p>BIND, Dnsmasq 等常见 DNS Server（却不包含 CoreDNS）：<br><a target="_blank" rel="noopener" href="https://computingforgeeks.com/bind-vs-dnsmasq-vs-powerdns-vs-unbound/">https://computingforgeeks.com/bind-vs-dnsmasq-vs-powerdns-vs-unbound/</a><br>安装 Core DNS Docker：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36938307/article/details/105390004">https://blog.csdn.net/weixin_36938307/article/details/105390004</a></p>
<h3 id="2）GitLab"><a href="#2）GitLab" class="headerlink" title="2）GitLab"></a>2）GitLab</h3><p>各种 docker 服务一般都需要持久化映射，以方便配置、数据的保存。本地使用 /home/devops/dockerSrvStorage 作为各种应用存储的根目录。<br>其中<strong>参数 –hostname gitlab.telbox.cn 定义了用户访问 gitlab 服务的主机域名</strong>。</p>
<pre><code>mkdir -p /home/devops/dockerSrvStorage/gitlab
sudo docker pull gitlab/gitlab-ce:13.9.2-ce.0

sudo docker run --detach \
--hostname gitlab.telbox.cn \
--publish 9181:443 --publish 9180:80 --publish 9182:22 \
--name gitlab \
--restart always \
--volume /home/devops/dockerSrvStorage/gitlab/config:/etc/gitlab \
--volume /home/devops/dockerSrvStorage/gitlab/logs:/var/log/gitlab \
--volume /home/devops/dockerSrvStorage/gitlab/data:/var/opt/gitlab \
gitlab/gitlab-ce:13.9.2-ce.0
</code></pre>
<p>可修改 /home/devops/dockerSrvStorage/gitlab/config 里的配置文件。如有需要，可进入 GitLab 容器进行配置。</p>
<pre><code>sudo docker exec -it gitlab bash
cd /opt/gitlab/embedded/service/gitlab-rails/config
vi gitlab.yml
</code></pre>
<p>执行命令 gitlab-ctl reconfigure 使之生效</p>
<pre><code>sudo docker exec gitlab gitlab-ctl reconfigure
</code></pre>
<p>第一次访问安装好的 GitLab 服务<a target="_blank" rel="noopener" href="http://gitlab.telbox.cn:9180/%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AEroot%E7%94%A8%E6%88%B7%E7%9A%84%E5%8F%A3%E4%BB%A4%E3%80%82">http://gitlab.telbox.cn:9180/需要设置root用户的口令。</a></p>
<p>Reference:<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/080a962c35b6">https://www.jianshu.com/p/080a962c35b6</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63786567">https://zhuanlan.zhihu.com/p/63786567</a></p>
<h3 id="3）Jenkins"><a href="#3）Jenkins" class="headerlink" title="3）Jenkins"></a>3）Jenkins</h3><pre><code>mkdir -p /home/devops/dockerSrvStorage/jenkins


sudo docker run -p 9183:8080 -p 9184:50000 \
--name jenkins -d \
-v /home/devops/dockerSrvStorage/jenkins:/var/jenkins_home \
-v /home/devops/dockerSrvStorage/jdk/java-se-8u41-ri:/var/jenkins_home/tools/jdk/java-se-8u41-ri \
-v /home/devops/dockerSrvStorage/jdk/jdk-11.0.2:/var/jenkins_home/tools/jdk/jdk-11.0.2 \
-v /home/devops/dockerSrvStorage/apache-maven-3.6.3:/var/jenkins_home/tools/apache-maven-3.6.3 \
jenkins/jenkins:lts
</code></pre>
<p>上面通过-v 的方式把 JDK 和 Maven mount 给 Jenkins 容器，之后可以通过 Jenkins Tools 配置他们给 Pipline 使用。<br>启动后，进入 docker 查看初始密码。首次访问 jenkins.telbox.cn:9183 时会用到这个密码。</p>
<pre><code>sudo docker exec -it jenkins bash
jenkins@e061aa64ed7b:/$ cat /var/jenkins_home/secrets/initialAdminPassword
</code></pre>
<p>访问 jenkins.telbox.cn:9183 输入初始密码，选择安装建议的插件。<br>插件安装完毕后，要求输入 Jenkins URL，这里输入 jenkins.telbox.cn:9183</p>
<blockquote>
<p>The Jenkins URL is used to provide the root URL for absolute links to various Jenkins resources. That means this value is required for proper operation of many Jenkins features including email notifications, PR status updates, and the BUILD_URL environment variable provided to build steps.<br>The proposed default value shown is not saved yet and is generated from the current request, if possible. The best practice is to set this value to the URL that users are expected to use. This will avoid confusion when sharing or viewing links.</p>
</blockquote>
<p>如果需要，<strong>可以给 Jenkins 配置日志</strong>：</p>
<pre><code>mkdir -p /home/devops/dockerSrvStorage/jenkins/data
cat &gt; /home/devops/dockerSrvStorage/jenkins/data/log.properties &lt;&lt;EOF
handlers=java.util.logging.ConsoleHandler
jenkins.level=FINEST
java.util.logging.ConsoleHandler.level=FINEST
EOF
docker run --name myjenkins -p 8080:8080 -p 50000:50000 --env JAVA_OPTS=&quot;-Djava.util.logging.config.file=/var/jenkins_home/log.properties&quot; -v `pwd`/data:/var/jenkins_home jenkins
</code></pre>
<p>如果 Jenkins 插件安装比较慢，可以使用国内插件镜像源，参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/oYinHeZhiGuang/article/details/104867525%E3%80%82">https://blog.csdn.net/oYinHeZhiGuang/article/details/104867525。</a></p>
<p>Reference:<br><a target="_blank" rel="noopener" href="https://github.com/jenkinsci/docker/blob/master/README.md">https://github.com/jenkinsci/docker/blob/master/README.md</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/docker-jenkins-cicd.html">https://www.cnblogs.com/xiaoqi/p/docker-jenkins-cicd.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/use_aliyun_ubuntu_apt_source" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-03-05T12:09:35.000Z"><a href="/2021/03/06/devops/use_aliyun_ubuntu_apt_source/">2021-03-06</a></time>
      
      
  
    <h1 class="title"><a href="/2021/03/06/devops/use_aliyun_ubuntu_apt_source/">设置Ubuntu Guest使用aliyun apt镜像源</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>本文记录如何更改 disk-create.yml 来让 Ubunt Guest 使用阿里云镜像作为 apt source。最终的命令形式如下：</p>
<pre><code>ansible-playbook ./virt-infra.yml --limit kvmhost,ubuntu20Server --extra-vars change_to_ali_ubuntu_source=true
</code></pre>
<p>通过在命令行里设置参数 change_to_ali_ubuntu_source=yes 来创建虚拟机的时候进行 ali ubunt apt source 的设置。</p>
<p>1）禁止使用 could init 设置默认的 apt sources</p>
<pre><code>- name: Do not use cloud source
  command: &gt;
    virt-customize
    -a &#123;&#123; hostvars[groups['kvmhost'][0]].virt_infra_host_image_path | default(virt_infra_host_image_path) &#125;&#125;/&#123;&#123; inventory_hostname &#125;&#125;-boot.qcow2
    --run-command &quot;echo &#39;apt_preserve_sources_list: true&#39; &gt;&gt; /etc/cloud/cloud.cfg&quot;
  register: result_disk_cmd
  retries: 2
  delay: 2
  until: result_disk_cmd is succeeded
  become: true
  when:
    - inventory_hostname not in groups[&#39;kvmhost&#39;]
    - inventory_hostname not in hostvars[groups[&#39;kvmhost&#39;][0]].result_all_vms.list_vms
    - virt_infra_state != &quot;undefined&quot;
    - change_to_ali_ubuntu_source is defined and change_to_ali_ubuntu_source
  delegate_to: &quot;&#123;&#123; groups['kvmhost'][0] &#125;&#125;&quot;
</code></pre>
<p>2）使用 aliyun 的 ubuntu apt source 镜像。</p>
<pre><code>- name: Setup Aliyun Source
  command: &gt;
    virt-customize
    -a &#123;&#123; hostvars[groups['kvmhost'][0]].virt_infra_host_image_path | default(virt_infra_host_image_path) &#125;&#125;/&#123;&#123; inventory_hostname &#125;&#125;-boot.qcow2
    --run-command &#39;mv /etc/apt/sources.list /etc/apt/sources.list.bak&#39;
    --run-command &#39;echo &quot;deb http://mirrors.aliyun.com/ubuntu/ $(lsb_release -cs) main multiverse restricted universe&quot; &gt;&gt; /etc/apt/sources.list&#39;
    --run-command &#39;echo &quot;deb http://mirrors.aliyun.com/ubuntu/ $(lsb_release -cs)-backports main multiverse restricted universe&quot; &gt;&gt; /etc/apt/sources.list&#39;
    --run-command &#39;echo &quot;deb http://mirrors.aliyun.com/ubuntu/ $(lsb_release -cs)-proposed main multiverse restricted universe&quot; &gt;&gt; /etc/apt/sources.list&#39;
    --run-command &#39;echo &quot;deb http://mirrors.aliyun.com/ubuntu/ $(lsb_release -cs)-security main multiverse restricted universe&quot; &gt;&gt; /etc/apt/sources.list&#39;
    --run-command &#39;echo &quot;deb http://mirrors.aliyun.com/ubuntu/ $(lsb_release -cs)-updates main multiverse restricted universe&quot; &gt;&gt; /etc/apt/sources.list&#39;
    --run-command &#39;echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ $(lsb_release -cs) main multiverse restricted universe&quot; &gt;&gt; /etc/apt/sources.list&#39;
    --run-command &#39;echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ $(lsb_release -cs)-backports main multiverse restricted universe&quot; &gt;&gt; /etc/apt/sources.list&#39;
    --run-command &#39;echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ $(lsb_release -cs)-proposed main multiverse restricted universe&quot; &gt;&gt; /etc/apt/sources.list&#39;
    --run-command &#39;echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ $(lsb_release -cs)-security main multiverse restricted universe&quot; &gt;&gt; /etc/apt/sources.list&#39;
    --run-command &#39;echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ $(lsb_release -cs)-updates main multiverse restricted universe&quot; &gt;&gt; /etc/apt/sources.list&#39;
  register: result_disk_cmd
  retries: 2
  delay: 2
  until: result_disk_cmd is succeeded
  become: true
  when:
    - inventory_hostname not in groups[&#39;kvmhost&#39;]
    - inventory_hostname not in hostvars[groups[&#39;kvmhost&#39;][0]].result_all_vms.list_vms
    - virt_infra_state != &quot;undefined&quot;
    - change_to_ali_ubuntu_source is defined and change_to_ali_ubuntu_source
  delegate_to: &quot;&#123;&#123; groups['kvmhost'][0] &#125;&#125;&quot;
</code></pre>
<p>3）删除已存在的 Guest 并重新创建。这个虚拟使用 Ali 源并跟随宿主机启动时自动启动。</p>
<pre><code>[devops@localhost virt-infra-ansible]$ ansible-playbook ./virt-infra.yml --limit kvmhost,ubuntu20Server --extra-vars virt_infra_state=undefined
[devops@localhost virt-infra-ansible]$ ansible-playbook ./virt-infra.yml --limit kvmhost,ubuntu20Server --extra-vars change_to_ali_ubuntu_source=true --extra-vars virt_infra_autostart=yes
</code></pre>
<ol start="4">
<li><p>安装 Docker 环境</p>
<p>[devops@localhost virt-infra-ansible]$ ansible-playbook ./install_docker.yml –limit ubuntu20Server -vv –extra-vars docker_version=5:20.10.4<del>3-0</del>ubuntu-focal</p>
</li>
</ol>
<p>参考：</p>
<p>关于 virt-customize 命令<br><a target="_blank" rel="noopener" href="https://libguestfs.org/virt-customize.1.html">https://libguestfs.org/virt-customize.1.html</a><br> <a target="_blank" rel="noopener" href="https://ywnz.com/linuxjc/5680.html">https://ywnz.com/linuxjc/5680.html</a></p>
<p>关于 Ansible yaml 中 command<br><a target="_blank" rel="noopener" href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html">https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/add_an_devServer_in_kvm" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-02-27T10:18:01.000Z"><a href="/2021/02/27/devops/add_an_devServer_in_kvm/">2021-02-27</a></time>
      
      
  
    <h1 class="title"><a href="/2021/02/27/devops/add_an_devServer_in_kvm/">在基于KVM的环境中添加一组开发服务器</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>好久没动 K8S，DevOps，准备折腾个 devops 的环境。考虑到 CentOS 未来的命运，这里使用 Ubuntu 20. 先在 KVM Host 上下载 ubuntu 并 copy 到目录/var/lib/libvirt/images/。</p>
<h3 id="在-KVM-HOST-上准备-Ubuntu20-的镜像"><a href="#在-KVM-HOST-上准备-Ubuntu20-的镜像" class="headerlink" title="在 KVM HOST 上准备 Ubuntu20 的镜像"></a>在 KVM HOST 上准备 Ubuntu20 的镜像</h3><pre><code>curl -O http://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img
mv -iv focal-server-cloudimg-amd64.img /var/lib/libvirt/images/
</code></pre>
<h3 id="在文件-virt-infra-ansible-inventory-devopServers-yml-中定义待创建的-devop-servers-虚拟机参数。"><a href="#在文件-virt-infra-ansible-inventory-devopServers-yml-中定义待创建的-devop-servers-虚拟机参数。" class="headerlink" title="在文件 virt-infra-ansible/inventory/devopServers.yml 中定义待创建的 devop servers 虚拟机参数。"></a>在文件 virt-infra-ansible/inventory/devopServers.yml 中定义待创建的 devop servers 虚拟机参数。</h3><p>进入目录 virt-infra-ansible/inventory，创建文件</p>
<p>参考：<a href="https://dhyuan.github.io/2020/09/28/devops/create_k8s_by_kubeadm/">https://dhyuan.github.io/2020/09/28/devops/create_k8s_by_kubeadm/</a> 。对，本文就是在这个环境的基础上再添加 4 个与 degvops 相关的服务器。其中 repositoryServer 用于安装 Nexus、Harbor、GitLab 等。devopsServer0-2 用于其它 devops 相关服务。<br>需注意的是 focal 的 python 版本是 3，所以设置 /usr/bin/python3，考虑到 repositoryServer 的用途，其磁盘容量设为 500G。<br>… virt-infra-ansible/inventory/devopServers.yml，内容如下：</p>
<pre><code>devopServers:
    hosts:
        repositoryServer:
        virt_infra_state: running
        virt_infra_distro: ubuntu
        virt_infra_distro_image: focal-server-cloudimg-amd64.img
        ansible_python_interpreter: /usr/bin/python3
        virt_infra_timezone: &quot;Asia/Shanghai&quot;
        virt_infra_disk_size: 500
        virt_infra_disk_cmd:
            - apt update
            - apt install -y net-tools
            - apt install -y lsb
            - useradd -m devops
            - echo &quot;devops:password&quot;| chpasswd
        devopsServer[0:2]:
        virt_infra_state: running
        virt_infra_distro: ubuntu
        virt_infra_distro_image: focal-server-cloudimg-amd64.img
        ansible_python_interpreter: /usr/bin/python3
        virt_infra_timezone: &quot;Asia/Shanghai&quot;
        virt_infra_disk_cmd:
            - apt update
            - apt install -y net-tools
            - apt install -y lsb
            - useradd -m devops
            - echo &quot;devops:password&quot;| chpasswd
    vars:
        virt_infra_root_password: password
        virt_infra_disk_size: 80
        virt_infra_ram: 4094
        virt_infra_ram_max: 8192
        virt_infra_cpus: 4
        virt_infra_cpus_max: 8
        virt_infra_state: running
        virt_infra_networks:
        - name: br0
            type: bridge
</code></pre>
<h3 id="一键创建-devop-servers-虚拟机"><a href="#一键创建-devop-servers-虚拟机" class="headerlink" title="一键创建 devop servers 虚拟机"></a>一键创建 devop servers 虚拟机</h3><pre><code>cd virt-infra-ansible
ansible-playbook ./virt-infra.yml --limit kvmhost,devopServers
</code></pre>
<h4 id="如果出现问题，可删除刚才创建的-guest-虚拟机"><a href="#如果出现问题，可删除刚才创建的-guest-虚拟机" class="headerlink" title="如果出现问题，可删除刚才创建的 guest 虚拟机"></a>如果出现问题，可删除刚才创建的 guest 虚拟机</h4><p>通过使用参数 –extra-vars virt_infra_state=undefined 来删除。比如：</p>
<pre><code>ansible-playbook ./virt-infra.yml --limit kvmhost,devopServers --extra-vars virt_infra_state=undefined
</code></pre>
<h3 id="一键在-devop-servers-节点上安装-docker"><a href="#一键在-devop-servers-节点上安装-docker" class="headerlink" title="一键在 devop servers 节点上安装 docker"></a>一键在 devop servers 节点上安装 docker</h3><p>在 Ubuntu 环境中安装 docker，<br>1）添加 Docker 的阿里云源。<br>在文件 ansible-role-docker-ce/tasks/setup-repository-Ubuntu.yml 尾部设置 aliyun source。</p>
<pre><code>- name: Add Aliyun Docker official GPG key
become: true
apt_key:
url: http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg
state: present
register: \_pkg_result
until: \_pkg_result is succeeded
when:

- docker_network_access | bool
- (\_docker_os_dist == &quot;Ubuntu&quot; and \_docker_os_dist_major_version | int &gt; 14) or
    (\_docker_os_dist == &quot;Debian&quot; and \_docker_os_dist_major_version | int &gt; 7)

- name: Add Aliyun Docker CE repository with correct channels (Ubuntu/Debian)
become: true
lineinfile:
path: /etc/apt/sources.list.d/docker-ce.list
line: &quot;deb [arch=&#123;&#123; _docker_os_arch|lower &#125;&#125;] http://mirrors.aliyun.com/docker-ce/linux/&#123;&#123; \_docker_os_dist|lower &#125;&#125; &#123;&#123; ansible_lsb.codename &#125;&#125; stable&quot;
insertbefore: BOF
</code></pre>
<p>2）找到适合自己 Ubuntu 版本的 Docker 版本。<br>可用命令 apt-cache madison docker-ce 查看。</p>
<pre><code>root@basehost0:~# apt-cache madison docker-ce
docker-ce | 5:20.10.4~3-0~ubuntu-focal | http://mirrors.aliyun.com/docker-ce/linux/ubuntu focal/stable amd64 Packages
docker-ce | 5:20.10.4~3-0~ubuntu-focal | https://download.docker.com/linux/ubuntu focal/stable amd64 Packages
docker-ce | 5:20.10.3~3-0~ubuntu-focal | http://mirrors.aliyun.com/docker-ce/linux/ubuntu focal/stable amd64 Packages
docker-ce | 5:20.10.3~3-0~ubuntu-focal | https://download.docker.com/linux/ubuntu focal/stable amd64 Packages
docker-ce | 5:20.10.2~3-0~ubuntu-focal | http://mirrors.aliyun.com/docker-ce/linux/ubuntu focal/stable amd64 Packages
。。。 。。。
</code></pre>
<p>3）在 Ubuntu Guest 上安装 Docker。<br>因为 virt-infra-ansible/install_docker.yml 中 docker 版本默认为 19.03.8，并不适用于 Ubuntu20 的环境。<br>可以通过在命令行指定参数 docker_version 来安装，如下：</p>
<pre><code>    ansible-playbook ./install_docker.yml --limit devopServers -vv --extra-vars docker_version=5:20.10.4~3-0~ubuntu-focal
</code></pre>
<p>之前 CentOS7 Guest 上安装 Docker 的命令：</p>
<pre><code>ansible-playbook ./install_docker.yml \
--limit devopServers -v \
-e &#39;&#123;&quot;docker_repository_url&quot;: &#123;&quot;Ubuntu focal&quot;: &quot; http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; &#125;&#125;&#39;
</code></pre>
<p>登录到一台 Ubuntu Guest 机器，查看已安装的 Docker 版本以确认成功。</p>
<pre><code>root@basehost0:~# docker -v
Docker version 20.10.4, build d3cb89e
</code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/5/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="as_sitesearch" value="dhyuan.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/AWS/">AWS</a><small>2</small></li>
  
    <li><a href="/tags/CAS/">CAS</a><small>5</small></li>
  
    <li><a href="/tags/Concurrency/">Concurrency</a><small>6</small></li>
  
    <li><a href="/tags/DevOps/">DevOps</a><small>31</small></li>
  
    <li><a href="/tags/FP/">FP</a><small>2</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
  
    <li><a href="/tags/Ingerss/">Ingerss</a><small>1</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>10</small></li>
  
    <li><a href="/tags/Kubernetes/">Kubernetes</a><small>3</small></li>
  
    <li><a href="/tags/Maven/">Maven</a><small>2</small></li>
  
    <li><a href="/tags/MicroService/">MicroService</a><small>3</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>6</small></li>
  
    <li><a href="/tags/Nginx/">Nginx</a><small>2</small></li>
  
    <li><a href="/tags/Reactive/">Reactive</a><small>8</small></li>
  
    <li><a href="/tags/SAGA/">SAGA</a><small>1</small></li>
  
    <li><a href="/tags/Scala/">Scala</a><small>7</small></li>
  
    <li><a href="/tags/Security/">Security</a><small>12</small></li>
  
    <li><a href="/tags/Spring/">Spring</a><small>14</small></li>
  
    <li><a href="/tags/android/">android</a><small>1</small></li>
  
    <li><a href="/tags/network/">network</a><small>2</small></li>
  
    <li><a href="/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><small>13</small></li>
  
    <li><a href="/tags/%E7%BD%91%E4%B8%8A%E5%A5%BD%E6%96%87/">网上好文</a><small>1</small></li>
  
  </ul>
</div>


  
  <div class="widget widget-archives">
    <h3 class="title">归档</h3>
    <div class="entry">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2025 Dahui
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
