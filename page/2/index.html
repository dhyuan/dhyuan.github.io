<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | 浅流</title>
  <meta name="author" content="Dahui">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="浅流"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">浅流</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-notes/cas/Apereo-CAS-Service-Registry-Storage" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-09-27T07:55:38.000Z"><a href="/2022/09/27/notes/cas/Apereo-CAS-Service-Registry-Storage/">2022-09-27</a></time>
      
      
  
    <h1 class="title"><a href="/2022/09/27/notes/cas/Apereo-CAS-Service-Registry-Storage/">Apereo CAS 使用MongoDB作为Service注册的存储</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>可以以不同的方式保存 Servcie 的注册信息，参考这里获得完整列表：<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/services/Service-Management.html#storage%E3%80%82">https://apereo.github.io/cas/6.5.x/services/Service-Management.html#storage。</a><br>这里只记录下如何设置 MongoDB 作为存储端，官方文档：<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/services/MongoDb-Service-Management.html%E3%80%82">https://apereo.github.io/cas/6.5.x/services/MongoDb-Service-Management.html。</a></p>
<h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h3><pre><code>implementation &quot;org.apereo.cas:cas-server-support-mongo-service-registry&quot;
</code></pre>
<h3 id="2-设置"><a href="#2-设置" class="headerlink" title="2. 设置"></a>2. 设置</h3><pre><code>cas.service-registry.mongo.client-uri=mongodb://casdb_user:password@localhost:27017/cas_db
cas.service-registry.mongo.collection=cas_serviceregistry
</code></pre>
<h3 id="3-服务注册初始化"><a href="#3-服务注册初始化" class="headerlink" title="3. 服务注册初始化"></a>3. 服务注册初始化</h3><p>参数 <code>cas.service-registry.core.init-from-json</code> 用于控制在 CAS 系统启动时对发现的 json 格式的服务注册信息是否导入到对应的后端存储。默认为 true，这样启动时会把用 json 文件定义的服务注册信息写入到后端存储，这里是 cas_db 的 cas_serviceregistry collection。<br>开发初期可以使用 json 的方式调试，然后通过 init-from-json=true 把数据导入 DB 之后，再设置 init-from-json 为 false。</p>
<h3 id="4-设置-CAS-Management-使用-MongoDB-作为服务注册信息源。"><a href="#4-设置-CAS-Management-使用-MongoDB-作为服务注册信息源。" class="headerlink" title="4. 设置 CAS-Management 使用 MongoDB 作为服务注册信息源。"></a>4. 设置 CAS-Management 使用 MongoDB 作为服务注册信息源。</h3><p>CAS Management 应用之前通过下面的信息找到注册的服务数据，使用 MongoDDB 作为存储后，需要在 cas-management 的 build.gradle 中添加依赖：</p>
<pre><code>implementation &quot;org.apereo.cas:cas-server-support-mongo-service-registry&quot;
</code></pre>
<p>同时 删除掉 cas.service-registry.json.location 的设置，并把把 cas-server 中关于 cas.service-registry.mongo 的配置 copy 过来。<br>cas.service-registry.mongo.client-uri=mongodb://casdb_user:password@localhost:27017/cas_db<br>cas.service-registry.mongo.collection=cas_serviceregistry</p>
<h3 id="5-通过-WebUI-注册一个新的-CAS-Service。"><a href="#5-通过-WebUI-注册一个新的-CAS-Service。" class="headerlink" title="5. 通过 WebUI 注册一个新的 CAS Service。"></a>5. 通过 WebUI 注册一个新的 CAS Service。</h3><p>通过 Web 界面添加一个新的 CAS Client 之后，查看 MongoDB 的 cas_serviceregistry collection，可以看到一个新的 document 数据被成功创建出来。</p>
<br/>

<hr>
<p><em>Reference:</em><br>[1]: <a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/services/AutoInitialization-Service-Management.html">https://apereo.github.io/cas/6.5.x/services/AutoInitialization-Service-Management.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-notes/cas/Apereo-CAS-User-Authentication" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-09-21T07:55:38.000Z"><a href="/2022/09/21/notes/cas/Apereo-CAS-User-Authentication/">2022-09-21</a></time>
      
      
  
    <h1 class="title"><a href="/2022/09/21/notes/cas/Apereo-CAS-User-Authentication/">Apereo CAS 之 用户认证</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>上篇使用默认的用户名密码登录 casuser/Mellon 登录 cas。我们可以通过 etc/cas/config/cas.properties 配置不同的后端存储用来进行用户信息的 authentication 的校验。</p>
<p>这里使用 MongoDB 作为用户信息认证的后端存储，参考这里官方文档：<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/authentication/MongoDb-Authentication.html%E3%80%82">https://apereo.github.io/cas/6.5.x/authentication/MongoDb-Authentication.html。</a><br>主要是三个步骤，但需要先把 cas-server-support-mongo 加到 build.gradle 文件。</p>
<pre><code>implementation &quot;org.apereo.cas:cas-server-support-mongo&quot;
</code></pre>
<h3 id="1）在-MongoDb-中保存用户信息"><a href="#1）在-MongoDb-中保存用户信息" class="headerlink" title="1）在 MongoDb 中保存用户信息"></a>1）在 MongoDb 中保存用户信息</h3><p>获得密码’md5password’的 MD5 值，并保存到 collection。<br>$ md5 -s ‘md5password’<br>MD5 (“md5password”) = ec85070aa70e598eda72cbe82d99fabc</p>
<pre><code>db.cas_user.insert(&#123;
    &quot;username&quot;: &quot;casuser&quot;,
    &quot;password&quot;: &quot;ec85070aa70e598eda72cbe82d99fabc&quot;,
    &quot;first_name&quot;: &quot;john&quot;,
    &quot;last_name&quot;: &quot;smith&quot;
&#125;)
</code></pre>
<h3 id="2）-配置-cas-从-MongoDB-获取用户信息"><a href="#2）-配置-cas-从-MongoDB-获取用户信息" class="headerlink" title="2） 配置 cas 从 MongoDB 获取用户信息"></a>2） 配置 cas 从 MongoDB 获取用户信息</h3><p>通过直接设置 client-uri 表明连接到 mongoDB 的哪个库做认证，就不用再分别设置注入 host、database 这样的参数了。<br><code>cas-user</code>是保存用户数据的 collection。<br>如果因为我们使用 MD5 作为密码摘要来验证，所以这里 password-encoder.type 设置为 DEFAULT，encoding-algorithm 设置为 MD5。可以查看源码 DefaultPasswordEncoder 理解这个设置，诸如 BCrypt 是不需要 encoding-algorithm 的。<br>cas 也支持 BCRYPT、PBKDF2 这样的密码编码。也可以把 type 设置为一个自己实现的 PasswordEncoder。<br>如果密码是明文保存的，则可把 password-encoder.type 设为 NONE。</p>
<pre><code># -- Use MongoDB as the authentication data source.
cas.authn.mongo.client-uri=mongodb://admin:password@localhost:27017/center0
cas.authn.mongo.collection=cas_user
# cas.authn.mongo.database-name=
# cas.authn.mongo.host=localhost=
# cas.authn.mongo.password=
# cas.authn.mongo.port=27017
# cas.authn.mongo.principal-transformation.groovy.location=
# cas.authn.mongo.user-id=
cas.authn.mongo.password-encoder.type=DEFAULT
cas.authn.mongo.password-encoder.encoding-algorithm=MD5
</code></pre>
<h3 id="3）登录验证"><a href="#3）登录验证" class="headerlink" title="3）登录验证"></a>3）登录验证</h3><p>运行<code>./gradlew clean copyCasConfiguration build run</code>，在浏览器输入 casuser / md5password 进行登录。</p>
<h3 id="4）使用-BCrypt"><a href="#4）使用-BCrypt" class="headerlink" title="4）使用 BCrypt"></a>4）使用 BCrypt</h3><p>BCrypt 是当前最通用的 password encoding 方式了。BCrypt 会自己内部产生一个随机 salt 并和 hash 的结果保存在一起作为 encode 的结果。这样每次做 BCrypt 的结果都不同并且再校验时也无需提供 salt。可参考这篇文章<a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-security-registration-password-encoding-bcrypt">spring-security-registration-password-encoding-bcrypt</a>。</p>
<p>生成一个密码 bcpassword 的 BCrypt 值：</p>
<pre><code>$ brew tap spring-io/tap
$ brew install spring-boot
$ spring encodepassword bcpassword
&#123;bcrypt&#125;$2a$10$fJc2wH.Oc1SES8Ju/fCoFOjqs6CRnIgPAbUXqRJQ.DGnBVTGG.bLy
</code></pre>
<p>更新数据库里的 password 为<code>$2a$10$fJc2wH.Oc1SES8Ju/fCoFOjqs6CRnIgPAbUXqRJQ.DGnBVTGG.bLy</code>。</p>
<p>设置 cas.authn.mongo.password-encoder.type=BCRYPT<br>注释掉 cas.authn.mongo.password-encoder.encoding-algorithm。</p>
<p>重新使用新配置启动 cas server，用密码 bcpassword 登录。这个时候 cas 后台就已经使用 BCrypt 来验证密码了。<br><code>./gradlew clean copyCasConfiguration build run</code></p>
<p>其实 Type=BCRYPT 就对应到了 class org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder。</p>
<h3 id="5）使用多个不同的-DataSource-用于认证"><a href="#5）使用多个不同的-DataSource-用于认证" class="headerlink" title="5）使用多个不同的 DataSource 用于认证"></a>5）使用多个不同的 DataSource 用于认证</h3><p>可同时使用多个不同的 DataSource 用于认证，但是相同类型的数据源只能有一个。<br>对于同时使用多个认证源的情况，关键是要设置好 authentication policy。请参考：<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/authentication/Configuring-Authentication-Components.html">Authentication Manager</a> 和 <a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/authentication/Configuring-Authentication-Policy.html">Authentication Policy
</a>。</p>
<p>同时用 json file， texfile，MongoDB 作为认证源的<a target="_blank" rel="noopener" href="https://github.com/dhyuan/demo_projects/commit/fc72643a88e93f1c1214e51ec3d88610b90109e1#diff-b94e97ddebc92ca55c272b4fe7917b097e9f38b4f042603370216252d0fb3494">一个例子</a>。</p>
<p>如果需要同时设置两个 MongoDB 作为认证源，就需要自己通过继承 AbstractUsernamePasswordAuthenticationHandler 来实现了。</p>
<br>

<hr>
<p>_References_：<br>[1]: <a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/authentication/Configuring-Authentication-Components.html">https://apereo.github.io/cas/6.5.x/authentication/Configuring-Authentication-Components.html</a><br>[2]: <a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/authentication/Configuring-Authentication-Policy.html">https://apereo.github.io/cas/6.5.x/authentication/Configuring-Authentication-Policy.html</a><br>[2]: <a target="_blank" rel="noopener" href="https://fawnoos.com/2018/06/12/cas53-authn-handlers/">https://fawnoos.com/2018/06/12/cas53-authn-handlers/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-mongo/mongodb-script-collection-fields-size-quantile-analysis" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-09-19T07:55:38.000Z"><a href="/2022/09/19/mongo/mongodb-script-collection-fields-size-quantile-analysis/">2022-09-19</a></time>
      
      
  
    <h1 class="title"><a href="/2022/09/19/mongo/mongodb-script-collection-fields-size-quantile-analysis/">MongoDB脚本：集合中字段数据大小的分位数统计</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="查询某个-collection-的文档大小分布"><a href="#查询某个-collection-的文档大小分布" class="headerlink" title="查询某个 collection 的文档大小分布"></a>查询某个 collection 的文档大小分布</h3><p>日常开发中，有时需要了解数据分布的一些特点，比如这个 colllection 里 documents 的平均大小、全部大小等，来调整程序的设计。<br>对于系统中已经存在大量数据的情况，这种提前分析数据分布模式的工作套路（最佳实践）可以帮助我们有的放矢的进行设计，避免不必要的过度设计或者进行更细致的设计。</p>
<p>如果想获得某个 collection 相关的各种存储统计信息，可以使用 **<a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v6.0/reference/method/db.collection.stats/">stats</a>、<a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v6.0/reference/operator/aggregation/collStats/">collStats</a>**。</p>
<p>如果想获取总计、平均等简单的统计信息，可以参考这里：<a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/core/aggregation-pipeline/#std-label-aggregation-pipeline%E3%80%82">https://www.mongodb.com/docs/manual/core/aggregation-pipeline/#std-label-aggregation-pipeline。</a></p>
<p>下面的命令可以显示 COLLECTION 中满足条件 status=’active’，字段 FIELD_A， FIELD_B 的数据大小的 Quantile analysis。<br>如果去掉第三行，就是对 COLLECTION 中所有文档数据的大小分布的统计。</p>
<pre><code>//最大的Top10和百分比分布。
db.COLLECTION.aggregate([
  &#123; $match: &#123; &quot;status&quot;: &#39;active&#39; &#125; &#125;,
  &#123; $project: &#123; _id: 1, FIELD_A: 1, FIELD_B: 1&#125; &#125;,
  &#123; $project: &#123; documentSize: &#123; $sum: &#123; $bsonSize: &quot;$$ROOT&quot; &#125; &#125; &#125; &#125;,
  &#123; $sort: &#123; documentSize: 1 &#125; &#125;,
  &#123; $group: &#123; &#39;_id&#39;: null, &#39;value&#39;: &#123; &#39;$push&#39;: &#39;$documentSize&#39; &#125; &#125; &#125;,
  &#123; $project: &#123; _id: 0,
      &quot;Top1&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-1, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top2&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-2, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top3&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-4, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top4&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-5, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top5&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-6, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top6&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-7, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top7&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-7, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top8&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-8, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top9&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-9, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top10&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-10, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;99-9%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.999, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;99%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.99, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;95%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.95, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;90%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.90, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;50%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.50, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;25%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.25, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
    &#125; &#125;,
  ]);
</code></pre>
<p>对 MongoDB 4.2 以上版本，可以使用上述 aggrigation 语法进行统计。对 4.2 及其以下版本，需要使用 forEach 语句迭代进行计算。<br>对于不支持 Object.bsonsize 的 Mongo shell 可以使用 BSON.calculateObjectSize 进行替代。</p>
<pre><code>// const BSON = require(&quot;bson&quot;);
var fieldsSize = []
var totalSize = 0
db.COLLECTION.find(&#123; &quot;status&quot;: &#39;A&#39; &#125;, &#123; FIELD_A: 1, FIELD_B: 1&#125;).forEach(function(doc)
&#123;
  var size = Object.bsonsize(doc)
//   var size = BSON.calculateObjectSize(doc)
  totalSize += size
  fieldsSize.push(size)
&#125;);
var sortedData = fieldsSize.sort(function(a, b)&#123;return a-b&#125;);
var statistic = &#123;
    &quot;Note&quot;: &quot;The Collection Fields(FIELD_A, FIELD_B) Size Statistic Reuslt&quot;,
    &quot;numbOfDocs&quot;: sortedData.length,
    &quot;totalSize&quot;: (totalSize / 1024) + &quot;KB    &quot; +  (totalSize / (1024 * 1024)) + &quot; MB&quot;,
    &quot;AVG:&quot;: Math.round(totalSize / sortedData.length),
    &quot;MIN&quot;: sortedData[0],
    &quot;TOP1&quot;: sortedData[sortedData.length - 1],
    &quot;TOP2&quot;: sortedData[sortedData.length - 2],
    &quot;TOP3&quot;: sortedData[sortedData.length - 3],
    &quot;TOP4&quot;: sortedData[sortedData.length - 4],
    &quot;TOP5&quot;: sortedData[sortedData.length - 5],
    &quot;TOP6&quot;: sortedData[sortedData.length - 6],
    &quot;TOP7&quot;: sortedData[sortedData.length - 7],
    &quot;TOP8&quot;: sortedData[sortedData.length - 8],
    &quot;TOP9&quot;: sortedData[sortedData.length - 9],
    &quot;TOP10&quot;: sortedData[sortedData.length - 10],
    &quot;99.9%&quot;: sortedData[Math.floor(sortedData.length * 0.999)],
    &quot;99%&quot;: sortedData[Math.floor(sortedData.length * 0.99)],
    &quot;95%&quot;: sortedData[Math.floor(sortedData.length * 0.95)],
    &quot;90%&quot;: sortedData[Math.floor(sortedData.length * 0.90)],
    &quot;75%&quot;: sortedData[Math.floor(sortedData.length * 0.75)],
    &quot;50%&quot;: sortedData[Math.floor(sortedData.length * 0.5)],
    &quot;25%&quot;: sortedData[Math.floor(sortedData.length * 0.25)],
    &quot;10%&quot;: sortedData[Math.floor(sortedData.length * 0.10)]
&#125;;

print(statistic)
</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a><br/></h2><p>_References:<br>[1]: <a target="_blank" rel="noopener" href="https://database.guide/2-ways-to-get-a-documents-size-in-mongodb/">https://database.guide/2-ways-to-get-a-documents-size-in-mongodb/</a><br>[2]: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22008822/how-to-get-the-size-of-single-document-in-mongodb">https://stackoverflow.com/questions/22008822/how-to-get-the-size-of-single-document-in-mongodb</a><br>[3]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v4.2/reference/command/collStats/">https://www.mongodb.com/docs/v4.2/reference/command/collStats/</a><br>[4]: <a target="_blank" rel="noopener" href="https://database.guide/mongodb-binarysize/">https://database.guide/mongodb-binarysize/</a><br>[5]: <a target="_blank" rel="noopener" href="https://database.guide/mongodb-object-bsonsize/">https://database.guide/mongodb-object-bsonsize/</a><br>[6]: <a target="_blank" rel="noopener" href="https://flowygo.com/en/blog/mongodb-compass-extract-statistics-using-aggregation-pipeline/">https://flowygo.com/en/blog/mongodb-compass-extract-statistics-using-aggregation-pipeline/</a><br>[7]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/aggregation/">https://www.mongodb.com/docs/manual/aggregation/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-mongo/MongoDB-User-Authentication" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-09-19T07:55:38.000Z"><a href="/2022/09/19/mongo/MongoDB-User-Authentication/">2022-09-19</a></time>
      
      
  
    <h1 class="title"><a href="/2022/09/19/mongo/MongoDB-User-Authentication/">MongoDB的用户管理</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>如果在配置文件中 eanble 了 authorization，那么用这样的配置启动 MongoDB 后。如果不是 root 用户去创建用户会遇到一些权限问题。</p>
<pre><code>security:
  authorization: enabled
</code></pre>
<p>/usr/local/opt/mongodb-community/bin/mongod –config /usr/local/etc/mongod.conf</p>
<p>如果你忘记的 root 用户或者其它管理员用户的密码，那么可以先以无权限控制的方式启动 MongoDB：</p>
<pre><code>mongod --port 27017 --dbpath /usr/local/var/mongodb
</code></pre>
<p>再连接到 MongoDB：</p>
<pre><code>mongo --port 27017
</code></pre>
<p>根据需要可以更改用户密码或者创建新用户：</p>
<pre><code>db.changeUserPassword(&quot;root&quot;, passwordPrompt())
db.changeUserPassword(&quot;root&quot;, &quot;password&quot;)

db.createUser(&#123;
    &quot;user&quot;: &quot;dahui&quot;,
    &quot;pwd&quot;: &quot;password&quot;,
    &quot;roles&quot;:
    [
        &#123;
            &quot;role&quot;: &quot;userAdminAnyDatabase&quot;,
            &quot;db&quot;: &quot;admin&quot;
        &#125;,
        &quot;readWriteAnyDatabase&quot;
    ]
&#125;);
</code></pre>
<p>添加完这种带有 userAdminAnyDatabase 角色的用户后，关闭 MongoDB server：</p>
<pre><code>db.adminCommand( &#123; shutdown: 1 &#125; )
</code></pre>
<p>再以有权限控制的方式重新启动 MongoDB Server。（/usr/local/etc/mongod.conf 中设置了 authorization: enabled）</p>
<pre><code>mongod --config /usr/local/etc/mongod.conf
或
mongod --auth --port 27017 --dbpath /var/lib/mongodb
</code></pre>
<p>这样使用拥有 userAdminAnyDatabase 角色的用户登录后，就可以通过使用 use DB_NAME 的方式给不同的 DB 添加用户了。</p>
<pre><code>mongosh --port 27017 -u admin -p password --authenticationDatabase admin

mongosh &quot;mongodb://admin:password@127.0.0.1:27017/center0?authSource=admin&quot;
</code></pre>
<br/>

<hr>
<p><em>Reference:</em><br>[1]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v5.0/tutorial/enable-authentication/">https://www.mongodb.com/docs/v5.0/tutorial/enable-authentication/</a><br>[2]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/reference/method/js-user-management/">https://www.mongodb.com/docs/manual/reference/method/js-user-management/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-spring/Authentication-in-Spring-Security" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-09-19T07:55:38.000Z"><a href="/2022/09/19/spring/Authentication-in-Spring-Security/">2022-09-19</a></time>
      
      
  
    <h1 class="title"><a href="/2022/09/19/spring/Authentication-in-Spring-Security/">Authentication in Spring Security</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>关于 Spring Security 里的 Authentication，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html">官方文档</a>总结的不错。理解这些 classes 的作用与关系是正确使用 Spring Security Authentication 的前提。</p>
<p>认证的方式不同，认证逻辑就不同，这样每个认证方式都会有对应的 fitler 实现。执行认证的大致流程以 AbstractAuthenticationProcessingFilter 为例描述一下。不同类别的 Authentication Filter 的处理略有差异，但大体逻辑差不多:<br><img src="/2022/09/19/spring/Authentication-in-Spring-Security/abstractauthenticationprocessingfilter.png"></p>
<ol>
<li>Authentication Filter 接收请求 http request。</li>
<li>从 request 中获取凭证(credential)等数据，封装在<strong>Authentication</strong>对象中，比如：OAuth2LoginAuthenticationToken， UsernamePasswordAuthenticationToken 等。</li>
<li>用<strong>AuthenticationManager</strong>向对其传入的 Authentication 进行实际的认证工作。</li>
<li>认证成功的处理，比如保存设置了授权信息的 Authentication 到<strong>SecurityContext</strong>中。</li>
<li>失败进行处理。</li>
</ol>
<h2 id="1-Authentication-Filter-接收请求"><a href="#1-Authentication-Filter-接收请求" class="headerlink" title="1) Authentication Filter 接收请求"></a>1) Authentication Filter 接收请求</h2><p>当用户发送了 http request 进行认证，将被负责 authentication 的 filter 处理。这些 filters 实际的认证工作大多数（不是全部）都是由 AuthenticationManager 完成的。比如，像 AbstractPreAuthenticatedProcessingFilter 这些类本身就是接收的是第三方已经认证的请求，所以无需 AuthenticationManager。 另外像 AnonymousAuthenticationFilter 也无需 AuthenticationManager 的参与。<br>所以虽然都是认证，但是因为不同场景处理的逻辑不同，所以与 AuthenticationFilter 相关类的父类并不相同。大致可以分成以下三类。</p>
<h3 id="1）继承自-AbstractAuthenticationProcessingFilter-的-authentication-fitler-class-有-3-个。"><a href="#1）继承自-AbstractAuthenticationProcessingFilter-的-authentication-fitler-class-有-3-个。" class="headerlink" title="1）继承自 AbstractAuthenticationProcessingFilter 的 authentication fitler class 有 3 个。"></a>1）继承自 AbstractAuthenticationProcessingFilter 的 authentication fitler class 有 3 个。</h3><p>public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter<br>public class OAuth2LoginAuthenticationFilter extends AbstractAuthenticationProcessingFilter<br>public class Saml2WebSsoAuthenticationFilter extends AbstractAuthenticationProcessingFilter<br><img src="/2022/09/19/spring/Authentication-in-Spring-Security/subclasses-of-AbstractAuthenticatedProcessingFilter.jpeg" alt="AbstractAuthenticationProcessingFilter"></p>
<h3 id="2）继承自-AbstractPreAuthenticatedProcessingFilter-的类有-5-个。"><a href="#2）继承自-AbstractPreAuthenticatedProcessingFilter-的类有-5-个。" class="headerlink" title="2）继承自 AbstractPreAuthenticatedProcessingFilter 的类有 5 个。"></a>2）继承自 AbstractPreAuthenticatedProcessingFilter 的类有 5 个。</h3><p>public class RequestHeaderAuthenticationFilter extends AbstractPreAuthenticatedProcessingFilter<br>public class RequestAttributeAuthenticationFilter extends AbstractPreAuthenticatedProcessingFilter<br><img src="/2022/09/19/spring/Authentication-in-Spring-Security/subclasses-of-AbstractPreAuthenticatedProcessingFilter.jpg" alt="AbstractPreAuthenticatedProcessingFilter"></p>
<h3 id="3）其它分别直接继承-OncePerRequestFilter-和-GenericFilterBean，比如："><a href="#3）其它分别直接继承-OncePerRequestFilter-和-GenericFilterBean，比如：" class="headerlink" title="3）其它分别直接继承 OncePerRequestFilter 和 GenericFilterBean，比如："></a>3）其它分别直接继承 OncePerRequestFilter 和 GenericFilterBean，比如：</h3><p>OncePerRequestFilter 较 GenericFilterBean 可以保证只被 filters 处理一次。</p>
<pre><code>public class BearerTokenAuthenticationFilter extends OncePerRequestFilter
public class BasicAuthenticationFilter extends OncePerRequestFilter

public class AnonymousAuthenticationFilter extends GenericFilterBean
public class RememberMeAuthenticationFilter extends GenericFilterBean
</code></pre>
<h2 id="2）Request-to-Authentication"><a href="#2）Request-to-Authentication" class="headerlink" title="2）Request to Authentication"></a>2）Request to Authentication</h2><p>Authentication 这个类在认证前主要用于承载认证需要的凭证信息，比如用户名密码。authentication 对象也就等同于一个 authentication request 的 event，并包含请求者进行认证所必须的信息。<br><img src="/2022/09/19/spring/Authentication-in-Spring-Security/Authentication.jpg"></p>
<h2 id="3）AuthenticationManager"><a href="#3）AuthenticationManager" class="headerlink" title="3）AuthenticationManager"></a>3）AuthenticationManager</h2><p>authentication 对象会传递给<strong>AuthenticationManager</strong> 的方法 authenticate()做认证。<br>AuthenticationManager 是个 interface，它的实现类如下图片所示。<br><img src="/2022/09/19/spring/Authentication-in-Spring-Security/implements_of_AuthenticationManager.jpg"></p>
<p>在认证后，principal 的授权信息会被写在 authentication 对象的 authorities 字段。下图摘自《Spring Security in Action》，使用 username password 做认证。<br><img src="/2022/09/19/spring/Authentication-in-Spring-Security/fg3.1_of_SpringSecurityInAction.jpg"></p>
<p>如上图所示的，具体的认证工作是委托给<strong>AuthenticationProvider</strong>完成的。在 Spring Security 的代码实现中，也并不是由 AuthenticationManager 直接包含一组 AuthenticationProvider 的方式完成，中间还有一个叫做<strong>ProviderManager</strong>的类，下面列出它的两个关键字段体会下。</p>
<pre><code>public class ProviderManager implements AuthenticationManager, MessageSourceAware, InitializingBean &#123;

    private List&lt;AuthenticationProvider&gt; providers = Collections.emptyList();

    private AuthenticationManager parent;
    ... ...
&#125;
</code></pre>
<p>可以看到 ProviderManager 包含的不是一个 provider 而是 a list of providers。通过提供一组 providers 就向用户提供了更多灵活控制的可能性。当然随之而来的就是这里就需要明确定义 providers 的认证结果以谁为准的规则。源码 authenticate()的 doc 说得很明白：</p>
<blockquote>
<p>Attempts to authenticate the passed Authentication object.<br>The list of AuthenticationProviders will be successively tried until an AuthenticationProvider indicates it is capable of authenticating the type of Authentication object passed. Authentication will then be attempted with that AuthenticationProvider.<br>If more than one AuthenticationProvider supports the passed Authentication object, the first one able to successfully authenticate the Authentication object determines the result, overriding any possible AuthenticationException thrown by earlier supporting AuthenticationProviders. On successful authentication, no subsequent AuthenticationProviders will be tried. If authentication was not successful by any supporting AuthenticationProvider the last thrown AuthenticationException will be rethrown.</p>
</blockquote>
<p>让我们对比一下 AuthenticationManger 和 AuthenticationProvider 这两个 interface 的定义。看了下面的定义，你会不会问一个问题：既然两个接口有一个一摸一样的方法 authentication()，为什么不让 AuthenticationProvider 继承 AuthenticationManager？ 我想或许是为了明确两个类的职责吧。<br><img src="/2022/09/19/spring/Authentication-in-Spring-Security/AuthenticationManager.jpg"><br><img src="/2022/09/19/spring/Authentication-in-Spring-Security/AuthenticationProvider.jpg"></p>
<p>以图形的方式看看它们的关系：<br><img src="/2022/09/19/spring/Authentication-in-Spring-Security/authentication-mgr-and-providers.png"></p>
<p>如果我们要实现某个特殊的在 Spring 里没有的认证方式，我们就需要实现自定的 AuthenticationProvider 并通过覆盖 WebSecurityConfigurerAdapter 里的 configure()方法实现。</p>
<pre><code>@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter &#123;

@Autowired
private AuthenticationProvider authenticationProvider;

@Override
protected void configure(AuthenticationManagerBuilder auth) &#123;
    auth.authenticationProvider(authenticationProvider);
&#125;
</code></pre>
<p>不过这个类已经被官方 API 文档标为 Deprecated，并推荐使用 HttpSecurity 定义 SecurityFilterChain 的方式或者通过 WebSecurityCustomizer 来配置 WebSecurity。参考源码：<br><img src="/2022/09/19/spring/Authentication-in-Spring-Security/registerAuthenticationProvider.jpeg"></p>
<p>到这里我们应该已经知道具体的认证逻辑都在 AuthenticationProvider 里。想知道 Spring Security 提供了哪些开箱即用的 provider 吗？见下图，一共 17 个。<br><img src="/2022/09/19/spring/Authentication-in-Spring-Security/authenticationProviders.jpg"></p>
<p>再捋一下与认证相关的类，就结束这篇吧。虽然没有涉及过多细节，相信理解了这些脉略应该也能在 copy-past 代码的时候点点头了。。。<br>SecurityContextHolder：保存 SecurityContext 的地方。<br>SecurityContextHolderStrategy：定义 SecurityContext 在线程中共享的策略模式。如果要跨线越 Spring 管理的线程，请参考 。。。。<br>SecurityContext - 认证成功后 Authentication 对象就放在这里。<br>Authentication - 存放要认证的信息以及被 AuthenticationManager 认证后的结果，认证成功后被放入 SecurityContext。<br>GrantedAuthority - 请求认证的 principal 认证成功后被赋予的权限(i.e. roles, scopes, etc.)<br>AuthenticationManager - authentication 相关的 filter 调用这个对象做认证。<br>AbstractAuthenticationProcessingFilter：各个认证相关 filter 的父类。<br>ProviderManager - AuthenticationManager 的一个实现.<br>AuthenticationProvider - 由 ProviderManager 用来做具体的认证。<br>AuthenticationEntryPoint: 用于询问并接收用户的 credentials，可以是重定向到一个网页或者发送 http WWW-Authenticate response。</p>
<p>我想现在我们看到下面这些类时，就应该能够大致知道/理解他们在 Spring Security Authentication 类图里的位置了吧？<br>UserDetails, User<br>UserDetailsService, UserDetailsManager, JdbcUserDetailsManager<br>PasswordEncoder<br>如果没有，一定是我还没描述清楚。</p>
<br/>

<hr>
<p><em>References:</em><br>[1]: <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html">https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html</a><br>[2]: 《Spring Security in Action》</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-notes/cas/Apereo-CAS-Management-UI" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-09-19T07:55:38.000Z"><a href="/2022/09/19/notes/cas/Apereo-CAS-Management-UI/">2022-09-19</a></time>
      
      
  
    <h1 class="title"><a href="/2022/09/19/notes/cas/Apereo-CAS-Management-UI/">Apereo CAS 之 管理界面</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>类似 cas-server，先下载 cas-management-overlay 代码，这里使用 6.5 分支。</p>
<pre><code>$ git clone https://github.com/apereo/cas-management-overlay cas-management
$ cd cas-management
$ git checkout -b 6.5 origin/6.5
</code></pre>
<p>cas-management 应用本身也需要用户认证之后才能使用。这里使用它自己要管理的 cas-server 作为认证源。这时，cas-manager 本身就是 cas-server 的一个 client 或者说 service 了。<br>因此需要首先 <strong>把 management 配置为 cas-server 的一个 client/service</strong>。</p>
<p>Apereo 支持不同的存储 service 注册的方式：json 文件、JPA、Redis …，这里使用 json 文件的方式把 cas-management 注册为 cas-server 的 service，即让 cas-manager 使用 cas-server 来认证用户。</p>
<h3 id="1）在-cas-server-的-build-gradle-中添加依赖。"><a href="#1）在-cas-server-的-build-gradle-中添加依赖。" class="headerlink" title="1）在 cas-server 的 build.gradle 中添加依赖。"></a>1）在 cas-server 的 build.gradle 中添加依赖。</h3><p>可参考官方文档：<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/services/Service-Management.html#storage">https://apereo.github.io/cas/6.5.x/services/Service-Management.html#storage</a></p>
<pre><code>implementation &quot;org.apereo.cas:cas-server-support-json-service-registry:$&#123;project.&#39;cas.version&#39;&#125;&quot;
</code></pre>
<h3 id="2）告诉-cas-server-在哪里可以找到定义-client-service-的-json-文件"><a href="#2）告诉-cas-server-在哪里可以找到定义-client-service-的-json-文件" class="headerlink" title="2）告诉 cas-server 在哪里可以找到定义 client/service 的 json 文件"></a>2）告诉 cas-server 在哪里可以找到定义 client/service 的 json 文件</h3><p>在文件 etc/cas/config/cas.properties 中加入如下配置：<br><code>cas.service-registry.json.location=classpath:/services</code></p>
<p>在 cas-server 项目的 src/resources 目录下创建一个名为 casManagement-2000.json 的文体。文件名的格式是 clientName + clientId.json，具体请阅读官方文档。</p>
<pre><code>&#123;
  &quot;@class&quot; : &quot;org.apereo.cas.services.RegexRegisteredService&quot;,
  &quot;serviceId&quot; : &quot;^(https|imaps)://.*&quot;,
  &quot;name&quot; : &quot;casManagement&quot;,
  &quot;id&quot; : 2000,
  &quot;logoutType&quot; : &quot;BACK_CHANNEL&quot;,
  &quot;logoutUrl&quot; : &quot;https://localhost:8444/cas-management/logout&quot;
&#125;
</code></pre>
<h3 id="3）配置-cas-management"><a href="#3）配置-cas-management" class="headerlink" title="3）配置 cas-management"></a>3）配置 cas-management</h3><p>上面两步是配置 cas-server 以把 cas-manager 作为它的 client。现在，配置 cas-management。<br>编辑 cas-management 项目里的 etc/case/config/management.properties 文件，内容如下。</p>
<pre><code>cas.server.name=https://localhost:8443
cas.server.prefix=$&#123;cas.server.name&#125;/cas

server.port=8444
mgmt.server-name=https://localhost:8444
mgmt.admin-roles[0]=ROLE_ADMIN
mgmt.user-properties-file=file:/etc/cas/config/users.json

logging.config=file:/etc/cas/config/log4j2-management.xml

server.ssl.key-store=file:/etc/cas/thekeystore
server.ssl.key-store-password=changeit

# Let the cas-management to know where to find/save the registed services
cas.service-registry.json.location=file:YOUR_PATH_TO_DIR_CONTAINS_JSONFILES/services
</code></pre>
<p>需要注意的是要保证 cas.server 和 mgmt server 的端口不要冲突，一个是 8443，一个是 8444。<br>这里方便起见，cas-management 和 cas-server 共享了同一个 keystore。</p>
<p>配置项<code>cas.service-registry.json.location</code>告诉 cas-management 到哪里去读写(管理)定义 client/service 的 json 文件。这个目录<br>是和 cas-server 的 <code>cas.service-registry.json.location=classpath:/services</code> 是一致的。</p>
<h3 id="4）-同时运行-cas-server，cas-management-后，访问-https-localhost-8444-cas-management"><a href="#4）-同时运行-cas-server，cas-management-后，访问-https-localhost-8444-cas-management" class="headerlink" title="4） 同时运行 cas-server，cas-management 后，访问 https://localhost:8444/cas-management/"></a>4） 同时运行 cas-server，cas-management 后，访问 <a target="_blank" rel="noopener" href="https://localhost:8444/cas-management/">https://localhost:8444/cas-management/</a></h3><p><img src="/2022/09/19/notes/cas/Apereo-CAS-Management-UI/apereo_cas_mgmt_ui.jpg" alt="CAS-Management-UI"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-notes/cas/Run-up-Apereo-CAS-locally" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-09-19T07:55:38.000Z"><a href="/2022/09/19/notes/cas/Run-up-Apereo-CAS-locally/">2022-09-19</a></time>
      
      
  
    <h1 class="title"><a href="/2022/09/19/notes/cas/Run-up-Apereo-CAS-locally/">Apereo CAS 之 在本地运行</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>Apereo CAS，是 CAS 协议<code>official reference implementation</code>，也差不多是当前开源的 SSO 解决方案最好、最成熟的一个了。<br>当前版本是 6.5，<a target="_blank" rel="noopener" href="https://github.com/apereo/cas-overlay-template/tree/6.5%E3%80%82">https://github.com/apereo/cas-overlay-template/tree/6.5。</a></p>
<p>本以为按照<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/installation/WAR-Overlay-Installation.html">Apereo CAS 的官方安装指南</a>能够很容易把 cas server 在本地跑起来，但最后发现这个文档实操性略差。这里略过基础概念，直接记录一下本地运行的步骤。</p>
<p>没必要下载源码修改代码、配置然后 build 出自己的安装包，按照官方文档推荐直接使用“WAR Overlay Installation”的方式安装。</p>
<h3 id="1）下载-overlay-框架代码，使用-6-5-分支代码。"><a href="#1）下载-overlay-框架代码，使用-6-5-分支代码。" class="headerlink" title="1）下载 overlay 框架代码，使用 6.5 分支代码。"></a>1）下载 overlay 框架代码，使用 6.5 分支代码。</h3><pre><code>git clone https://github.com/apereo/cas-overlay-template.git cas-server
git checkout -b 6.5 origin/6.5
</code></pre>
<p>Overlays 这个方式是通过 maven-war-plugin 实现的： <a target="_blank" rel="noopener" href="https://maven.apache.org/plugins/maven-war-plugin/overlays.html%EF%BC%8C">https://maven.apache.org/plugins/maven-war-plugin/overlays.html，</a><br>gradle 的实现：<a target="_blank" rel="noopener" href="https://docs.freefair.io/gradle-plugins/current/reference/#_io_freefair_war_overlay">https://docs.freefair.io/gradle-plugins/current/reference/#_io_freefair_war_overlay</a><br>在这个 cas 项目里可参看 ./gradle/springboot.gradle 里 bootWar 部分。</p>
<h3 id="2）gradle-perperties"><a href="#2）gradle-perperties" class="headerlink" title="2）gradle.perperties"></a>2）gradle.perperties</h3><p>这利用这个 overlays 项目运行 CAS 之前，可浏览一下 gradle.properties 文件定义的各个属性。其中，<br><strong>appServer</strong> 用于定义 Apereo CAS server 使用哪个内置 server（Tomcat、Jetty…），如果只生成 war 部署到外部已存在的 servlet contaier 则无需定义此项。<br><strong>certDir、serverKeyStore、exportedServerCert、storeType</strong> 这些选项用于定义 https 所用的证书。</p>
<h3 id="3）gradle-tasks-gradle"><a href="#3）gradle-tasks-gradle" class="headerlink" title="3）gradle/tasks.gradle"></a>3）gradle/tasks.gradle</h3><p><code>./gradlew tasks</code> 运行会显示可执行的 tasks，其中一部分 task 被定义于 gradle/tasks.gradle 文件中。</p>
<pre><code>CAS tasks
---------
casVersion - Display the current CAS version
copyCasConfiguration - Copy the CAS configuration from this project to /etc/cas/config
createKeystore - Create CAS keystore
createTheme - Create theme directory structure in the overlay
... ...
</code></pre>
<p>其中 createKeystore 用于生成 https 所用的证书。<br><code>sudo ./gradlew createKeystore</code></p>
<p>如果需要修改 keystore 的密码，可以执行：<br><code>keytool -storepasswd -keystore /etc/cas/thekeystore</code></p>
<p>生成 https 需要的 PK 和证书后，需要把 CA 导入到 JDK 的的 ca 根证书库中。</p>
<pre><code>cd /etc/cas
sudo keytool -import -alias cas_cert -storepass changeit -file cas.crt -keystore  /Library/Java/JavaVirtualMachines/temurin-11.jdk/Contents/Home/lib/security/cacerts
</code></pre>
<p>查看 ca keystore<br><code>sudo keytools -list -storepass changeit  -keystore  /Library/Java/JavaVirtualMachines/temurin-11.jdk/Contents/Home/lib/security/cacerts</code></p>
<p>从 ca keystore 中删除 cascert<br><code>sudo keytool -delete  -alias cas_cert  -keystore  /Library/Java/JavaVirtualMachines/temurin-11.jdk/Contents/Home/lib/security/cacerts  -storepass changeit</code></p>
<h3 id="4）cas-的配置文件"><a href="#4）cas-的配置文件" class="headerlink" title="4）cas 的配置文件"></a>4）cas 的配置文件</h3><p>把项目中的 etc/cas/config 目录下的默认配置内容 copy 到 /etc/cas/config 中。可以手工 copy 文件，也可以通过 gradle task, <code>./gradlew copyCasConfiguration</code></p>
<p>默认的内置的用户名密码是 casuser/Mellon，可以通过修改/etc/cas/config/cas.properties <code>cas.authn.accept.users=casuser::password</code> 进行定义。</p>
<p>配置登录用户在 Apereo 里属于<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/authentication/Configuring-Authentication-Components.html">CAS Authentication 的范畴</a>。</p>
<h3 id="5）Build-and-Run"><a href="#5）Build-and-Run" class="headerlink" title="5）Build and Run"></a>5）Build and Run</h3><pre><code>./gradlew clean build
java -jar ./build/libs/cas.war
</code></pre>
<p>在浏览器中访问 <a target="_blank" rel="noopener" href="https://localhost:8443/cas">https://localhost:8443/cas</a> 进入 CAS 系统。</p>
<h3 id="6"><a href="#6" class="headerlink" title="6)"></a>6)</h3><p>如果在日志里发现提示<code>The generated key MUST be added to CAS settings</code>， 则可按照提示把 cas.tgc.crypto.encryption.key，cas.tgc.crypto.signing.key 加入到 etc/cas/config/cas.properties 文件。</p>
<pre><code>    2022-08-29 23:29:34,160 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Secret key for encryption is not defined for [Ticket-granting Cookie]; CAS will attempt to auto-generate the encryption key&gt;
    2022-08-29 23:29:34,168 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Generated encryption key [rAHG_XeYnE-DbLtE77fngWAMtbB5lpIXYKbI_nSiD8I] of size [256] for [Ticket-granting Cookie]. The generated key MUST be added to CAS settings:

            cas.tgc.crypto.encryption.key=rAHG_XeYnE-DbLtE77fngWAMtbB5lpIXYKbI_nSiD8I

    &gt;
    2022-08-29 23:29:34,170 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Secret key for signing is not defined for [Ticket-granting Cookie]. CAS will attempt to auto-generate the signing key&gt;
    2022-08-29 23:29:34,170 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Generated signing key [cOlc7xQB5UJTwYrVmA30aQehEkxbSkcyHmE8vRkPHboRZkTn2rBJ8pUUPZfTJt7H8e3ecpitvuH2prrLxfIVxg] of size [512] for [Ticket-granting Cookie]. The generated key MUST be added to CAS settings:

            cas.tgc.crypto.signing.key=cOlc7xQB5UJTwYrVmA30aQehEkxbSkcyHmE8vRkPHboRZkTn2rBJ8pUUPZfTJt7H8e3ecpitvuH2prrLxfIVxg
</code></pre>
<br/>

<hr>
<p><em>Reference:</em><br>[1]: <a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/index.html">https://apereo.github.io/cas/6.5.x/index.html</a><br>[2]: <a target="_blank" rel="noopener" href="https://github.com/apereo/cas-overlay-template/tree/6.5">https://github.com/apereo/cas-overlay-template/tree/6.5</a><br>[3]: <a target="_blank" rel="noopener" href="https://medium.com/swlh/install-cas-server-with-db-authentication-8ff52234f52">https://medium.com/swlh/install-cas-server-with-db-authentication-8ff52234f52</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/Kubernetes-Ingresses-1" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-08-18T07:55:38.000Z"><a href="/2022/08/18/devops/Kubernetes-Ingresses-1/">2022-08-18</a></time>
      
      
  
    <h1 class="title"><a href="/2022/08/18/devops/Kubernetes-Ingresses-1/">Kubernetes Ingresses (1)</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>在连接上一个 K8S cluster 后执行下面的命令可以看到系统中的 ingressclasses。这篇文字用来帮助自己理解下面几行简单的输出。</p>
<pre><code>╰─$ kubectl get ingressclass
NAME       CONTROLLER                     PARAMETERS                             AGE
awslb      ingress.k8s.aws/alb            IngressClassParams.elbv2.k8s.aws/alb   20d
nginx      nginx.org/ingress-controller   &lt;none&gt;                                 30d
os-nginx   k8s.io/ingress-nginx           &lt;none&gt;                                 30d
</code></pre>
<h2 id="Mental-Model"><a href="#Mental-Model" class="headerlink" title="Mental Model"></a>Mental Model</h2><p>在 Kubernets 里经常会提到 Pod，Service，Ingress，Ingress Controller, Ingress Class，那他们之间有什么逻辑关系呢？</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 用于把几个相关的 containers 封装在一起对外提供业务服务，containers 之间可以直接通过 localhost 通讯。而如果想访问 POD 服务只能凭借 POD 的 IP，这个 IP 也是 K8S 集群内部可见，而 POD 的 IP 在每次重建后都会变化，这显然是不可接受的。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 就是为了解决这个问题而生，通过 service.yaml 可以定义 1）这个 service 的 name/namespace；2）由 selector 定义这个 service 对应的 PODs；3）再通过定义 service port 和 pod port 的映射关系，就可以通过 Service 的名称访问 PODs 提供的服务了。Service 借助自己对 Pod 自动发现的能力、服务名到 POD IP 的解析能力、简单的负载均衡能力，成为在 Kubernets 集群内部暴露 Pod 的不二之选。</p>
<h3 id="Ingress-Ingress-Controller-Ingerss-Class"><a href="#Ingress-Ingress-Controller-Ingerss-Class" class="headerlink" title="Ingress / Ingress Controller / Ingerss Class"></a>Ingress / Ingress Controller / Ingerss Class</h3><p>Service 解决了我们在 k8s 集群内部访问‘服务’的问题。如果想从集群外部访问‘服务’呢？这正是“Ingress 机制”七层路由存在的意义。这里的 Ingress 机制由 Ingress Controller、Ingress 这两个概念组成。<br>作为码农，接触较多的一般是 Ingress。这是因为 Ingress Controller 一旦部署到 Kubernetes Cluster 就很少会再去改动，而需要经常改动的应用路由规则都是在 Ingress 这个 Kubernets API 对象(或者说是在 ingress.yaml 文件)完成的。实际上，Ingress Controller 实例才是真正执行<strong>将用户请求路由到 Service 进而到 Pod</strong>的部件。Ingress 只是我们<strong>定义请求到 Service 的路由规则</strong>的对象。</p>
<p>既然“ingress“的核心功能就是 7 层路由/反向代理，那么借助早已存在的 Nginx、HAProxy 等产品实现 IngressController 就是很自然的想法了。另一个 ingress controller 的实现类别可以划分到 service mesh 阵营，比如 Istio Ingerss、Gloo 等。<br>k8s 官网列出的<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">一些 Ingerss Controller 实现</a>。<br>而<a target="_blank" rel="noopener" href="https://blog.palark.com/comparing-ingress-controllers-for-kubernetes/">这篇文章</a>详细讲解了各种 Ingress Controller 的特性以方便我们根据自己项目的需求做出选择。直接贴上文章的干货图片：<br><img src="/2022/08/18/devops/Kubernetes-Ingresses-1/kubernetes-ingress-comparison.png" alt="kubernetes-ingress-comparison"></p>
<p>在一个 Kubernets 集群里可以定义多个不同 Ingress Controller 实现/类型，那么 Ingress 对象如何知道自己的数据是提供给哪个 Ingress Controller 的呢？</p>
<p>在 Kubernetes 1.18 之前，是通过在 Ingress 的一个<strong>annotation</strong> <code>kubernets.io/ingress.class</code> 来声明。<br>在 Kubernetes 1.18 正式引入了一个新的<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-class">k8s 资源对象 IngressClass</a> 来<strong>帮助 Ingress 定义它绑定到哪个 IngressController</strong>。<br>下面是一个官网的 IngressClass 对象定义示例，<code>spec.controll</code>定义了 IngressController 的实现， <code>spec.parameters</code> 相当于定义了你可以在 Ingerss 对象里可以向这个 IngressController 对象能够传递的参数，当然这些参数也是这种 IngressControll 必须支持的。不同的 Ingress Controller 实现其需要的 parameter 肯定是不同的，而 k8s 1.18 之前通过 annoation 给 IngerssController 传递参数的方式就显得比较随意无章可循了，这应该也是 IngressClass 出现的一个原因。</p>
<pre><code>apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: external-lb
spec:
  controller: example.com/ingress-controller
  parameters:
    apiGroup: k8s.example.com
    kind: IngressParameters
    name: external-lb
</code></pre>
<p>有了 IngressClass，那么在 Ingress 中只要设置 <code>spec.ingressClassName</code> 为某个 IngerssClass 的名字，那么就意味着这个 Ingress 的配置就会被这个 IngerssClass 所对应的 IngressController 所获取并被这个 IngressControll 生成为对应的路由 rules，从而完成把一个集群外请求路由到 Service 的功能。</p>
<p>以上就是关于 Kubernetes 里 Ingerss 的几个基本概念。</p>
<h2 id="有关-Nginx-的-IngressController"><a href="#有关-Nginx-的-IngressController" class="headerlink" title="有关 Nginx 的 IngressController"></a>有关 Nginx 的 IngressController</h2><p>基于 Nginx 实现的 IngressController 分为<code>Kubernets社区版</code>和<code>Nginx版</code>。</p>
<p>Kubernets 社区版由 Kubernetes 社区和 F5 Nginx 工程师基于开源的 Nginx 实现，其官网 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/ingress-nginx">code</a> <a target="_blank" rel="noopener" href="https://kubernetes.github.io/ingress-nginx/">doc</a>。</p>
<p>Nginx 版自己又分为免费的基于开源 Nginx 的 IngressController 实现和商业版。Nginx 开源版<a target="_blank" rel="noopener" href="https://github.com/nginxinc/kubernetes-ingress">code</a> <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/">doc</a>。</p>
<p>所以就开源的版本来说，一个是 Kubernets 社区版，一个是 Nginx 开源版，两个都是基于开源的 Nginx 实现的，只是 owner 不通。表现在 IngressClass 的定义中，就是字段 <code>spec.controller</code> 的值一个是 Kubernets 社区版的 <code>k8s.io/ingress-nginx</code>, 一个是 nginx 开源版的 <code>nginx.org/ingress-controller</code></p>
<p>下面<a target="_blank" rel="noopener" href="https://gist.github.com/grigorkh/f8e4fd73e99f0fde06a51e2ed7c2156c">这个表格列</a>出了 Nginx Ingress Controller 的 Kubernets 社区版和 Nginx 开源版的区别。可以看到，两者差别不大，k8s 社区版功能略好于 Nginx 开源版。而 Nginx 开源版因为没有使用 Lua 性能又好于 k8s 社区版。</p>
<table>
<thead>
<tr>
<th>Aspect or Feature</th>
<th>kubernetes/ingress-nginx</th>
<th>nginxinc/kubernetes-ingress with NGINX</th>
<th>nginxinc/kubernetes-ingress with NGINX Plus</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Fundamental</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Authors</td>
<td>Kubernetes community</td>
<td>NGINX Inc and community</td>
<td>NGINX Inc and community</td>
</tr>
<tr>
<td>NGINX version</td>
<td><a target="_blank" rel="noopener" href="https://github.com/kubernetes/ingress-nginx/tree/master/images/nginx">Custom</a> NGINX build that includes several third-party modules</td>
<td>NGINX official mainline <a target="_blank" rel="noopener" href="https://github.com/nginxinc/docker-nginx">build</a></td>
<td>NGINX Plus</td>
</tr>
<tr>
<td>Commercial support</td>
<td>N/A</td>
<td>N/A</td>
<td>Included</td>
</tr>
<tr>
<td>Implemented in</td>
<td>Go/Lua (while Nginx is written in C)</td>
<td>Go/Python</td>
<td>Go/Python</td>
</tr>
<tr>
<td><strong>Load balancing configuration via the Ingress resource</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Merging Ingress rules with the same host</td>
<td>Supported</td>
<td>Supported via <a href="../examples/mergeable-ingress-types">Mergeable Ingresses</a></td>
<td>Supported via <a href="../examples/mergeable-ingress-types">Mergeable Ingresses</a></td>
</tr>
<tr>
<td>HTTP load balancing extensions - Annotations</td>
<td>See the <a target="_blank" rel="noopener" href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/">supported annotations</a></td>
<td>See the <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/advanced-configuration-with-annotations/">supported annotations</a></td>
<td>See the <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/advanced-configuration-with-annotations/">supported annotations</a></td>
</tr>
<tr>
<td>HTTP load balancing extensions – ConfigMap</td>
<td>See the <a target="_blank" rel="noopener" href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/">supported ConfigMap keys</a></td>
<td>See the <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/global-configuration/configmap-resource/">supported ConfigMap keys</a></td>
<td>See the <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/global-configuration/configmap-resource/">supported ConfigMap keys</a></td>
</tr>
<tr>
<td>TCP/UDP</td>
<td>Supported via a ConfigMap</td>
<td>Supported via custom resources</td>
<td>Supported via custom resources</td>
</tr>
<tr>
<td>Websocket</td>
<td>Supported</td>
<td>Supported via an <a href="../examples/websocket">annotation</a></td>
<td>Supported via an <a href="../examples/websocket">annotation</a></td>
</tr>
<tr>
<td>TCP SSL Passthrough</td>
<td>Supported via a ConfigMap</td>
<td>Supported via custom resources</td>
<td>Supported via custom resources</td>
</tr>
<tr>
<td>JWT validation</td>
<td>Not supported</td>
<td>Not supported</td>
<td>Supported</td>
</tr>
<tr>
<td>Session persistence</td>
<td>Supported via a third-party module</td>
<td>Not supported</td>
<td>Supported</td>
</tr>
<tr>
<td>Canary testing (by header, cookie, weight)</td>
<td>Supported via annotations</td>
<td>Supported via custom resources</td>
<td>Supported via custom resources</td>
</tr>
<tr>
<td>Configuration templates</td>
<td>See the <a target="_blank" rel="noopener" href="https://github.com/kubernetes/ingress-nginx/blob/master/rootfs/etc/nginx/template/nginx.tmpl">template</a></td>
<td>See the <a href="../internal/configs/version1">templates</a></td>
<td>See the <a href="../internal/configs/version1">templates</a></td>
</tr>
<tr>
<td><strong>Load balancing configuration via Custom Resources</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>HTTP load balancing</td>
<td>Not supported</td>
<td>See <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/">VirtualServer and VirtualServerRoute</a> resources</td>
<td>See <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/">VirtualServer and VirtualServerRoute</a> resources</td>
</tr>
<tr>
<td>TCP/UDP load balancing</td>
<td>Not supported</td>
<td>See <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/transportserver-resource/">TransportServer</a> resource</td>
<td>See <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/transportserver-resource/">TransportServer</a> resource</td>
</tr>
<tr>
<td>TCP SSL Passthrough load balancing</td>
<td>Not supported</td>
<td>See <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/transportserver-resource/">TransportServer</a> resource</td>
<td>See <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/transportserver-resource/">TransportServer</a> resource</td>
</tr>
<tr>
<td><strong>Deployment</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Command-line arguments</td>
<td>See the <a target="_blank" rel="noopener" href="https://kubernetes.github.io/ingress-nginx/user-guide/cli-arguments/">arguments</a></td>
<td>See the <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/global-configuration/command-line-arguments/">arguments</a></td>
<td>See the <a target="_blank" rel="noopener" href="https://docs.nginx.com/nginx-ingress-controller/configuration/global-configuration/command-line-arguments/">arguments</a></td>
</tr>
<tr>
<td>TLS certificate and key for the default server</td>
<td>Required as a command-line argument/ auto-generated</td>
<td>Required as a command-line argument</td>
<td>Required as a command-line argument</td>
</tr>
<tr>
<td>Helm chart</td>
<td>Supported</td>
<td>Supported</td>
<td>Supported</td>
</tr>
<tr>
<td>Operator</td>
<td>Not supported</td>
<td>Supported</td>
<td>Supported</td>
</tr>
<tr>
<td><strong>Operational</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Reporting the IP address(es) of the Ingress controller into Ingress resources</td>
<td>Supported</td>
<td>Supported</td>
<td>Supported</td>
</tr>
<tr>
<td>Extended Status</td>
<td>Supported via a third-party module</td>
<td>Not supported</td>
<td>Supported</td>
</tr>
<tr>
<td>Prometheus Integration</td>
<td>Supported</td>
<td>Supported</td>
<td>Supported</td>
</tr>
<tr>
<td>Dynamic reconfiguration of endpoints (no configuration reloading)</td>
<td>Supported with a third-party Lua module</td>
<td>Not supported</td>
<td>Supported</td>
</tr>
</tbody></table>
<p>再回到文章开头的命令输出，是不是看到的更多了些？</p>
<pre><code>╰─$ kubectl get ingressclass
NAME       CONTROLLER                     PARAMETERS                             AGE
awslb      ingress.k8s.aws/alb            IngressClassParams.elbv2.k8s.aws/alb   20d
nginx      nginx.org/ingress-controller   &lt;none&gt;                                 30d
os-nginx   k8s.io/ingress-nginx           &lt;none&gt;                                 30d
</code></pre>
<p><em>References</em>:<br>[1]: <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress</a><br>[2]: <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">IngressController</a><br>[3]: <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-class">IngressClass</a><br>[4]: <a target="_blank" rel="noopener" href="https://blog.palark.com/comparing-ingress-controllers-for-kubernetes/">Comparing Ingress Controllers for Kubernetes</a><br>[5]: <a target="_blank" rel="noopener" href="https://www.nginx.com/blogguide-to-choosing-ingress-controller-part-4-nginx-ingress-controller-options/">基于 Nginx 的 Ingress Controller 在社区和商业版之间的比较</a><br>[6]: <a target="_blank" rel="noopener" href="https://kubernetes.github.io/ingress-nginx/">Kubernetes 社区版</a><br>[7]: <a target="_blank" rel="noopener" href="https://kubernetes.github.io/ingress-nginx/">Nginx 开源版</a><br>[8]: <a target="_blank" rel="noopener" href="https://grigorkh.medium.com/there-are-two-nginx-ingress-controllers-for-k8s-what-44c7b548e678">Nginx Ingress Controll 社区版和 Nginx 开源版的比较</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-spring/BsonUndefined_caused_ConverterNotFoundException" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-08-11T07:55:38.000Z"><a href="/2022/08/11/spring/BsonUndefined_caused_ConverterNotFoundException/">2022-08-11</a></time>
      
      
  
    <h1 class="title"><a href="/2022/08/11/spring/BsonUndefined_caused_ConverterNotFoundException/">如何解决 No converter found capable of converting from type org.bson.BsonUndefined 问题</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>因为 MongoDB 数据中有的字段值为’undefined’，程序程序访问到这个数据时抛出如下 exception</p>
<blockquote>
<p>org.springframework.core.convert.ConverterNotFoundException: No converter found capable of converting from type org.bson.BsonUndefined to type XXXXX.</p>
</blockquote>
<p>我们可以通过一下几步解决这个问题：</p>
<h3 id="1）我们首先需要分析是什么情况导致数据中存在-undefined-值。"><a href="#1）我们首先需要分析是什么情况导致数据中存在-undefined-值。" class="headerlink" title="1）我们首先需要分析是什么情况导致数据中存在 undefined 值。"></a>1）我们首先需要分析是什么情况导致数据中存在 undefined 值。</h3><p>从 BSON 的规范 <a target="_blank" rel="noopener" href="https://bsonspec.org/spec.html">https://bsonspec.org/spec.html</a> 看，undefined 已经是 depricated。数据库中出现 undefined 的多半说明程序有问题，所以需要找出是在哪里、什么情况下向 MongoDB 写入了 undefined value 并进行修改。</p>
<h3 id="2）如果这个问题仅存在于开发、测试环境，而不是遗留数据导致。"><a href="#2）如果这个问题仅存在于开发、测试环境，而不是遗留数据导致。" class="headerlink" title="2）如果这个问题仅存在于开发、测试环境，而不是遗留数据导致。"></a>2）如果这个问题仅存在于开发、测试环境，而不是遗留数据导致。</h3><p>那么修正代码出错的地方并清理数据库中的脏数据就可以了。</p>
<h3 id="3）如果这种脏数据是遗留数据并且在生产环境也是存在的。"><a href="#3）如果这种脏数据是遗留数据并且在生产环境也是存在的。" class="headerlink" title="3）如果这种脏数据是遗留数据并且在生产环境也是存在的。"></a>3）如果这种脏数据是遗留数据并且在生产环境也是存在的。</h3><p>那么我们可以通过添加一个 converter 类</p>
<pre><code>BsonUndefinedToNullObjectConverterFactory implements ConverterFactory&lt;BsonUndefined, Object&gt;
</code></pre>
<p>把 undefined 转为<strong>任意类型</strong>对象的 null，就可以避免如上的 Exception。代码如 stackoverflow 上的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/37066690/no-converter-found-capable-of-converting-from-type-org-bson-bsonundefined">这篇帖子</a>。把 Converter 传给 mongoTemplate，我们就需要定义一个 MongoCustomConversions Bean。为什么需要这样的 Bean，可以参考 AbstractMongoClientConfiguration 的源代码。因为 AbstractMongoClientConfiguration 中已经定义了一个 MongoCustomConversions bean，我们就需要给自己的 Bean 加上@Primary，以便让 spring-data-mongo 优先使用我们设置了自定义 converter 的 MongoCustomConversions bean。</p>
<p>如果你的 spring application 还是通过 XML 方式进行 beans 定义与组装的，那么你就不能通过定义一个 ConverterFactory 来方便地把 undefined 转为<strong>任意类型</strong>对象的 null 了。这是因为 XML 不支持类型化参数。这时，只能把 converter 一个个地定义出来。XML 的组装大致如下：</p>
<pre><code>&lt;mongo:mapping-converter id=&quot;mappingConverter&quot; &gt;
    &lt;mongo:custom-converters&gt;
        &lt;mongo:converter&gt;
            &lt;bean class=&quot;your.package.UndefinedToLongNullReadConverter&quot;/&gt;
        &lt;/mongo:converter&gt;
        &lt;mongo:converter&gt;
            &lt;bean class=&quot;your.package.UndefinedToStringNullReadConverter&quot;/&gt;
        &lt;/mongo:converter&gt;
    &lt;/mongo:custom-converters&gt;
&lt;/mongo:mapping-converter&gt;
</code></pre>
<h3 id="4）到这里即使数据库里有脏数据，程序也能‘愉快’地运行了。问题似乎已经被彻底解决了，其实没有。"><a href="#4）到这里即使数据库里有脏数据，程序也能‘愉快’地运行了。问题似乎已经被彻底解决了，其实没有。" class="headerlink" title="4）到这里即使数据库里有脏数据，程序也能‘愉快’地运行了。问题似乎已经被彻底解决了，其实没有。"></a>4）到这里即使数据库里有脏数据，程序也能‘愉快’地运行了。问题似乎已经被彻底解决了，其实没有。</h3><p>因为生产环境的脏数据还没有被清理，我们现在只是容忍了脏数据的存在。在当前微服务架构下，这样的数据可能会被多个不同的微服务访问到，这就意味着这些微服务都要使用如上所述的一个 converter 才能避免 exception。我们有必要发现这些脏数据存在的位置，并进行清理。<br>通过在 converter 返回 o -&gt; null 之前，执行下面的代码就可以通过 log 看到是哪个 DAO 触发了这个转换，进而可以分析出哪个 collection 存在脏数据。如果我们清理了这个 collection 的所有脏数据之后这种 undefined 脏数据还是会产生出来，那么我们就应该好好 review 一下之前的代码是哪里有问题并进行修改了。</p>
<pre><code>StackTraceElement[] causes = Thread.currentThread().getStackTrace();
for(StackTraceElement st : causes)&#123;
    if (st.toString().indexOf(&quot;YOUR_DAO_PACKAGE&quot;) &gt;= 0) &#123;
        log.warn(st.toString());
    &#125; else &#123;
        log.info(st.toString());
    &#125;
&#125;
</code></pre>
<p>如果是使用 JDK9 及以上，那么可以使用 StackWalker 避免 getStackTrace()的性能损耗。可以参考 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2347828/how-expensive-is-thread-getstacktrace%E3%80%82">https://stackoverflow.com/questions/2347828/how-expensive-is-thread-getstacktrace。</a></p>
<p>写了个 Demo 来复现并解决这个问题，代码可参考<a target="_blank" rel="noopener" href="https://github.com/dhyuan/demo_projects/tree/master/mongo_testcontainer">这里</a>。</p>
<p><em>Reference:</em></p>
<p><em><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#mapping-chapter">https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#mapping-chapter</a></em></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-spring/spring_jdbc_and_data" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-08-11T07:55:38.000Z"><a href="/2022/08/11/spring/spring_jdbc_and_data/">2022-08-11</a></time>
      
      
  
    <h1 class="title"><a href="/2022/08/11/spring/spring_jdbc_and_data/">Spring提供的对数据(库)访问的几个套路</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>不使用 Spring 框架的情况下，Java 访问 RDBMS 会通过原始的 JDBC 或者借助 MyBatis、Hibernate、Jooq 这些能够进行对象封装的库。<br>MyBatis 在国内挺流行的，在欧美背景的企业里基本没有使用。</p>
<p>在 Spring 的世界里进行 SQL 数据库访问，基本可分为三种方式：1）Spring JDBC；2）Spring Data JDBC；3）Spring Data JPA。</p>
<h3 id="1）Spring-JDBC；"><a href="#1）Spring-JDBC；" class="headerlink" title="1）Spring JDBC；"></a>1）Spring JDBC；</h3><p>使用 JdbcTemplate 进行各种数据库操作。对于实体类不用加注任何 annotation。在@Repository 类中通过 jdbcTemplate 操作数据库数据。</p>
<h3 id="2）Spring-Data-JDBC；"><a href="#2）Spring-Data-JDBC；" class="headerlink" title="2）Spring Data JDBC；"></a>2）Spring Data JDBC；</h3><p>这个就有些领域对象的味道。每个实体类需要定义@Id (org.springframework.data.annotation.Id)字段。<br>定义接口@Repository  继承 CrudRepository&lt;T, R&gt;，在方法上标注@Query 定义查询语句，而无需实现。有 Spring 自动生成实现类，底层就是借助 JdbcTemplate、NamedParameterJdbcTemplate。<br>在 pom 中需导入 spring-data-jdbc，并使用@EnableJdbcRepositories 进行配置。。</p>
<h3 id="3）Spring-Data-JPA。"><a href="#3）Spring-Data-JPA。" class="headerlink" title="3）Spring Data JPA。"></a>3）Spring Data JPA。</h3><p>Spring Data JPA 内部基于 Hibernate 这样的 ORM 实现，可以看作是 spring 对 JPA 的封装(解决方案)。<br>实体类需要标注@Entity、@Table 定义对应的表，还需要有个@Id（javax.persistence.Id）字段。<br>定义的@Repository 接口中可以通过@Query 标注查询语句之外还可以通过约定的 metho name 自动生成查询。</p>
<p>对于 NoSQL 数据库，Spring 对不同的数据库提供对应的模块进行支持。对于 MongoDB 来说就是 spring-boot-starter-data-mongodb。</p>
<h3 id="4）MongoRepository"><a href="#4）MongoRepository" class="headerlink" title="4）MongoRepository"></a>4）MongoRepository</h3><p>实体类上使用标注@Document，属性字段上可使用@Id（org.bson.types.ObjectId），@Indexed，@Field 等。<br>定义的@Repository 接口继承 MongoRepository&lt;T, R&gt;，同 Spring Data JPA 一样：方法名上加@Query 定义查询、也可通过约定的 metho name 自动生成查询。spring 自动生成实现类。</p>
<h3 id="5）ReactiveMongoRepository"><a href="#5）ReactiveMongoRepository" class="headerlink" title="5）ReactiveMongoRepository"></a>5）ReactiveMongoRepository</h3><p>MongoDB 驱动是支持 reactive 的。Spring 通过 spring-boot-starter-data-mongo-reactive 进行支持。<br>实体类如使用 MongoRepository 一样，通过@Document、@org.bson.types.ObjectId 标识自己。@Repository 接口继承 ReactiveMongoRepository&lt;T, R&gt;即可。这样就可以愉快地使用 Flux、Mono 了。</p>
<p>上面简单的罗列了一下是 Spring 对数据访问支持的几个方案。没有特殊要求，作为业务开发使用相对高层的 JPA 应该是不错的选择。如果进行响应式编程，根据后台数据服务的不同选用 ReactiveMongoRepository、ReactiveCRUDRepository。</p>
<h3 id="6）测试-ReactiveMongoRepository"><a href="#6）测试-ReactiveMongoRepository" class="headerlink" title="6）测试 ReactiveMongoRepository"></a>6）测试 ReactiveMongoRepository</h3><p>如果是使用 Junit5，通过 org.junit.jupiter.api.Test 测试，那么只要在测试类上标注@DataMongoTest 即可。<br>如果是基于 Junit4，则需要在测试类上除了@DataMongoTest 还需再标注@RunWith(SpringRunner.class)。<br>@DataMongoTest 的作用是“disable full auto-configuration and instead apply only configuration relevant to MongoDB tests.” 因为对 DAO 这个层面进行测试完全没必要引入类似 WebContext 这样耗能的上下文环境，如下所示即可。</p>
<pre><code>@DataMongoTest
public class UserDaoTest &#123;

    @Autowired
    private ReactiveMongoUserRepository userRepository;

    @Test
    public void testCreateUser() &#123;
      ... ...
</code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/3/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="as_sitesearch" value="dhyuan.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/AWS/">AWS</a><small>2</small></li>
  
    <li><a href="/tags/CAS/">CAS</a><small>5</small></li>
  
    <li><a href="/tags/Concurrency/">Concurrency</a><small>6</small></li>
  
    <li><a href="/tags/DevOps/">DevOps</a><small>31</small></li>
  
    <li><a href="/tags/FP/">FP</a><small>2</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
  
    <li><a href="/tags/Ingerss/">Ingerss</a><small>1</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>10</small></li>
  
    <li><a href="/tags/Kubernetes/">Kubernetes</a><small>3</small></li>
  
    <li><a href="/tags/Maven/">Maven</a><small>2</small></li>
  
    <li><a href="/tags/MicroService/">MicroService</a><small>3</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>6</small></li>
  
    <li><a href="/tags/Nginx/">Nginx</a><small>2</small></li>
  
    <li><a href="/tags/Reactive/">Reactive</a><small>8</small></li>
  
    <li><a href="/tags/SAGA/">SAGA</a><small>1</small></li>
  
    <li><a href="/tags/Scala/">Scala</a><small>7</small></li>
  
    <li><a href="/tags/Security/">Security</a><small>12</small></li>
  
    <li><a href="/tags/Spring/">Spring</a><small>14</small></li>
  
    <li><a href="/tags/android/">android</a><small>1</small></li>
  
    <li><a href="/tags/network/">network</a><small>2</small></li>
  
    <li><a href="/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><small>13</small></li>
  
    <li><a href="/tags/%E7%BD%91%E4%B8%8A%E5%A5%BD%E6%96%87/">网上好文</a><small>1</small></li>
  
  </ul>
</div>


  
  <div class="widget widget-archives">
    <h3 class="title">归档</h3>
    <div class="entry">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2025 Dahui
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
