<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | 浅流</title>
  <meta name="author" content="Dahui">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="浅流"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">浅流</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-notes/cas/Run-up-Apereo-CAS-locally" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.276Z"><a href="/2025/01/25/notes/cas/Run-up-Apereo-CAS-locally/">2025-01-25</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/25/notes/cas/Run-up-Apereo-CAS-locally/">Apereo CAS 之 在本地运行</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>Apereo CAS，是CAS协议<code>official reference implementation</code>，也差不多是当前开源的SSO解决方案最好、最成熟的一个了。<br>当前版本是6.5，<a target="_blank" rel="noopener" href="https://github.com/apereo/cas-overlay-template/tree/6.5%E3%80%82">https://github.com/apereo/cas-overlay-template/tree/6.5。</a></p>
<p>本以为按照<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/installation/WAR-Overlay-Installation.html">Apereo CAS的官方安装指南</a>能够很容易把cas server在本地跑起来，但最后发现这个文档实操性略差。这里略过基础概念，直接记录一下本地运行的步骤。</p>
<p>没必要下载源码修改代码、配置然后build出自己的安装包，按照官方文档推荐直接使用“WAR Overlay Installation”的方式安装。</p>
<h3 id="1）下载overlay框架代码，使用6-5分支代码。"><a href="#1）下载overlay框架代码，使用6-5分支代码。" class="headerlink" title="1）下载overlay框架代码，使用6.5分支代码。"></a>1）下载overlay框架代码，使用6.5分支代码。</h3><pre><code>git clone https://github.com/apereo/cas-overlay-template.git cas-server
git checkout -b 6.5 origin/6.5
</code></pre>
<p>Overlays这个方式是通过maven-war-plugin实现的： <a target="_blank" rel="noopener" href="https://maven.apache.org/plugins/maven-war-plugin/overlays.html%EF%BC%8C">https://maven.apache.org/plugins/maven-war-plugin/overlays.html，</a><br>gradle的实现：<a target="_blank" rel="noopener" href="https://docs.freefair.io/gradle-plugins/current/reference/#_io_freefair_war_overlay">https://docs.freefair.io/gradle-plugins/current/reference/#_io_freefair_war_overlay</a><br>在这个cas项目里可参看 ./gradle/springboot.gradle 里bootWar部分。</p>
<h3 id="2）gradle-perperties"><a href="#2）gradle-perperties" class="headerlink" title="2）gradle.perperties"></a>2）gradle.perperties</h3><p>这利用这个overlays项目运行CAS之前，可浏览一下gradle.properties文件定义的各个属性。其中，<br><strong>appServer</strong> 用于定义Apereo CAS server使用哪个内置server（Tomcat、Jetty…），如果只生成war部署到外部已存在的servlet contaier则无需定义此项。<br><strong>certDir、serverKeyStore、exportedServerCert、storeType</strong> 这些选项用于定义https所用的证书。</p>
<h3 id="3）gradle-tasks-gradle"><a href="#3）gradle-tasks-gradle" class="headerlink" title="3）gradle/tasks.gradle"></a>3）gradle/tasks.gradle</h3><p><code>./gradlew tasks</code> 运行会显示可执行的tasks，其中一部分task被定义于 gradle/tasks.gradle 文件中。</p>
<pre><code>CAS tasks
---------
casVersion - Display the current CAS version
copyCasConfiguration - Copy the CAS configuration from this project to /etc/cas/config
createKeystore - Create CAS keystore
createTheme - Create theme directory structure in the overlay
... ...
</code></pre>
<p>其中 createKeystore 用于生成https所用的证书。<br><code>sudo ./gradlew createKeystore</code></p>
<p>如果需要修改keystore的密码，可以执行：<br><code>keytool -storepasswd -keystore /etc/cas/thekeystore</code></p>
<p>生成https需要的PK和证书后，需要把CA导入到JDK的的ca根证书库中。</p>
<pre><code>cd /etc/cas
sudo keytool -import -alias cas_cert -storepass changeit -file cas.crt -keystore  /Library/Java/JavaVirtualMachines/temurin-11.jdk/Contents/Home/lib/security/cacerts
</code></pre>
<p>查看ca keystore<br><code>sudo keytools -list -storepass changeit  -keystore  /Library/Java/JavaVirtualMachines/temurin-11.jdk/Contents/Home/lib/security/cacerts</code></p>
<p>从ca keystore中删除cascert<br><code>sudo keytool -delete  -alias cas_cert  -keystore  /Library/Java/JavaVirtualMachines/temurin-11.jdk/Contents/Home/lib/security/cacerts  -storepass changeit</code></p>
<h3 id="4）cas的配置文件"><a href="#4）cas的配置文件" class="headerlink" title="4）cas的配置文件"></a>4）cas的配置文件</h3><p>把项目中的 etc/cas/config 目录下的默认配置内容copy到 /etc/cas/config 中。可以手工copy文件，也可以通过gradle task, <code>./gradlew copyCasConfiguration</code></p>
<p>默认的内置的用户名密码是 casuser/Mellon，可以通过修改/etc/cas/config/cas.properties <code>cas.authn.accept.users=casuser::password</code> 进行定义。</p>
<p>配置登录用户在Apereo里属于<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/authentication/Configuring-Authentication-Components.html">CAS Authentication 的范畴</a>。</p>
<h3 id="5）Build-and-Run"><a href="#5）Build-and-Run" class="headerlink" title="5）Build and Run"></a>5）Build and Run</h3><pre><code>./gradlew clean build
java -jar ./build/libs/cas.war
</code></pre>
<p>在浏览器中访问 <a target="_blank" rel="noopener" href="https://localhost:8443/cas">https://localhost:8443/cas</a> 进入CAS系统。</p>
<h3 id="6"><a href="#6" class="headerlink" title="6)"></a>6)</h3><p>如果在日志里发现提示<code>The generated key MUST be added to CAS settings</code>， 则可按照提示把cas.tgc.crypto.encryption.key，cas.tgc.crypto.signing.key 加入到etc/cas/config/cas.properties 文件。</p>
<pre><code>    2022-08-29 23:29:34,160 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Secret key for encryption is not defined for [Ticket-granting Cookie]; CAS will attempt to auto-generate the encryption key&gt;
    2022-08-29 23:29:34,168 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Generated encryption key [rAHG_XeYnE-DbLtE77fngWAMtbB5lpIXYKbI_nSiD8I] of size [256] for [Ticket-granting Cookie]. The generated key MUST be added to CAS settings:

            cas.tgc.crypto.encryption.key=rAHG_XeYnE-DbLtE77fngWAMtbB5lpIXYKbI_nSiD8I

    &gt;
    2022-08-29 23:29:34,170 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Secret key for signing is not defined for [Ticket-granting Cookie]. CAS will attempt to auto-generate the signing key&gt;
    2022-08-29 23:29:34,170 WARN [org.apereo.cas.util.cipher.BaseStringCipherExecutor] - &lt;Generated signing key [cOlc7xQB5UJTwYrVmA30aQehEkxbSkcyHmE8vRkPHboRZkTn2rBJ8pUUPZfTJt7H8e3ecpitvuH2prrLxfIVxg] of size [512] for [Ticket-granting Cookie]. The generated key MUST be added to CAS settings:

            cas.tgc.crypto.signing.key=cOlc7xQB5UJTwYrVmA30aQehEkxbSkcyHmE8vRkPHboRZkTn2rBJ8pUUPZfTJt7H8e3ecpitvuH2prrLxfIVxg
</code></pre>
<br/>

<hr>
<p><em>Reference:</em><br>[1]: <a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/index.html">https://apereo.github.io/cas/6.5.x/index.html</a><br>[2]: <a target="_blank" rel="noopener" href="https://github.com/apereo/cas-overlay-template/tree/6.5">https://github.com/apereo/cas-overlay-template/tree/6.5</a><br>[3]: <a target="_blank" rel="noopener" href="https://medium.com/swlh/install-cas-server-with-db-authentication-8ff52234f52">https://medium.com/swlh/install-cas-server-with-db-authentication-8ff52234f52</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-notes/cas/enable-OAuth-support-for-Apereo-CAS" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.276Z"><a href="/2025/01/25/notes/cas/enable-OAuth-support-for-Apereo-CAS/">2025-01-25</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/25/notes/cas/enable-OAuth-support-for-Apereo-CAS/">Apereo CAS 之 支持OAuth2</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>Apereo CAS 通过使用bridge模式来支持多个协议：CAS、SAML2、OAuth2、OpenID Connect等。<br>CAS可部署软件包中已经包含了可以使用SAML2、OAuth2等协议的plugin/bridges/modules，这些plugins模块都是和CAS通信。 可参考：<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/protocol/Protocol-Overview.html%E3%80%82">https://apereo.github.io/cas/6.5.x/protocol/Protocol-Overview.html。</a> </p>
<p><code>The right-hand side of that equation is always CAS when you consider, as an example, the following authentication flow with an OAuth2-enabled client application:</code></p>
<ol>
<li>The CAS deployment has turned on the OAuth2 plugin.</li>
<li>An OAuth2 authorization request is submitted to the relevant CAS endpoint.</li>
<li>The OAuth2 plugin verifies the request and translates it to a CAS authentication request!</li>
<li>The authentication request is routed to the relevant CAS login endpoint.</li>
<li>User authenticates and CAS routes the flow back to the OAuth2 plugin, having issued a service ticket for the plugin.</li>
<li>The OAuth2 plugin attempts to validate that ticket to retrieve the necessary user profile and attributes.</li>
<li>The OAuth2 plugin then proceeds to issue the right OAuth2 response by translating and transforming the profile and validated assertions into what the client application may need.</li>
</ol>
<h3 id="1-添加依赖库"><a href="#1-添加依赖库" class="headerlink" title="1. 添加依赖库"></a>1. 添加依赖库</h3><pre><code>implementation &quot;org.apereo.cas:cas-server-support-oauth-webflow&quot;
</code></pre>
<h3 id="2-Enable-Actuator-Endpoints-（Optional）"><a href="#2-Enable-Actuator-Endpoints-（Optional）" class="headerlink" title="2. Enable Actuator Endpoints （Optional）"></a>2. Enable Actuator Endpoints （Optional）</h3><p>添加依赖，并设置开放oauthd的actuator端点。</p>
<pre><code>implementation &quot;org.apereo.cas:cas-server-support-reports&quot;

management.endpoint.oauthTokens.enabled=true
management.endpoints.web.exposure.include=oauthTokens
cas.monitor.endpoints.endpoint.oauthTokens.access=PERMIT
</code></pre>
<p>通过访问 <a target="_blank" rel="noopener" href="https://localhost:8443/cas/actuator/">https://localhost:8443/cas/actuator/</a> 应该可以看到OAuth相关endpoints。</p>
<h3 id="3-定义一个OAuth-Client"><a href="#3-定义一个OAuth-Client" class="headerlink" title="3. 定义一个OAuth Client"></a>3. 定义一个OAuth Client</h3><p>可以通过设置</p>
<pre><code>cas.service-registry.json.location=classpath:/services
cas.service-registry.core.init-from-json=true
</code></pre>
<p>在 cas-overlay-template的 resources/services 下定义文件 OAuth2DemoClient-2001.json 包含以下内容来把这个OAuth2 Client ‘OAuth2DemoClient’ 自动导入到MongoDB 的 cas_serviceregistry collection。</p>
<pre><code>&#123;
  &quot;@class&quot; : &quot;org.apereo.cas.support.oauth.services.OAuthRegisteredService&quot;,
  &quot;clientId&quot;: &quot;oauth2DemoClientID&quot;,
  &quot;clientSecret&quot;: &quot;clientSecret&quot;,
  &quot;serviceId&quot; : &quot;^(https|imaps)://&lt;redirect-uri&gt;.*&quot;,
  &quot;name&quot; : &quot;OAuth2DemoClient&quot;,
  &quot;id&quot; : 2001,
  &quot;supportedGrantTypes&quot;: [ &quot;java.util.HashSet&quot;, [ &quot;password&quot;, &quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;] ],
  &quot;supportedResponseTypes&quot;: [ &quot;java.util.HashSet&quot;, [ &quot;token&quot;, &quot;code&quot;, &quot;device_code&quot;] ]
&#125;
</code></pre>
<p>grant是获得AccessToken的方式/方法，这篇文章对此进行了详细介绍：<a target="_blank" rel="noopener" href="https://alexbilbie.com/guide-to-oauth-2-grants/%E3%80%82">https://alexbilbie.com/guide-to-oauth-2-grants/。</a></p>
<h3 id="4-重启、查看"><a href="#4-重启、查看" class="headerlink" title="4. 重启、查看"></a>4. 重启、查看</h3><p>运行 <code>./gradlew clean copyCasConfiguration build run </code> 后，查看 <code>db.getCollection(&#39;cas_serviceregistry&#39;).find(&#123;&#125;)</code> 应该可以看到id为2001的 OAutho client定义。</p>
<p>通过CAS Management UI也可以看到刚刚添加的‘OAuth2DemoClient’：<br><img src="/2025/01/25/notes/cas/enable-OAuth-support-for-Apereo-CAS/OAuth2Client_view.jpg" alt="An OAuth Client/Service"></p>
<p>至此，我们以及把Apereo CAS配置成支持OAuth2协议。</p>
<br/>

<hr>
<p><em>Reference:</em><br>[1]: <a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/protocol/Protocol-Overview.html">https://apereo.github.io/cas/6.5.x/protocol/Protocol-Overview.html</a><br>[2]: <a target="_blank" rel="noopener" href="https://alexbilbie.com/guide-to-oauth-2-grants/">https://alexbilbie.com/guide-to-oauth-2-grants/</a><br>[3]: <a target="_blank" rel="noopener" href="https://dacurry-tns.github.io/deploying-apereo-cas/building_server_service-registry_configure-the-service-registry.html">https://dacurry-tns.github.io/deploying-apereo-cas/building_server_service-registry_configure-the-service-registry.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-notes/test/Performance-Test-101" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.276Z"><a href="/2025/01/25/notes/test/Performance-Test-101/">2025-01-25</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/25/notes/test/Performance-Test-101/">Performance Test 101</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>无论是哪种测试：单元测试、集成测试、回归测试等，目的都是找到breaking points、消除性能瓶颈。</p>
<p>对于Performance Test来说，我们希望在期望的负载下验证我们的系统是否在 <strong>速度</strong>、 <strong>伸缩性</strong>、 <strong>稳定性</strong> 方面满足系统对性能的需求。一般来说我们希望系统能在RPS和latency之间达到一个不错的平衡。  </p>
<p>最最基础的两个指标：</p>
<p><strong>RPS</strong> (request per sec):<br>每秒系统可接受/处理的请求数。值得注意的时，虽然请求可被接收或者处理，但是处理的结果可能是正常启动的value也有可能因为系统压力的原因而是Error。</p>
<p>这篇文章讲了<a target="_blank" rel="noopener" href="https://medium.com/@novyludek/virtual-users-vs-rps-77627b384127">RPS和Virtual User的概念</a> ，可以帮助理解为什么不是RPS越高越好而是RPS与Latence之间的平衡。其中讲到Virutal User的生命周期是到测试结束，这一点对我们理解和写测试代码挺重要的。<br><code>The typical virtual user life cycle looks like this — it picks up the scripted tasks and performs them, once it finishes all of them it will start the loop again. And it keeps it going until the test is terminated.</code></p>
<p>这个和 <a target="_blank" rel="noopener" href="https://docs.locust.io/en/stable/quickstart.html#locust-s-web-interface">Locust 文档</a> 中描述的行为是一致的:  <code>This user will make HTTP requests to /hello, and then /world, again and again. </code></p>
<p><strong>Latency</strong>:<br>从请求被创建出来发送到接收的endpint开始到收到response的这个段时间。</p>
<h2 id="1-性能测试类型"><a href="#1-性能测试类型" class="headerlink" title="1. 性能测试类型"></a>1. 性能测试类型</h2><p>这里列出的类型分类是从稍微具体一点的关注点来分类的。我们做性能测试就是希望在下面几个方面得到系统当前的处理能力，以及它的breaking points。</p>
<ul>
<li><p>负载测试 Load Test</p>
</li>
<li><p>压力测试 Stress Test</p>
</li>
<li><p>耐久/疲劳测试 Endurance Test</p>
</li>
<li><p>尖峰测试 Spike Test</p>
</li>
<li><p>容量 Volume Test</p>
</li>
<li><p>伸缩测试 Scaliability Test</p>
</li>
</ul>
<p><em>Load testing</em> – checks the application’s ability to perform under anticipated user loads. The objective is to identify performance bottlenecks before the software application goes live.  </p>
<p><em>Stress testing</em> – involves testing an application under extreme workloads to see how it handles high traffic or data processing. The objective is to identify the breaking point of an application.  </p>
<p><em>Endurance testing</em> – is done to make sure the software can handle the expected load over a long period of time.  </p>
<p><em>Spike testing</em> – tests the software’s reaction to sudden large spikes in the load generated by users.  </p>
<p><em>Volume testing</em> – Under Volume Testing large no. of. Data is populated in a database and the overall software system’s behavior is monitored. The objective is to check software application’s performance under varying database volumes.  </p>
<p><em>Scalability testing</em> – The objective of scalability testing is to determine the software application’s effectiveness in “scaling up” to support an increase in user load. It helps plan capacity addition to your software system.</p>
<h2 id="2-性能测试的三个方面"><a href="#2-性能测试的三个方面" class="headerlink" title="2. 性能测试的三个方面"></a>2. 性能测试的三个方面</h2><p>上面列出的几个测试关注点，都可以放到这三点：速度、伸缩性、稳定性。<br>速度: 负载测试, 压力测试<br>伸缩: 压力测试, Spike Test, Volume Test, Scaliability Test<br>稳定性: Endurance testing</p>
<h3 id="1-有多快？——-速度"><a href="#1-有多快？——-速度" class="headerlink" title="1. 有多快？—— 速度"></a>1. 有多快？—— 速度</h3><p>常用指标：</p>
<ul>
<li>加载时长 Load time</li>
<li>响应时长 Response time</li>
<li>RPS</li>
<li>每秒网络字节数 Network bytes total per second</li>
<li>网络输出队列长度 Network output queue length</li>
<li>…</li>
</ul>
<p>只看平均值是没有太多意义的，要看百分比分布。</p>
<h3 id="2-还能有多快？-——-伸缩性"><a href="#2-还能有多快？-——-伸缩性" class="headerlink" title="2. 还能有多快？ —— 伸缩性"></a>2. 还能有多快？ —— 伸缩性</h3><p>这里的scalability是说在外部请求不断增加的情况下，系统的资源分配是否能支持这些增加的负载。同样我们也期望当外部负载变小时，系统占用的资源也能够释放出来。<br>这里的memeory footprint、CPU usage、bandwidth usage都是系统垂直伸缩的指标。<br>如果系统支持水平伸缩，那么就要看系统是否能够在输入负载增加的情况下，系统是否能够通过水平扩展节点来保持期望的处理速度。</p>
<p>常用指标：</p>
<ul>
<li>内存</li>
<li>带宽</li>
<li>CPU</li>
<li>并发用户数</li>
<li>系统处理节点</li>
<li>… …</li>
</ul>
<h3 id="3-可以持续多久？——-稳定性"><a href="#3-可以持续多久？——-稳定性" class="headerlink" title="3. 可以持续多久？—— 稳定性"></a>3. 可以持续多久？—— 稳定性</h3><p>持续的给系统一定的输入负载，看看系统是否能够正常处理请求。一般来说，通过这种持续性测试可以发现系统是否能够对使用后的资源进行了释放，比如内存泄露的情况。<br>如果使用Gatling，对应如下语句进行stability的测试。</p>
<pre><code>jumpToRps(20),
holdFor(Duration.ofSeconds(30)),
</code></pre>
<p>常用指标：</p>
<ul>
<li>Page faults </li>
<li>Committed memory</li>
<li>Maximum active sessions</li>
<li>Thread counts</li>
<li>Transactions passed or failed</li>
<li>Error rate</li>
</ul>
<h2 id="3-性能测试步骤"><a href="#3-性能测试步骤" class="headerlink" title="3. 性能测试步骤"></a>3. 性能测试步骤</h2><h3 id="1-Identify-your-testing-environment"><a href="#1-Identify-your-testing-environment" class="headerlink" title="1. Identify your testing environment"></a>1. Identify your testing environment</h3><p>软硬件环境、网络配置、测试工具。</p>
<h3 id="2-Identify-the-performance-acceptance-criteria"><a href="#2-Identify-the-performance-acceptance-criteria" class="headerlink" title="2. Identify the performance acceptance criteria"></a>2. Identify the performance acceptance criteria</h3><p>针对 吞吐量、响应时间、资源占用等，设定被测程序可接受的性能指标。比如：</p>
<ul>
<li>1000个用户同时访问网站时，响应时间不超过4s。</li>
<li>应用崩溃前可处理器的最大并发用户数。</li>
<li>在峰值负载的情况下，CPU、内存的使用情况</li>
<li>测试应用在低、一般、大、超大负载情况下应用的响应时间、吞吐量。</li>
</ul>
<h3 id="3-规划设计性能测试方案"><a href="#3-规划设计性能测试方案" class="headerlink" title="3. 规划设计性能测试方案"></a>3. 规划设计性能测试方案</h3><p>对于测试指标因为人力、需求的不同，也没必要面面俱到， 根据需要和场景重点设计需要的测试类型：比如 Load Test, Endurance Test等</p>
<h3 id="4-配置测试环境"><a href="#4-配置测试环境" class="headerlink" title="4. 配置测试环境"></a>4. 配置测试环境</h3><h3 id="5-实现并运行测试"><a href="#5-实现并运行测试" class="headerlink" title="5. 实现并运行测试"></a>5. 实现并运行测试</h3><h3 id="6-Analyze，Tune，Retest"><a href="#6-Analyze，Tune，Retest" class="headerlink" title="6. Analyze，Tune，Retest"></a>6. Analyze，Tune，Retest</h3><br/>

<hr>
<p>Reference:<br>[1]: <a target="_blank" rel="noopener" href="https://www.guru99.com/performance-testing.html">https://www.guru99.com/performance-testing.html</a><br>[2]: <a target="_blank" rel="noopener" href="https://www.onpathtesting.com/blog/performance-testing-metrics">https://www.onpathtesting.com/blog/performance-testing-metrics</a><br>[3]: <a target="_blank" rel="noopener" href="https://nbomber.com/docs/loadtesting-basics/">https://nbomber.com/docs/loadtesting-basics/</a><br>[4]: <a target="_blank" rel="noopener" href="https://medium.com/@novyludek/virtual-users-vs-rps-77627b384127">https://medium.com/@novyludek/virtual-users-vs-rps-77627b384127</a>  </p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-mongo/setupMongoForLocalDevEnv" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.275Z"><a href="/2025/01/25/mongo/setupMongoForLocalDevEnv/">2025-01-25</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/25/mongo/setupMongoForLocalDevEnv/">为本地Mac开发环境设置mongo服务</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="1）安装"><a href="#1）安装" class="headerlink" title="1）安装"></a>1）安装</h3><p>Mac上通过brew安装Mongo 参考：<a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/#std-label-install">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/#std-label-install</a></p>
<pre><code>brew tap mongodb/brew
brew install mongodb-community@5.0

brew services start/restart/stop mongodb-community@5.0
brew services list
</code></pre>
<p>通过brew安装后，MongoDB的配置文件在 /usr/local/etc/mongod.conf，可根据实际情况设置端口、认证、复制集等。</p>
<pre><code>net:
  port: 27117
  bindIp: 0.0.0.0
replication:
  replSetName: rs0
</code></pre>
<h3 id="2-设置密码登录"><a href="#2-设置密码登录" class="headerlink" title="2) 设置密码登录"></a>2) 设置密码登录</h3><p>创建超级用户、普通用户：<br>    mongosh</p>
<pre><code>use admin
db.createUser(
  &#123;
    user: &quot;root&quot;,
    pwd: &quot;password&quot;, 
    roles: [
      &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125;
    ]
  &#125;
)

// 创建用户test，对数据库testDB1、testDB2读写的权限，其authorizaiton的DB是testDB1。
use testDB1
db.createUser(
  &#123;
    user: &quot;testuser&quot;,
    pwd: &quot;123&quot;, 
    roles: [
      &#123; role: &quot;readWrite&quot;, db: &quot;testDB&quot; &#125;,
      &#123; role: &quot;readWrite&quot;, db: &quot;testDB2&quot; &#125;
    ]
  &#125;
)
</code></pre>
<p>给 root 用户设置clusterManager角色，这样才可以使用rs.initiate()、rs.conf()与复制集相关的命令。</p>
<pre><code>use admin
db.grantRolesToUser(
  &quot;root&quot;,
  [ &quot;clusterManager&quot; ]
)
</code></pre>
<p>这个dbAdminAnyDatabase 角色似乎很‘方便’。</p>
<pre><code>db.grantRolesToUser(&quot;yourUser&quot;, [&#123;&quot;role&quot;: &quot;dbAdminAnyDatabase&quot;, &quot;db&quot;: &quot;admin&quot;&#125;])
</code></pre>
<h3 id="3）设置复制集。"><a href="#3）设置复制集。" class="headerlink" title="3）设置复制集。"></a>3）设置复制集。</h3><p>复制集需要安全通行。首先生成mongodb私钥<br>Reference：<a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/tutorial/enforce-keyfile-access-control-in-existing-replica-set/">https://docs.mongodb.com/manual/tutorial/enforce-keyfile-access-control-in-existing-replica-set/</a></p>
<pre><code>openssl rand -base64 756 &gt; KEY_PATH/mongo_server.key
</code></pre>
<p>修改配置设置keyFile：</p>
<pre><code>security:
  keyFile: KEY_PATH/mongo_server.key
  authorization: enabled
</code></pre>
<p>强制设置本地节点复制集名称。</p>
<pre><code>replication:
  replSetName: rs0
</code></pre>
<p>重启mongo</p>
<pre><code>brew services restart mongodb-community
</code></pre>
<p>进入mongosh，执行rs.initiate()初始化数据集：</p>
<pre><code>rs.initiate()
rs.conf()
</code></pre>
<h3 id="4）强制设置master复制集。"><a href="#4）强制设置master复制集。" class="headerlink" title="4）强制设置master复制集。"></a>4）强制设置master复制集。</h3><p>遇到的问题及解决：开始在端口为27017的情况下按照 <a target="_blank" rel="noopener" href="https://mongoing.com/docs/tutorial/convert-standalone-to-replica-set.html">https://mongoing.com/docs/tutorial/convert-standalone-to-replica-set.html</a> 介绍的方式把单节点的mongo服务转变为单复制集的方式运行。</p>
<p>接着又更改了mongo服务的端口为27117，这样之前的复制集节点就不对了。<br>先加上当前27117端口的mongo服务作为一个复制集。</p>
<pre><code>rs.add(&quot;127.0.0.1:27117&quot;)
</code></pre>
<p>查看复制集配置</p>
<pre><code>rs0 [direct: primary] test&gt; cfg = rs.conf()
&#123;
  _id: &#39;rs0&#39;,
  version: 4,
  term: 30,
  members: [
    &#123;
      _id: 0,
      host: &#39;127.0.0.1:27017&#39;,
      arbiterOnly: false,
      buildIndexes: true,
      hidden: false,
      priority: 1,
      tags: &#123;&#125;,
      secondaryDelaySecs: Long(&quot;0&quot;),
      votes: 1
    &#125;,
    &#123;
      _id: 1,
      host: &#39;127.0.0.1:27117&#39;,
      arbiterOnly: false,
      buildIndexes: true,
      hidden: false,
      priority: 1,
      tags: &#123;&#125;,
      secondaryDelaySecs: Long(&quot;0&quot;),
      votes: 1
    &#125;
  ],
  protocolVersion: Long(&quot;1&quot;),
  writeConcernMajorityJournalDefault: true,
  settings: &#123;
    chainingAllowed: true,
    heartbeatIntervalMillis: 2000,
    heartbeatTimeoutSecs: 10,
    electionTimeoutMillis: 10000,
    catchUpTimeoutMillis: -1,
    catchUpTakeoverDelayMillis: 30000,
    getLastErrorModes: &#123;&#125;,
    getLastErrorDefaults: &#123; w: 1, wtimeout: 0 &#125;,
    replicaSetId: ObjectId(&quot;616d08c744db747bb7e580b8&quot;)
  &#125;
&#125;
</code></pre>
<p>删除第一节点，</p>
<pre><code>cfg.members.splice(0,1)
</code></pre>
<p>强制执行重新配置</p>
<pre><code>rs.reconfig(cfg, &#123;force : true&#125;)
</code></pre>
<h3 id="5）设置复制集。"><a href="#5）设置复制集。" class="headerlink" title="5）设置复制集。"></a>5）设置复制集。</h3><p>通过用户名密码登录</p>
<pre><code>mongosh --port 27117 -u testuser -p 123 --authenticationDatabase  test 
</code></pre>
<h3 id="6）Mac环境设置-maxfile-limit"><a href="#6）Mac环境设置-maxfile-limit" class="headerlink" title="6）Mac环境设置 maxfile limit"></a>6）Mac环境设置 maxfile limit</h3><p>查看当前设置：</p>
<pre><code>launchctl limit maxfiles
</code></pre>
<p>如果soft limit是256，则执行下面命令扩大。否则mongo server可用的线程将受限。</p>
<pre><code>sudo launchctl limit maxfiles 65536 200000
</code></pre>
<p>因为机器重启后以上更改会失效，所以还需要添加以上命令到开机脚本中。因为使用到了sudo，可使用 visudo 修改设置免密码。</p>
<pre><code>%admin          ALL = (ALL) NOPASSWD: ALL
</code></pre>
<h3 id="7）mongo-conf"><a href="#7）mongo-conf" class="headerlink" title="7）mongo.conf"></a>7）mongo.conf</h3><p>mongo.conf 大致如此：<br>如果需要设置MongoDB无需认证登录的话，需要authrozation、keyFile这两个字段同时注释掉。·</p>
<pre><code>systemLog:
  destination: file
  path: /usr/local/var/log/mongodb/mongo.log
  logAppend: true
storage:
  dbPath: /usr/local/var/mongodb
net:
  bindIp: 127.0.0.1
  port: 27017
  maxIncomingConnections: 4096
security:
  keyFile: /YOURPATH/mongo_server.key
  authorization: enabled
replication:
  replSetName: rs0
</code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-mongo/mongodb-script-collection-fields-size-quantile-analysis" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.275Z"><a href="/2025/01/25/mongo/mongodb-script-collection-fields-size-quantile-analysis/">2025-01-25</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/25/mongo/mongodb-script-collection-fields-size-quantile-analysis/">MongoDB脚本：集合中字段数据大小的分位数统计</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="查询某个collection-的文档大小分布"><a href="#查询某个collection-的文档大小分布" class="headerlink" title="查询某个collection 的文档大小分布"></a>查询某个collection 的文档大小分布</h3><p>日常开发中，有时需要了解数据分布的一些特点，比如这个colllection里documents的平均大小、全部大小等，来调整程序的设计。<br>对于系统中已经存在大量数据的情况，这种提前分析数据分布模式的工作套路（最佳实践）可以帮助我们有的放矢的进行设计，避免不必要的过度设计或者进行更细致的设计。</p>
<p>如果想获得某个collection相关的各种存储统计信息，可以使用 **<a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v6.0/reference/method/db.collection.stats/">stats</a>、<a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v6.0/reference/operator/aggregation/collStats/">collStats</a>**。</p>
<p>如果想获取总计、平均等简单的统计信息，可以参考这里：<a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/core/aggregation-pipeline/#std-label-aggregation-pipeline%E3%80%82">https://www.mongodb.com/docs/manual/core/aggregation-pipeline/#std-label-aggregation-pipeline。</a></p>
<p>下面的命令可以显示 COLLECTION 中满足条件status=’active’，字段FIELD_A， FIELD_B的数据大小的Quantile analysis。<br>如果去掉第三行，就是对COLLECTION中所有文档数据的大小分布的统计。</p>
<pre><code>//最大的Top10和百分比分布。
db.COLLECTION.aggregate([
  &#123; $match: &#123; &quot;status&quot;: &#39;active&#39; &#125; &#125;,
  &#123; $project: &#123; _id: 1, FIELD_A: 1, FIELD_B: 1&#125; &#125;,
  &#123; $project: &#123; documentSize: &#123; $sum: &#123; $bsonSize: &quot;$$ROOT&quot; &#125; &#125; &#125; &#125;,
  &#123; $sort: &#123; documentSize: 1 &#125; &#125;,
  &#123; $group: &#123; &#39;_id&#39;: null, &#39;value&#39;: &#123; &#39;$push&#39;: &#39;$documentSize&#39; &#125; &#125; &#125;,
  &#123; $project: &#123; _id: 0, 
      &quot;Top1&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-1, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top2&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-2, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top3&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-4, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top4&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-5, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top5&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-6, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top6&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-7, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top7&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-7, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top8&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-8, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top9&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-9, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;Top10&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $add: [-10, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;99-9%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.999, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;99%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.99, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;95%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.95, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;90%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.90, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;50%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.50, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
      &quot;25%&quot;: &#123; $arrayElemAt: [&quot;$value&quot;, &#123; $floor: &#123; $multiply: [0.25, &#123; $size: &quot;$value&quot; &#125;] &#125; &#125; ] &#125;,
    &#125; &#125;,
  ]);
  
</code></pre>
<p>对MongoDB 4.2以上版本，可以使用上述aggrigation 语法进行统计。对4.2及其以下版本，需要使用forEach语句迭代进行计算。<br>对于不支持Object.bsonsize的Mongo shell可以使用 BSON.calculateObjectSize 进行替代。</p>
<pre><code>// const BSON = require(&quot;bson&quot;);
var fieldsSize = []
var totalSize = 0
db.COLLECTION.find(&#123; &quot;status&quot;: &#39;A&#39; &#125;, &#123; FIELD_A: 1, FIELD_B: 1&#125;).forEach(function(doc)
&#123;
  var size = Object.bsonsize(doc)
//   var size = BSON.calculateObjectSize(doc)
  totalSize += size
  fieldsSize.push(size)
&#125;);
var sortedData = fieldsSize.sort(function(a, b)&#123;return a-b&#125;);
var statistic = &#123;
    &quot;Note&quot;: &quot;The Collection Fields(FIELD_A, FIELD_B) Size Statistic Reuslt&quot;,    
    &quot;numbOfDocs&quot;: sortedData.length,
    &quot;totalSize&quot;: (totalSize / 1024) + &quot;KB    &quot; +  (totalSize / (1024 * 1024)) + &quot; MB&quot;,
    &quot;AVG:&quot;: Math.round(totalSize / sortedData.length),
    &quot;MIN&quot;: sortedData[0],
    &quot;TOP1&quot;: sortedData[sortedData.length - 1],
    &quot;TOP2&quot;: sortedData[sortedData.length - 2],
    &quot;TOP3&quot;: sortedData[sortedData.length - 3],
    &quot;TOP4&quot;: sortedData[sortedData.length - 4],
    &quot;TOP5&quot;: sortedData[sortedData.length - 5],
    &quot;TOP6&quot;: sortedData[sortedData.length - 6],
    &quot;TOP7&quot;: sortedData[sortedData.length - 7],
    &quot;TOP8&quot;: sortedData[sortedData.length - 8],
    &quot;TOP9&quot;: sortedData[sortedData.length - 9],
    &quot;TOP10&quot;: sortedData[sortedData.length - 10],
    &quot;99.9%&quot;: sortedData[Math.floor(sortedData.length * 0.999)],
    &quot;99%&quot;: sortedData[Math.floor(sortedData.length * 0.99)],
    &quot;95%&quot;: sortedData[Math.floor(sortedData.length * 0.95)],
    &quot;90%&quot;: sortedData[Math.floor(sortedData.length * 0.90)],
    &quot;75%&quot;: sortedData[Math.floor(sortedData.length * 0.75)],
    &quot;50%&quot;: sortedData[Math.floor(sortedData.length * 0.5)],
    &quot;25%&quot;: sortedData[Math.floor(sortedData.length * 0.25)],
    &quot;10%&quot;: sortedData[Math.floor(sortedData.length * 0.10)]
&#125;;

print(statistic)
</code></pre>
<br/>
------

<p>_References:<br>[1]: <a target="_blank" rel="noopener" href="https://database.guide/2-ways-to-get-a-documents-size-in-mongodb/">https://database.guide/2-ways-to-get-a-documents-size-in-mongodb/</a><br>[2]: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22008822/how-to-get-the-size-of-single-document-in-mongodb">https://stackoverflow.com/questions/22008822/how-to-get-the-size-of-single-document-in-mongodb</a><br>[3]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v4.2/reference/command/collStats/">https://www.mongodb.com/docs/v4.2/reference/command/collStats/</a><br>[4]: <a target="_blank" rel="noopener" href="https://database.guide/mongodb-binarysize/">https://database.guide/mongodb-binarysize/</a><br>[5]: <a target="_blank" rel="noopener" href="https://database.guide/mongodb-object-bsonsize/">https://database.guide/mongodb-object-bsonsize/</a><br>[6]: <a target="_blank" rel="noopener" href="https://flowygo.com/en/blog/mongodb-compass-extract-statistics-using-aggregation-pipeline/">https://flowygo.com/en/blog/mongodb-compass-extract-statistics-using-aggregation-pipeline/</a><br>[7]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/aggregation/">https://www.mongodb.com/docs/manual/aggregation/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-mongo/MongoDB-User-Authentication" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.275Z"><a href="/2025/01/25/mongo/MongoDB-User-Authentication/">2025-01-25</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/25/mongo/MongoDB-User-Authentication/">MongoDB的用户管理</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>如果在配置文件中eanble了 authorization，那么用这样的配置启动MongoDB后。如果不是root用户去创建用户会遇到一些权限问题。</p>
<pre><code>security:
  authorization: enabled
</code></pre>
<p>/usr/local/opt/mongodb-community/bin/mongod –config /usr/local/etc/mongod.conf</p>
<p>如果你忘记的root用户或者其它管理员用户的密码，那么可以先以无权限控制的方式启动MongoDB：</p>
<pre><code>mongod --port 27017 --dbpath /usr/local/var/mongodb
</code></pre>
<p>再连接到MongoDB：</p>
<pre><code>mongo --port 27017
</code></pre>
<p>根据需要可以更改用户密码或者创建新用户：</p>
<pre><code>db.changeUserPassword(&quot;root&quot;, passwordPrompt())
db.changeUserPassword(&quot;root&quot;, &quot;password&quot;)

db.createUser(&#123;
    &quot;user&quot;: &quot;dahui&quot;,
    &quot;pwd&quot;: &quot;password&quot;,
    &quot;roles&quot;:
    [
        &#123;
            &quot;role&quot;: &quot;userAdminAnyDatabase&quot;,
            &quot;db&quot;: &quot;admin&quot;
        &#125;,
        &quot;readWriteAnyDatabase&quot;
    ]
&#125;);
</code></pre>
<p>添加完这种带有 userAdminAnyDatabase 角色的用户后，关闭MongoDB server：</p>
<pre><code>db.adminCommand( &#123; shutdown: 1 &#125; )
</code></pre>
<p>再以有权限控制的方式重新启动MongoDB Server。（/usr/local/etc/mongod.conf 中设置了 authorization: enabled）</p>
<pre><code>mongod --config /usr/local/etc/mongod.conf
或
mongod --auth --port 27017 --dbpath /var/lib/mongodb
</code></pre>
<p>这样使用拥有 userAdminAnyDatabase 角色的用户登录后，就可以通过使用use DB_NAME 的方式给不同的DB添加用户了。</p>
<pre><code>mongosh --port 27017 -u admin -p password --authenticationDatabase admin

mongosh &quot;mongodb://admin:password@127.0.0.1:27017/center0?authSource=admin&quot;
</code></pre>
<br/>

<hr>
<p><em>Reference:</em><br>[1]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/v5.0/tutorial/enable-authentication/">https://www.mongodb.com/docs/v5.0/tutorial/enable-authentication/</a><br>[2]: <a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/reference/method/js-user-management/">https://www.mongodb.com/docs/manual/reference/method/js-user-management/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-network/tcp_close-wait_time-wait" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.275Z"><a href="/2025/01/25/network/tcp_close-wait_time-wait/">2025-01-25</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/25/network/tcp_close-wait_time-wait/">关于TCP的好文章</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h4 id="关于挥手中的close-wait-time-wait。"><a href="#关于挥手中的close-wait-time-wait。" class="headerlink" title="关于挥手中的close-wait, time-wait。"></a>关于挥手中的close-wait, time-wait。</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&mid=402163560&idx=1&sn=5269044286ce1d142cca1b5fed3efab1&3rd=MzA3MDU4NTYzMw==&scene=6#rd">又见CLOSE_WAIT</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903734300901390">线上大量CLOSE_WAIT的原因深入分析</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/9988354.html">TCP连接的TIME_WAIT和CLOSE_WAIT 状态解说</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Jt2ss3SsE_iGJp5oW8QDSw">高性能网络 | 你所不知道的TIME_WAIT和CLOSE_WAIT</a></p>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-notes/cas/Apereo-CAS-Management-UI" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.275Z"><a href="/2025/01/25/notes/cas/Apereo-CAS-Management-UI/">2025-01-25</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/25/notes/cas/Apereo-CAS-Management-UI/">Apereo CAS 之 管理界面</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>类似cas-server，先下载cas-management-overlay代码，这里使用6.5分支。</p>
<pre><code>$ git clone https://github.com/apereo/cas-management-overlay cas-management   
$ cd cas-management   
$ git checkout -b 6.5 origin/6.5
</code></pre>
<p>cas-management应用本身也需要用户认证之后才能使用。这里使用它自己要管理的cas-server作为认证源。这时，cas-manager本身就是cas-server的一个client或者说service了。<br>因此需要首先 __把management配置为cas-server的一个client/service__。</p>
<p>Apereo支持不同的存储service注册的方式：json文件、JPA、Redis …，这里使用json文件的方式把cas-management注册为cas-server的service，即让cas-manager使用cas-server来认证用户。</p>
<h3 id="1）在cas-server的build-gradle中添加依赖。"><a href="#1）在cas-server的build-gradle中添加依赖。" class="headerlink" title="1）在cas-server的build.gradle中添加依赖。"></a>1）在cas-server的build.gradle中添加依赖。</h3><p>可参考官方文档：<a target="_blank" rel="noopener" href="https://apereo.github.io/cas/6.5.x/services/Service-Management.html#storage">https://apereo.github.io/cas/6.5.x/services/Service-Management.html#storage</a></p>
<pre><code>implementation &quot;org.apereo.cas:cas-server-support-json-service-registry:$&#123;project.&#39;cas.version&#39;&#125;&quot;
</code></pre>
<h3 id="2）告诉cas-server-在哪里可以找到定义client-service的json文件"><a href="#2）告诉cas-server-在哪里可以找到定义client-service的json文件" class="headerlink" title="2）告诉cas-server 在哪里可以找到定义client/service的json文件"></a>2）告诉cas-server 在哪里可以找到定义client/service的json文件</h3><p>在文件 etc/cas/config/cas.properties 中加入如下配置：<br><code>cas.service-registry.json.location=classpath:/services</code></p>
<p>在cas-server 项目的 src/resources 目录下创建一个名为casManagement-2000.json的文体。文件名的格式是 clientName + clientId.json，具体请阅读官方文档。</p>
<pre><code>&#123;
  &quot;@class&quot; : &quot;org.apereo.cas.services.RegexRegisteredService&quot;,
  &quot;serviceId&quot; : &quot;^(https|imaps)://.*&quot;,
  &quot;name&quot; : &quot;casManagement&quot;,
  &quot;id&quot; : 2000,
  &quot;logoutType&quot; : &quot;BACK_CHANNEL&quot;,
  &quot;logoutUrl&quot; : &quot;https://localhost:8444/cas-management/logout&quot;
&#125;
</code></pre>
<h3 id="3）配置cas-management"><a href="#3）配置cas-management" class="headerlink" title="3）配置cas-management"></a>3）配置cas-management</h3><p>上面两步是配置cas-server以把cas-manager作为它的client。现在，配置cas-management。<br>编辑 cas-management 项目里的 etc/case/config/management.properties 文件，内容如下。</p>
<pre><code>cas.server.name=https://localhost:8443
cas.server.prefix=$&#123;cas.server.name&#125;/cas

server.port=8444
mgmt.server-name=https://localhost:8444
mgmt.admin-roles[0]=ROLE_ADMIN
mgmt.user-properties-file=file:/etc/cas/config/users.json

logging.config=file:/etc/cas/config/log4j2-management.xml

server.ssl.key-store=file:/etc/cas/thekeystore
server.ssl.key-store-password=changeit

# Let the cas-management to know where to find/save the registed services
cas.service-registry.json.location=file:YOUR_PATH_TO_DIR_CONTAINS_JSONFILES/services
</code></pre>
<p>需要注意的是要保证cas.server 和 mgmt server的端口不要冲突，一个是8443，一个是8444。<br>这里方便起见，cas-management和 cas-server共享了同一个keystore。</p>
<p>配置项<code>cas.service-registry.json.location</code>告诉cas-management到哪里去读写(管理)定义client/service的json文件。这个目录<br>是和cas-server的 <code>cas.service-registry.json.location=classpath:/services</code> 是一致的。</p>
<h3 id="4）-同时运行cas-server，cas-management后，访问-https-localhost-8444-cas-management"><a href="#4）-同时运行cas-server，cas-management后，访问-https-localhost-8444-cas-management" class="headerlink" title="4） 同时运行cas-server，cas-management后，访问 https://localhost:8444/cas-management/"></a>4） 同时运行cas-server，cas-management后，访问 <a target="_blank" rel="noopener" href="https://localhost:8444/cas-management/">https://localhost:8444/cas-management/</a></h3><p><img src="/2025/01/25/notes/cas/Apereo-CAS-Management-UI/apereo_cas_mgmt_ui.jpg" alt="CAS-Management-UI"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-micro_service/glimpse-of-saga" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.270Z"><a href="/2025/01/25/micro_service/glimpse-of-saga/">2025-01-25</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/25/micro_service/glimpse-of-saga/">glimpse of saga</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>项目中遇到多个微服务调用需要考虑和处理某个环节失败时的处理。虽然这里不需要很强的事务概念，但是需要对失败的动作进行重试等操作。这里的重试本质上就是rollback的另一种形式，在saga里算是“forward recovery”。<br>借机又翻看了一下相关的文章，贴到了文末。</p>
<h3 id="Saga-vs-TCC"><a href="#Saga-vs-TCC" class="headerlink" title="Saga vs TCC"></a>Saga vs TCC</h3><ol>
<li>Saga相比TCC的缺点是缺少预留动作，所以某些情况补偿的实现比较麻烦甚至无法撤销只能补救。不过没有预留动作也意味着不必担心资源释放的问题。</li>
<li>TCC最少通信次数为2n，Saga为n（n=sub-transaction的数量）。</li>
<li>第三方服务没需要提供有Try接口。<br>总体感觉下来SAGA更适合微服务的多数场景。</li>
</ol>
<h3 id="Simple-Saga"><a href="#Simple-Saga" class="headerlink" title="Simple Saga"></a>Simple Saga</h3><p>解决这类问题当然可以直接引入一些已存在的saga框架，不过这里存在学习、部署等成本。如果只是小范围的解决问题，或许可以使用下面的形式。<br><img src="/2025/01/25/micro_service/glimpse-of-saga/poc.jpg" alt="示意图"><br>上面示意图针对的场景是：服务的执行都需要较长时间、并且是异步调用。<br>如果各个服务执行时间都不长，一个调用链下来小于几百毫秒，那么直接使用reactive style的编码也应该可以。<br>因为各服务执行时间较长，所以不能使用同步调用。这里耗时指的是对于有UI的程序至少影响到到UI前的用户，如果是后台应用那么至少阻塞的时长影响到系统的资源可用性。<br>即使服务执行时间短，同步调用也会使调用链的availability降低，所以微服务的场景下使用异步调用有天然的好处。  </p>
<p>从这个示意图其实可以看作是Chris演讲中提到的最最原始的模式。可以把callback看作是saga事务参与方发送消息到message broker。而调用链的第一个节点就充当了saga的协调者。<br>各个微服务的updateStatus端点就是message的listner，只不过这里直接通过callback实现而没有利用消息队列。<br>最开始的endpoint负责生成一个transactionId并依次传递给每个下游服务，每个下游服务通过callback把自己的状态更新给上游。</p>
<ol>
<li><p>getStatus() 端点提供给UI获取当前状态。<br><img src="/2025/01/25/micro_service/glimpse-of-saga/ui_option.png" alt="UI上的状态显示"></p>
</li>
<li><p>transCheckAndAmend(trans_n) 每个服务暴露的业务方法都需要提供一个补偿方法。<br><img src="/2025/01/25/micro_service/glimpse-of-saga/tc.png" alt="Compensating transactions"></p>
</li>
<li><p>服务的入口方法其实充当了协调者, 更像orchestration的，而不是choreography的。</p>
</li>
<li><p>Timer 是个后台定时器不停的检查服务状态，如果状态不成功就调用compensating endpoint.</p>
</li>
</ol>
<p><em>Reference:</em><br>[1]: Saga的经典论文 <a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf</a><br>[2]: 《Microservice Pattern》”Chapter4, Managing transactions with sagas”<br>[3]: Chris Richardson 在2017年的演讲：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=YPbGW3Fnmbc">https://www.youtube.com/watch?v=YPbGW3Fnmbc</a>   </p>
<p>一些中文网文：<br>[3] 分布式事务：Saga模式 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4b662407c66">https://www.jianshu.com/p/e4b662407c66</a><br>[4] 七种分布式事务的解决方案 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1806989">https://cloud.tencent.com/developer/article/1806989</a><br>[5] 分布式事务六种解决方案 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/183753774">https://zhuanlan.zhihu.com/p/183753774</a>   </p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-micro_service/Use-the-AWS-EFS-as-the-PV-s-backend-storate" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-01-25T12:22:54.269Z"><a href="/2025/01/25/micro_service/Use-the-AWS-EFS-as-the-PV-s-backend-storate/">2025-01-25</a></time>
      
      
  
    <h1 class="title"><a href="/2025/01/25/micro_service/Use-the-AWS-EFS-as-the-PV-s-backend-storate/">使用 AWS EFS 作为EKS里PV的后端存储 (1)</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="如何在EKS手工创建AWS-EFS资源"><a href="#如何在EKS手工创建AWS-EFS资源" class="headerlink" title="如何在EKS手工创建AWS EFS资源"></a>如何在EKS手工创建AWS EFS资源</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>AWS的EC2存储，有四种选择：</p>
<ul>
<li>Amazon Elastic Block Store</li>
<li>Amazon EC2 instance store</li>
<li>Use Amazon EFS with Amazon EC2</li>
<li>Use Amazon S3 with Amazon EC2</li>
</ul>
<p>下面的这张概念图很好的描述各种存储的位置层次。<br><img src="/2025/01/25/micro_service/Use-the-AWS-EFS-as-the-PV-s-backend-storate/ec2_storage_options.jpg" alt="EC2 Storage Options"><br>在EKS的node如果是基于EC2的，那么PV就可以利用以上除去S3之外的其余三种作为底层存储。<br>参考：<a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/eks/latest/userguide/storage.html">https://docs.aws.amazon.com/eks/latest/userguide/storage.html</a></p>
<p>关于EC2可以使用的存储的特性、使用场景，推荐阅读官方文档：<a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Storage.html%E3%80%82">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Storage.html。</a>   </p>
<h2 id="使用-aws-cli-创建一个EFS资源"><a href="#使用-aws-cli-创建一个EFS资源" class="headerlink" title="使用 aws cli 创建一个EFS资源"></a>使用 aws cli 创建一个EFS资源</h2><p>可以在AWS Console中创建EFS <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AmazonEFS.html%E3%80%82">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AmazonEFS.html。</a><br>也可以通过使用aws cli在命令行创建，<a target="_blank" rel="noopener" href="https://www.eksworkshop.com/beginner/190_efs/launching-efs/%E3%80%82">https://www.eksworkshop.com/beginner/190_efs/launching-efs/。</a><br>下面是根据上文得到的，通过aws cli创建EFS的脚本。<br>假设，你的aws profile是myAwsProfile、eks所在region是us-west-2、eks集群名称是myCluster，而要创建的EFS名称是 my-test-efs<br>为了使用EFS需要创建SecurityGroup来允许对NFS端口2049的使用，这里设置SG名称为 SG_efs_demo。</p>
<h4 id="设置环境变量："><a href="#设置环境变量：" class="headerlink" title="设置环境变量："></a>设置环境变量：</h4><hr>
<pre><code># Set the input env vars
export AWS_PROFILE=myAwsProfile
export AWS_REGION=us-west-2
export CLUSTER_NAME=myCluster
</code></pre>
<hr>
<pre><code># Set the output env vars
export MOUNT_TARGET_GROUP_NAME=perf-test-efs-group
export MOUNT_TARGET_GROUP_DESC=&quot;NFS access to EFS from EKS worker nodes&quot;
export EFS_NAME=my-test-efs
</code></pre>
<h4 id="获取-VPC-ID"><a href="#获取-VPC-ID" class="headerlink" title="获取 VPC ID"></a>获取 VPC ID</h4><hr>
<pre><code># Get eks cluster&#39;s VPC ID.
export VPC_ID=$(aws eks describe-cluster --profile $AWS_PROFILE --region $AWS_REGION --name $CLUSTER_NAME --query &quot;cluster.resourcesVpcConfig.vpcId&quot; --output text)
echo $VPC_ID
</code></pre>
<h4 id="获取-VPC-里的-subnets"><a href="#获取-VPC-里的-subnets" class="headerlink" title="获取 VPC 里的 subnets"></a>获取 VPC 里的 subnets</h4><hr>
<pre><code># Get the subnets&#39;s CIDR in the VPC.
export CIDR_BLOCK=$(aws ec2 describe-vpcs --profile $AWS_PROFILE --region $AWS_REGION --vpc-ids $VPC_ID --query &quot;Vpcs[].CidrBlock&quot; --output text)
echo $CIDR_BLOCK
</code></pre>
<h4 id="创建-Security-Group"><a href="#创建-Security-Group" class="headerlink" title="创建 Security Group"></a>创建 Security Group</h4><hr>
<pre><code># Create SG(allow port 2049 in ingress for all of the CIDR in VPC) for EFS
export MOUNT_TARGET_GROUP_ID=$(aws ec2 create-security-group --profile $AWS_PROFILE --region $AWS_REGION --group-name $MOUNT_TARGET_GROUP_NAME --description &quot;$MOUNT_TARGET_GROUP_DESC&quot; --vpc-id $VPC_ID | jq --raw-output &#39;.GroupId&#39;)
aws ec2 authorize-security-group-ingress --profile $AWS_PROFILE --region $AWS_REGION --group-id $MOUNT_TARGET_GROUP_ID --protocol tcp --port 2049 --cidr $CIDR_BLOCK

# Get back the security-group informaation.
aws ec2 describe-security-groups --filters Name=group-name,Values=$MOUNT_TARGET_GROUP_NAME
</code></pre>
<h4 id="创建-EFS"><a href="#创建-EFS" class="headerlink" title="创建 EFS"></a>创建 EFS</h4><hr>
<pre><code># Create EFS. https://docs.aws.amazon.com/cli/latest/reference/efs/create-file-system.html
# https://docs.aws.amazon.com/efs/latest/ug/creating-using-create-fs.html#creating-using-fs-part1-cli
# If no creation-token is provied, you&#39;d better go to the AWS EFS Console 
# to make sure the EFS is created or not to avoid too many EFS reources are created.
# 使用efs name作为前缀加序号的方式做 creation-token 是个不错的选择，
export FILE_SYSTEM_ID=$(aws efs create-file-system --profile $AWS_PROFILE --region $AWS_REGION \
  --performance-mode generalPurpose --throughput-mode bursting --tags Key=name,Value=$EFS_NAME \
  --backup --encrypted --creation-token &quot;$EFS_NAME&quot;_0 | jq --raw-output &#39;.FileSystemId&#39;)
</code></pre>
<h4 id="找到-VPC-中的-pubilc-subnets"><a href="#找到-VPC-中的-pubilc-subnets" class="headerlink" title="找到 VPC 中的 pubilc subnets"></a>找到 VPC 中的 pubilc subnets</h4><hr>
<pre><code># Find out the public subtnets from the subnets of the eks cluster.

# 得到eks VPC的所有 subnetIds
# export eksSubnetIDs=($(aws eks describe-cluster --profile $AWS_PROFILE --region $AWS_REGION --name $CLUSTER_NAME --query &quot;cluster.resourcesVpcConfig.subnetIds&quot; --output text))

# 找到 Internet GW
export IGW_ID=`aws ec2 describe-internet-gateways \
  --filters Name=attachment.vpc-id,Values=$&#123;VPC_ID&#125; \
  --query &quot;InternetGateways[].InternetGatewayId&quot; \
  | jq -r &#39;.[0]&#39;`

# 找到 public subnets: https://stackoverflow.com/questions/48830793/aws-vpc-identify-private-and-public-subnet 
export PUBLIC_SUBNETS=`aws ec2 describe-route-tables \
  --query  &#39;RouteTables[*].Associations[].SubnetId&#39; \
  --filters &quot;Name=vpc-id,Values=$&#123;VPC_ID&#125;&quot; \
    &quot;Name=route.gateway-id,Values=$&#123;IGW_ID&#125;&quot; \
  | jq . -c`
</code></pre>
<h4 id="把-EFS-mount-到-public-subnets，这样EKS里的worker-nodes就都可以访问这些EFS了。"><a href="#把-EFS-mount-到-public-subnets，这样EKS里的worker-nodes就都可以访问这些EFS了。" class="headerlink" title="把 EFS mount 到 public subnets，这样EKS里的worker nodes就都可以访问这些EFS了。"></a>把 EFS mount 到 public subnets，这样EKS里的worker nodes就都可以访问这些EFS了。</h4><hr>
<pre><code>for subnet in $&#123;PUBLIC_SUBNETS[@]&#125;
do
    echo &quot;creating mount target in &quot; $subnet
    aws efs create-mount-target --profile $AWS_PROFILE --region us-west-2 --file-system-id $FILE_SYSTEM_ID --subnet-id $subnet --security-groups $MOUNT_TARGET_GROUP_ID
done
</code></pre>
<hr>
<h4 id="创建-Access-Points"><a href="#创建-Access-Points" class="headerlink" title="创建 Access Points"></a>创建 Access Points</h4><p>有了EFS之后就可以创建 AccessPoints 供应用程序使用了。关于更详细的Access Points介绍：<a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html">https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html</a></p>
<pre><code>ACCESS_POING_NAME=ap_db2
FILE_SYSTEM_ID=fs-055b5f1fcc7df3e4b
AP_DIR_USER=&#39;&#123;&quot;Uid&quot;: 70, &quot;Gid&quot;: 70, &quot;SecondaryGids&quot;: [70]&#125;&#39;
AP_ROOT_DIR=&#39;/mydataPath,CreationInfo=&#123;OwnerUid=70,OwnerGid=70,Permissions=0755&#125;&#39;

aws efs create-access-point --profile $AWS_PROFILE --region $AWS_REGION  \
--tags Key=name,Value=$ACCESS_POING_NAME \
--client-token &quot;$ACCESS_POING_NAME&quot;_2 \
--file-system-id $FILE_SYSTEM_ID \
--posix-user $AP_DIR_USER \
--root-directory Path=$AP_ROOT_DIR
</code></pre>
<p>注意：</p>
<h5 id="1）Path的格式必须满足下面的正则"><a href="#1）Path的格式必须满足下面的正则" class="headerlink" title="1）Path的格式必须满足下面的正则"></a>1）Path的格式必须满足下面的正则</h5><pre><code>^(\/|(\/(?!\.)+[^$#&lt;&gt;;`|&amp;?&#123;&#125;^*/\n]+)&#123;1,4&#125;)$
</code></pre>
<p>所以path不能以 <code>/</code> 结尾。</p>
<h5 id="2）创建的access-point-可以同名、可以同名同path，唯一标识access-point的是-Access-point-ID"><a href="#2）创建的access-point-可以同名、可以同名同path，唯一标识access-point的是-Access-point-ID" class="headerlink" title="2）创建的access point 可以同名、可以同名同path，唯一标识access point的是 Access point ID"></a>2）创建的access point 可以同名、可以同名同path，唯一标识access point的是 <code>Access point ID</code></h5><h5 id="3-根据id删除一个-access-point"><a href="#3-根据id删除一个-access-point" class="headerlink" title="3) 根据id删除一个 access point"></a>3) 根据id删除一个 access point</h5><p>aws efs delete-access-point –profile $AWS_PROFILE –region $AWS_REGION  –access-point-id fsap-0a8b1b7d9e0c1c9c3</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/3/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="as_sitesearch" value="dhyuan.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/AWS/">AWS</a><small>2</small></li>
  
    <li><a href="/tags/CAS/">CAS</a><small>5</small></li>
  
    <li><a href="/tags/Concurrency/">Concurrency</a><small>6</small></li>
  
    <li><a href="/tags/DevOps/">DevOps</a><small>31</small></li>
  
    <li><a href="/tags/FP/">FP</a><small>2</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
  
    <li><a href="/tags/Ingerss/">Ingerss</a><small>1</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>10</small></li>
  
    <li><a href="/tags/Kubernetes/">Kubernetes</a><small>3</small></li>
  
    <li><a href="/tags/Maven/">Maven</a><small>2</small></li>
  
    <li><a href="/tags/MicroService/">MicroService</a><small>3</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>6</small></li>
  
    <li><a href="/tags/Nginx/">Nginx</a><small>2</small></li>
  
    <li><a href="/tags/Reactive/">Reactive</a><small>8</small></li>
  
    <li><a href="/tags/SAGA/">SAGA</a><small>1</small></li>
  
    <li><a href="/tags/Scala/">Scala</a><small>7</small></li>
  
    <li><a href="/tags/Security/">Security</a><small>12</small></li>
  
    <li><a href="/tags/Spring/">Spring</a><small>14</small></li>
  
    <li><a href="/tags/android/">android</a><small>1</small></li>
  
    <li><a href="/tags/network/">network</a><small>2</small></li>
  
    <li><a href="/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><small>13</small></li>
  
    <li><a href="/tags/%E7%BD%91%E4%B8%8A%E5%A5%BD%E6%96%87/">网上好文</a><small>1</small></li>
  
  </ul>
</div>


  
  <div class="widget widget-archives">
    <h3 class="title">归档</h3>
    <div class="entry">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a><span class="archive-list-count">25</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2025 Dahui
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
