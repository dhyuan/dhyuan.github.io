<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 | 浅流</title>
  <meta name="author" content="Dahui">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="浅流"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">浅流</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-micro_service/glimpse-of-saga" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-05-19T07:55:38.000Z"><a href="/2022/05/19/micro_service/glimpse-of-saga/">2022-05-19</a></time>
      
      
  
    <h1 class="title"><a href="/2022/05/19/micro_service/glimpse-of-saga/">glimpse of saga</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>项目中遇到多个微服务调用需要考虑和处理某个环节失败时的处理。虽然这里不需要很强的事务概念，但是需要对失败的动作进行重试等操作。这里的重试本质上就是 rollback 的另一种形式，在 saga 里算是“forward recovery”。<br>借机又翻看了一下相关的文章，贴到了文末。</p>
<h3 id="Saga-vs-TCC"><a href="#Saga-vs-TCC" class="headerlink" title="Saga vs TCC"></a>Saga vs TCC</h3><ol>
<li>Saga 相比 TCC 的缺点是缺少预留动作，所以某些情况补偿的实现比较麻烦甚至无法撤销只能补救。不过没有预留动作也意味着不必担心资源释放的问题。</li>
<li>TCC 最少通信次数为 2n，Saga 为 n（n=sub-transaction 的数量）。</li>
<li>第三方服务没需要提供有 Try 接口。<br>总体感觉下来 SAGA 更适合微服务的多数场景。</li>
</ol>
<h3 id="Simple-Saga"><a href="#Simple-Saga" class="headerlink" title="Simple Saga"></a>Simple Saga</h3><p>解决这类问题当然可以直接引入一些已存在的 saga 框架，不过这里存在学习、部署等成本。如果只是小范围的解决问题，或许可以使用下面的形式。<br><img src="/2022/05/19/micro_service/glimpse-of-saga/poc.jpg" alt="示意图"><br>上面示意图针对的场景是：服务的执行都需要较长时间、并且是异步调用。<br>如果各个服务执行时间都不长，一个调用链下来小于几百毫秒，那么直接使用 reactive style 的编码也应该可以。<br>因为各服务执行时间较长，所以不能使用同步调用。这里耗时指的是对于有 UI 的程序至少影响到到 UI 前的用户，如果是后台应用那么至少阻塞的时长影响到系统的资源可用性。<br>即使服务执行时间短，同步调用也会使调用链的 availability 降低，所以微服务的场景下使用异步调用有天然的好处。</p>
<p>从这个示意图其实可以看作是 Chris 演讲中提到的最最原始的模式。可以把 callback 看作是 saga 事务参与方发送消息到 message broker。而调用链的第一个节点就充当了 saga 的协调者。<br>各个微服务的 updateStatus 端点就是 message 的 listner，只不过这里直接通过 callback 实现而没有利用消息队列。<br>最开始的 endpoint 负责生成一个 transactionId 并依次传递给每个下游服务，每个下游服务通过 callback 把自己的状态更新给上游。</p>
<ol>
<li><p>getStatus() 端点提供给 UI 获取当前状态。<br><img src="/2022/05/19/micro_service/glimpse-of-saga/ui_option.png" alt="UI上的状态显示"></p>
</li>
<li><p>transCheckAndAmend(trans_n) 每个服务暴露的业务方法都需要提供一个补偿方法。<br><img src="/2022/05/19/micro_service/glimpse-of-saga/tc.png" alt="Compensating transactions"></p>
</li>
<li><p>服务的入口方法其实充当了协调者, 更像 orchestration 的，而不是 choreography 的。</p>
</li>
<li><p>Timer 是个后台定时器不停的检查服务状态，如果状态不成功就调用 compensating endpoint.</p>
</li>
</ol>
<p><em>Reference:</em><br>[1]: Saga 的经典论文 <a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf</a><br>[2]: 《Microservice Pattern》”Chapter4, Managing transactions with sagas”<br>[3]: Chris Richardson 在 2017 年的演讲：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=YPbGW3Fnmbc">https://www.youtube.com/watch?v=YPbGW3Fnmbc</a></p>
<p>一些中文网文：<br>[3] 分布式事务：Saga 模式 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4b662407c66">https://www.jianshu.com/p/e4b662407c66</a><br>[4] 七种分布式事务的解决方案 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1806989">https://cloud.tencent.com/developer/article/1806989</a><br>[5] 分布式事务六种解决方案 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/183753774">https://zhuanlan.zhihu.com/p/183753774</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-reactive/processAListOfDataInReactiveParallelWay" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-10-24T07:55:38.000Z"><a href="/2021/10/24/reactive/processAListOfDataInReactiveParallelWay/">2021-10-24</a></time>
      
      
  
    <h1 class="title"><a href="/2021/10/24/reactive/processAListOfDataInReactiveParallelWay/">响应式并发批处理</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>假设 DataProcessor 接口定义了方法 batchProcess 能够对一批数据进行处理，一批处理 500 个数据。现在我们需要对一个响应式数据流 Flux<DataItem> dataItems 调用 batchProcess() 进行处理。</p>
<pre><code>public interface DataProcessor &#123;
  Mono&lt;String&gt; batchProcess(List&lt;DataItem&gt; dataItems);
  ... ...
&#125;


DataProcessor dataProcessor = ...;

int batchSize = 500;

Flux&lt;DataItem&gt; dataItems = ...
</code></pre>
<p>下面分别以串行和并行的方式展示一下 Reactor API 的使用。</p>
<h3 id="1）攒够-batchSize-个数据后进行处理。"><a href="#1）攒够-batchSize-个数据后进行处理。" class="headerlink" title="1）攒够 batchSize 个数据后进行处理。"></a>1）攒够 batchSize 个数据后进行处理。</h3><pre><code>Mono&lt;List&lt;String&gt;&gt; result = dataItems.buffer(batchSize)
    .flatMap(dataProcessor::batchProcess)
    .collectList();
</code></pre>
<h3 id="2）以并行的方式，把流分成-10-股，每股攒够-batchSize-个数据后进行处理。"><a href="#2）以并行的方式，把流分成-10-股，每股攒够-batchSize-个数据后进行处理。" class="headerlink" title="2）以并行的方式，把流分成 10 股，每股攒够 batchSize 个数据后进行处理。"></a>2）以并行的方式，把流分成 10 股，每股攒够 batchSize 个数据后进行处理。</h3><pre><code>Mono&lt;List&lt;String&gt;&gt; result = dataItems
    .parallel(10)
    .runOn(Schedulers.fromExecutor(Executors.newFixedThreadPool(10)))
    .groups()
    .flatMap(g -&gt; g.buffer(batchSize).flatMap(dataProcessor::batchProcess))
    .collectList();
</code></pre>
<p>这里 runOn 接收的参数可以是 Schedulers 不同策略的实现，具有不同适用范围，比如适合计算密集型的 ParallelScheduler、单线程的 SingleScheduler。这里使用的是 Executors FixedThreadPool。</p>
<p>可以想象如果我们自己实现这样一个处理逻辑的复杂度，而通过 reactor api，仅仅几行代码就完成了这么复杂高效的处理。</p>
<h3 id="3）使用-reactive-mongo-driver-需要的线程。"><a href="#3）使用-reactive-mongo-driver-需要的线程。" class="headerlink" title="3）使用 reactive mongo driver 需要的线程。"></a>3）使用 reactive mongo driver 需要的线程。</h3><p>Spring 默认到 monog 的链接池最大为 100，但是实际上在使用 reactive 方式访问时使用 20 ～ 10 个左右的线程就足够了。因此对 mongog 的连接串最好明确使用适合自己情况的连接数以避免连接浪费或不够。<br>测试了一个 70 万条、大概 250M 数据的批量插入，发现无论使用串行还是并行，数据库插入时间都差不多（36s ～ 26s）。而连接池最大连接设为 200、100、50、20、10 对数据库插入的性能也没有太大影响，200 个线程时反而有一点下降。这个情况从 mongo 响应式驱动的角度去解释是完全可以理解的，如果使用传统驱动，恐怕所需的线程就不是这个量级的了。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/oracle12c_docker" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-07-23T06:37:27.000Z"><a href="/2021/07/23/devops/oracle12c_docker/">2021-07-23</a></time>
      
      
  
    <h1 class="title"><a href="/2021/07/23/devops/oracle12c_docker/">使用Oracle 12c容器服务创建数据库</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="1-启动Oracle服务容器"><a href="#1-启动Oracle服务容器" class="headerlink" title="1) 启动Oracle服务容器"></a>1) 启动Oracle服务容器</h3><pre><code>docker run -d --name oracle -p1521:1521 -v OracleDBData:/ORCL store/oracle/database-enterprise:12.2.0.1-slim
</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://hub.docker.com/u/dhyuan/content/sub-2794a3fe-cd52-4dcb-bf8e-3fda40f02a83">https://hub.docker.com/u/dhyuan/content/sub-2794a3fe-cd52-4dcb-bf8e-3fda40f02a83</a></p>
<p>通过docker inspect oracle 可以看到被映射在 /var/lib/docker/volumes/OracleDBData</p>
<pre><code>&quot;Mounts&quot;: [
    &#123;
        &quot;Type&quot;: &quot;volume&quot;,
        &quot;Name&quot;: &quot;OracleDBData&quot;,
        &quot;Source&quot;: &quot;/var/lib/docker/volumes/OracleDBData/_data&quot;,
        &quot;Destination&quot;: &quot;/ORCL&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Mode&quot;: &quot;z&quot;,
        &quot;RW&quot;: true,
        &quot;Propagation&quot;: &quot;&quot;
    &#125;
],
</code></pre>
<h3 id="2）进入Oracle，执行sqlplus。"><a href="#2）进入Oracle，执行sqlplus。" class="headerlink" title="2）进入Oracle，执行sqlplus。"></a>2）进入Oracle，执行sqlplus。</h3><p>oracle 12c 是多租户数据库，有个核心概念CDB，PDB需要理解。进入容器oracle：<br>参考： <a target="_blank" rel="noopener" href="https://docs.oracle.com/database/121/CNCPT/cdbovrvw.htm#CNCPT89236">https://docs.oracle.com/database/121/CNCPT/cdbovrvw.htm#CNCPT89236</a></p>
<pre><code>docker exec -it oracle bash

sqlplus / as sysdba

show user
show con_name
show pdbs
</code></pre>
<p>查看当前用户连接到的数据库是CDB还是PDB。</p>
<pre><code>SELECT NAME, CDB, CON_ID FROM V$DATABASE;
</code></pre>
<h3 id="3）创建PDB"><a href="#3）创建PDB" class="headerlink" title="3）创建PDB"></a>3）创建PDB</h3><p>创建PDB之前需要设置 FILE_NAME_CONVERT 或者 db_create_file_dest<br>参考：<a target="_blank" rel="noopener" href="https://smarttechways.com/2019/03/05/ora-65016-file_name_convert-must-be-specified/">https://smarttechways.com/2019/03/05/ora-65016-file_name_convert-must-be-specified/</a><br>     <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000038344836">https://segmentfault.com/a/1190000038344836</a><br>     <a target="_blank" rel="noopener" href="https://dba.stackexchange.com/questions/190451/unable-to-connect-to-pluggable-database-in-oracle-12c">https://dba.stackexchange.com/questions/190451/unable-to-connect-to-pluggable-database-in-oracle-12c</a></p>
<p>检查PDB$SEED database文件的位置：</p>
<pre><code>SQL&gt; alter session set container=PDB$SEED;

Session altered.

SQL&gt; select FILE_NAME from dba_data_files;

FILE_NAME
--------------------------------------------------------------------------------
/u02/app/oracle/oradata/ORCL/pdbseed/system01.dbf
/u02/app/oracle/oradata/ORCL/pdbseed/sysaux01.dbf
/u02/app/oracle/oradata/ORCL/pdbseed/xdb01.dbf

SQL&gt;
</code></pre>
<p>因为创建PDB时需要连接在CDB$ROOT，所以先检查当前连接。如果不是，则切换到CDB。</p>
<pre><code>SQL&gt; select sys_context (&#39;USERENV&#39;, &#39;CON_NAME&#39;) from dual;

SYS_CONTEXT(&#39;USERENV&#39;,&#39;CON_NAME&#39;)
--------------------------------------------------------------------------------
PDB$SEED

SQL&gt;  alter session set container = CDB$ROOT;

Session altered.

SQL&gt; select sys_context (&#39;USERENV&#39;, &#39;CON_NAME&#39;) from dual;

SYS_CONTEXT(&#39;USERENV&#39;,&#39;CON_NAME&#39;)
--------------------------------------------------------------------------------
CDB$ROOT
</code></pre>
<p>创建一个PDB: YDPDB 用户：ydhbqb</p>
<pre><code>    SQL&gt; CREATE PLUGGABLE DATABASE YDPDB ADMIN USER ydhbqb IDENTIFIED BY ydhbqb0531 FILE_NAME_CONVERT=(&#39;/u02/app/oracle/oradata/ORCL/pdbseed/&#39;,&#39;/u02/app/oracle/oradata/ORCL/pdbseed/YDPDB/&#39;);
</code></pre>
<p>赋予sysdba权限：</p>
<pre><code>SQL&gt;  grant SYSDBA to ydhbqb;

Grant succeeded.
   

Pluggable database created.

SQL&gt; show pdbs;

    CON_ID CON_NAME              OPEN MODE  RESTRICTED
---------- ------------------------------ ---------- ----------
    2 PDB$SEED              READ ONLY  NO
    3 ORCLPDB1              READ WRITE NO
    4 YDPDB              MOUNTED
SQL&gt; 

SQL&gt; alter pluggable database YDPDB open;

Pluggable database altered.

SQL&gt; show pdbs;

    CON_ID CON_NAME              OPEN MODE  RESTRICTED
---------- ------------------------------ ---------- ----------
    2 PDB$SEED              READ ONLY  NO
    3 ORCLPDB1              READ WRITE NO
    4 YDPDB                  READ WRITE NO
SQL&gt; 
</code></pre>
<p>让Oracle记住这个状态：</p>
<pre><code>alter pluggable database YDPDB save state;
</code></pre>
<p>关闭PDB</p>
<pre><code>alter pluggable database YDPDBclose immediate;
</code></pre>
<p>查看错误信息</p>
<pre><code>select * from PDB_PLUG_IN_VIOLATIONS;
</code></pre>
<h3 id="4）-连接到PDB。"><a href="#4）-连接到PDB。" class="headerlink" title="4） 连接到PDB。"></a>4） 连接到PDB。</h3><h4 id="1）-用sqlplus连接到PDB。"><a href="#1）-用sqlplus连接到PDB。" class="headerlink" title="1） 用sqlplus连接到PDB。"></a>1） 用sqlplus连接到PDB。</h4><pre><code>sqlplus ydhbqb/ydhbqb0531@localhost:1521/ydpdb.localdomain
</code></pre>
<h4 id="2）-Spring-DS"><a href="#2）-Spring-DS" class="headerlink" title="2） Spring DS"></a>2） Spring DS</h4><pre><code>spring:
    datasource:
        url:  jdbc:oracle:thin:@localhost:1521/ydpdb.localdomain
        username: ydhbqb
        password: ydhbqb0531
</code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/create_vm_and_docker_by_ansible" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-05-21T14:54:38.000Z"><a href="/2021/05/22/devops/create_vm_and_docker_by_ansible/">2021-05-22</a></time>
      
      
  
    <h1 class="title"><a href="/2021/05/22/devops/create_vm_and_docker_by_ansible/">通过Ansible在Ubuntu KVM Host上安装VM和Docker</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="0）-前提"><a href="#0）-前提" class="headerlink" title="0） 前提"></a>0） 前提</h3><p>Ubuntu HOST 已经安装了 KVM 环境并工作良好。</p>
<h3 id="1）-在-Ubuntu-KVM-HOST-上安装-ansible"><a href="#1）-在-Ubuntu-KVM-HOST-上安装-ansible" class="headerlink" title="1） 在 Ubuntu KVM HOST 上安装 ansible"></a>1） 在 Ubuntu KVM HOST 上安装 ansible</h3><pre><code># Ansible
sudo apt install -y software-properties-common
sudo apt-add-repository --yes --update ppa:ansible/ansible
sudo apt install -y ansible
</code></pre>
<h3 id="2）-安装其它相关工具包"><a href="#2）-安装其它相关工具包" class="headerlink" title="2） 安装其它相关工具包"></a>2） 安装其它相关工具包</h3><pre><code>sudo apt install -y --no-install-recommends \
dnsmasq \
git \
genisoimage \
libguestfs-tools \
libosinfo-bin \
python3-libvirt \
python3-lxml \
qemu-utils \
virtinst
</code></pre>
<h3 id="3-checkout-virt-infra-代码库"><a href="#3-checkout-virt-infra-代码库" class="headerlink" title="3) checkout virt-infra 代码库"></a>3) checkout virt-infra 代码库</h3><pre><code>mkdir ~/devenv_bootstrap

git clone https://github.com/dhyuan/virt-infra-ansible.git
git check -b devenv origin/devenv

cd roles
git clone https://github.com/dhyuan/ansible-role-virt-infra.git
git check -b devenv orign.devenv
</code></pre>
<h3 id="4）-确保宿主机上有个网桥名与客户机定义文件所用网络名一致。"><a href="#4）-确保宿主机上有个网桥名与客户机定义文件所用网络名一致。" class="headerlink" title="4） 确保宿主机上有个网桥名与客户机定义文件所用网络名一致。"></a>4） 确保宿主机上有个网桥名与客户机定义文件所用网络名一致。</h3><p>比如 inventory/ubuntu20Server.yml 中我们定义了网桥网络使用 br0。</p>
<pre><code>virt_infra_networks:
        - name: br0
</code></pre>
<h3 id="5）-使用-ansible-在-ubuntu-宿主机上安装客户机"><a href="#5）-使用-ansible-在-ubuntu-宿主机上安装客户机" class="headerlink" title="5） 使用 ansible 在 ubuntu 宿主机上安装客户机"></a>5） 使用 ansible 在 ubuntu 宿主机上安装客户机</h3><p>在 <a target="_blank" rel="noopener" href="http://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img">http://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img</a> 下载镜像保持到 host 的 /var/lib/libvirt/images 目录。确保 kvmhost 上的/etc/hosts 中没有定义对 ubuntu20Server 的 ip 映射。</p>
<pre><code>apt install -y ansible

ansible-playbook --limit kvmhost,ubuntu20Server ./virt-infra.yml
</code></pre>
<p>删除安装的虚拟机：</p>
<pre><code>ansible-playbook ./virt-infra.yml --limit kvmhost,ubuntu20Server --extra-vars virt_infra_state=undefined
</code></pre>
<h3 id="6-创建完毕，通过-virt-manager-启动客户机。"><a href="#6-创建完毕，通过-virt-manager-启动客户机。" class="headerlink" title="6) 创建完毕，通过 virt-manager 启动客户机。"></a>6) 创建完毕，通过 virt-manager 启动客户机。</h3><p>测试网络的连通性，在 kvmhost 上 ping ubuntu20Server。有问题可以通过 ip 命令查看，进行必要的网卡启动等操作、检查/etc/netplan/….yml 文件、执行 netplan apply 等操作。</p>
<h3 id="7-下载在-VM-安装-Docker-的脚本，并安装"><a href="#7-下载在-VM-安装-Docker-的脚本，并安装" class="headerlink" title="7) 下载在 VM 安装 Docker 的脚本，并安装"></a>7) 下载在 VM 安装 Docker 的脚本，并安装</h3><p>在 kvmhost 上执行：</p>
<pre><code>ansible-galaxy install \
--roles-path ~/.ansible/roles/ \
git+https://github.com/haxorof/ansible-role-docker-ce.git,3.3.2

#
ansible-galaxy list
</code></pre>
<p>~/devenv_bootstrap/virt-infra-ansible/install_docker.yml 里定义了 ansbile 所用配置。执行以下语句，将在第五步创建的 VM ubuntu20Server 中安装 Docker 20.10.4。</p>
<pre><code>ansible-playbook ./install_docker.yml --limit ubuntu20Server -v --extra-vars docker_version=5:20.10.4~3-0~ubuntu-focal
</code></pre>
<p>可以通过 docker_users 参数指定加入 docker group 的用户，使用 ali 镜像下载 docker 安装包：</p>
<pre><code>ansible-playbook ./install_docker.yml \
--limit ubuntu20Server -v \
--extra-vars docker_version=5:20.10.4~3-0~ubuntu-focal \
--extra-vars &#39;&#123;&quot;docker_users&quot;: [&quot;devops&quot;] &#125;&#39; \
-e &#39;&#123;&quot;docker_repository_url&quot;: &#123;&quot;Ubuntu20&quot;: &quot;http://mirrors.aliyun.com/docker-ce/linux/ubuntu/dists/focal/Release&quot;&#125;&#125;&#39;
</code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/create_bridge_and_vms_on_ubuntu20_desktop" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-05-19T14:14:52.000Z"><a href="/2021/05/20/devops/create_bridge_and_vms_on_ubuntu20_desktop/">2021-05-20</a></time>
      
      
  
    <h1 class="title"><a href="/2021/05/20/devops/create_bridge_and_vms_on_ubuntu20_desktop/">在Ubuntu20上创建桥接网络和虚拟机</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="1）-网络管理相关命令"><a href="#1）-网络管理相关命令" class="headerlink" title="1） 网络管理相关命令"></a>1） 网络管理相关命令</h3><p>之前常用的包含在 net-tools 工具包里的命令 ifconfig、netstat 已经被 iproute2 工具包里的 ip 等命令所取代。<br>所以以后在非遗留系统，就没必要再使用不被维护的老命令了。</p>
<pre><code>ip link show
ip link show eth0
ip link set eth0 up|down

ip addr show
ip addr show eth0
ip add add|del 192.168.0.99/24 eth0

ip route
ip neigh

ss -l
ss -a

lsof -i // -i 网络 -u 用户  -p 进程ID -c 进程名
</code></pre>
<h3 id="2）-Ubuntu-网络管理"><a href="#2）-Ubuntu-网络管理" class="headerlink" title="2） Ubuntu 网络管理"></a>2） Ubuntu 网络管理</h3><p>如果是 Ubuntu Desktop 环境，就不妨使用 NetworkManager 和 nm-connection-editor 这些 GUI 程序或者 nmcli、nmtui 来管理网络及设备。<br>如果是 Ubuntu Server 环境，还是用 systemd-netword 比较好。<br>NetworkManager 和 networkd 是有冲突的，选择使用一个之后另一种方式需要被禁用。下面的命令是操作相关服务所用的命令，其中 enable/disable 用于设置是否开机启动而 mask/unmask 则用于设置服务是否可用。选择使用 NetworkManager 之后检查以下 cat /etc/NetworkManager/NetworkManager.conf，确保 managered 被设置为 true。</p>
<pre><code>sudo systemctl stop NetworkManager
sudo systemctl disable NetworkManager
sudo systemctl mask NetworkManager

sudo systemctl unmask systemd-networkd.service
sudo systemctl enable systemd-networkd.service
sudo systemctl start systemd-networkd.service
</code></pre>
<p>在 NetworkManager 和 networkd 之上，我们可以使用 netplan 来进行更高层次的控制。参考：<a target="_blank" rel="noopener" href="https://netplan.io/">https://netplan.io/</a></p>
<blockquote><p>Netplan is a utility for easily configuring networking on a linux system. You simply create a YAML description of the required network interfaces and what each should be configured to do. From this description Netplan will generate all the necessary configuration for your chosen renderer tool.</p>
</blockquote>

<h3 id="3）创建网桥、虚拟机，设置虚拟机桥接网卡。"><a href="#3）创建网桥、虚拟机，设置虚拟机桥接网卡。" class="headerlink" title="3）创建网桥、虚拟机，设置虚拟机桥接网卡。"></a>3）创建网桥、虚拟机，设置虚拟机桥接网卡。</h3><p>实验环境使用 Ubuntu20 Desktop 做宿主机，感觉用 nm-connection-editor 创建网桥、配置网桥出口也很方便、顺利。具体步骤可参考<a target="_blank" rel="noopener" href="http://www.zrway.com/news/8366.html%E3%80%82">http://www.zrway.com/news/8366.html。</a></p>
<p>下图是通过 nm-connection-editor 创建出网桥，并把物理网卡插到这个网桥上。注意，把网卡作为网桥的 salver 设备之后，需要通过 GUI 删除这个网络网卡。</p>
<p><img src="/2021/05/19/devops/create_bridge_and_vms_on_ubuntu20_desktop/create_bridge.png" alt="创建网桥"></p>
<p>通过 virt-manager 创建出虚拟机后，需要设置虚拟机的网卡。这里有个 QEMU 前端设备、后端后端设备（backend network）的概念。所谓前端设备就是 Guest 虚拟机看到的设备，后端设备、后端网络就是在 Host 宿主机上的设备、网络。下图实际上大致对应这样的命令： qemu -net nic,model=e1000 -net bridge,br=bridge1 …</p>
<p><img src="/2021/05/19/devops/create_bridge_and_vms_on_ubuntu20_desktop/set_net_device_in_guestvm.png" alt="设置网桥"></p>
<p>下图是/etc/netplan 目录里的配置文件。</p>
<p><img src="/2021/05/19/devops/create_bridge_and_vms_on_ubuntu20_desktop/netplan_setting_in_guestvm.png"></p>
<p>参考:<br>netplan: <a target="_blank" rel="noopener" href="https://ubuntu.com/blog/ubuntu-bionic-netplan">https://ubuntu.com/blog/ubuntu-bionic-netplan</a><br>图形化管理工具： <a target="_blank" rel="noopener" href="https://ubuntu.com/core/docs/networkmanager">https://ubuntu.com/core/docs/networkmanager</a><br>网络管理服务: <a target="_blank" rel="noopener" href="https://www.configserverfirewall.com/ubuntu-linux/ubuntu-network-manager/">https://www.configserverfirewall.com/ubuntu-linux/ubuntu-network-manager/</a><br>创建网桥： <a target="_blank" rel="noopener" href="http://www.zrway.com/news/8366.html">http://www.zrway.com/news/8366.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/nginx-workshop-environment" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-05-18T07:55:38.000Z"><a href="/2021/05/18/devops/nginx-workshop-environment/">2021-05-18</a></time>
      
      
  
    <h1 class="title"><a href="/2021/05/18/devops/nginx-workshop-environment/">利用docker在本地搭建nginx环境</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>利用 docker 搭建如下拓扑结构的的实验环境。相关代码可以在 <a target="_blank" rel="noopener" href="https://github.com/dhyuan/dockerEnv/tree/main/nginx">https://github.com/dhyuan/dockerEnv/tree/main/nginx</a> 获得。</p>
<p><img src="/2021/05/18/devops/nginx-workshop-environment/topology.jpg" alt="Topology"></p>
<h3 id="1-网路"><a href="#1-网路" class="headerlink" title="1) 网路"></a>1) 网路</h3><p>首先创建一个网络’nginx-net’，把所有的相关的容器放在这个网络里以方便容器之间的访问。<br>这个网络地址范围 172.50.0.0/16。相关脚本 createNetwork.sh。</p>
<pre><code>docker network create --subnet=172.50.0.0/16 nginx-net
</code></pre>
<h3 id="2-创建并运行-Nginx-容器-‘nginxA’-‘nginxB’-‘nginxC’"><a href="#2-创建并运行-Nginx-容器-‘nginxA’-‘nginxB’-‘nginxC’" class="headerlink" title="2) 创建并运行 Nginx 容器 ‘nginxA’, ‘nginxB’, ‘nginxC’."></a>2) 创建并运行 Nginx 容器 ‘nginxA’, ‘nginxB’, ‘nginxC’.</h3><p>并把个容器的 IP 固定下来防止容器重启后 IP 变化以影响日志观察。<br>把相关配置影射到本地方便修改。相关脚本 startNginx.sh。</p>
<p>下面是配置 nginx 容器 nginxA。</p>
<pre><code>docker run --name nginxA \
--network nginx-net --ip 172.50.0.11 \
-v ~/dockerEnv/nginx/nginxA/html:/usr/share/nginx/html:ro \
-v ~/dockerEnv/nginx/nginxA/config/conf.d:/etc/nginx/conf.d \
-v ~/dockerEnv/nginx/nginxA/config/nginx.conf:/etc/nginx/nginx.conf:ro \
-v ~/dockerEnv/nginx/nginxA/log:/var/log/nginx \
-p 18080:9090 \
-d nginx:1.22.0
</code></pre>
<p>Nginx 镜像不包含 ping，curl 这样的常用工具，可以自行安装。</p>
<pre><code>docker exec -it nginxA sh
apt-get update
apt-get install iputils-ping curl
</code></pre>
<h3 id="3-创建一个容器作为-client"><a href="#3-创建一个容器作为-client" class="headerlink" title="3) 创建一个容器作为 client"></a>3) 创建一个容器作为 client</h3><p>因为 nginx 容器都在自己的网络 nginx-net 里，为了方便测试通过创建一个 Alpine 容器作为客户端环境。Alpine 容器以-it 交互模式运行。</p>
<pre><code>docker run --name nclient100 --network nginx-net --ip 172.50.0.100 -it alpine:3.16.0
</code></pre>
<p>Alpine 镜像没有 curl 命令，可以通过 apk 安装。</p>
<pre><code>apk add curl
</code></pre>
<p>可以在 console 发送 curl 命令进行测试。</p>
<pre><code>curl http://nginxA:9090/testProxy/index.html
curl -H &quot;X-FORWARDED-FOR: 12.3.4.5&quot;  http://nginxA:9090/testProxy/index.html
</code></pre>
<h3 id="4-Play-around"><a href="#4-Play-around" class="headerlink" title="4) Play around"></a>4) Play around</h3><p>因为 ngix 容器的配置、日志、html 目录都映射到了本地，所以可以本地的这些内容进行测试、验证。<br>可以根据自己的需要修改 nginxA(B|C)/config/confd/9090.conf 里的**”location /testProxy”** 来进行相关 nginx 相关参数的验证。</p>
<p>查看各容器的 IP，可运行 ./showInfo.sh<br>清除各容器的 nginx 日志，可运行 ./cleanlog.sh<br>修改 nginx 的配置后进行语法检查，可运行 ./testCfg.sh<br>变更了 nginx 的配置使之生效，可运行 ./reload.sh</p>
<h3 id="5）-Demo"><a href="#5）-Demo" class="headerlink" title="5） Demo"></a>5） Demo</h3><p>下图显示了一个测试获取真实用户 IP 的场景。</p>
<p>为了查看 HTTP header 里的 X_REAL_IP 字段，在‘log_format main’里加上了 <strong>“ | $http_x_real_ip”</strong> ,这样在 access.log 就就可以看到 nginx 接收到的 HEADER X_REAL_IP 的值。</p>
<p>从图里 nginxC 的 access.log 中可以看到，nginxC 收到的 X_REAL_IP 是 ngixA 的 IP。如果我们希望这里的 X_REAL_IP 记录的是真正 web client 的 IP 就需要把 nginxB 中的指令 “proxy_set_header X-Real-IP $remote_addr;” 注释掉。这样，ngixC中收到的X_REAL_IP就是 nginxA中看到的$remote_addr，及 ngixA 看到的 client 的 IP 了。</p>
<p><img src="/2021/05/18/devops/nginx-workshop-environment/Nginx-X-FORWARDED-FOR.drawio.png" alt="X-FORWARDED_FOR_demo"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/jenkins_maven_allure" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-05-10T12:39:52.000Z"><a href="/2021/05/11/devops/jenkins_maven_allure/">2021-05-11</a></time>
      
      
  
    <h1 class="title"><a href="/2021/05/11/devops/jenkins_maven_allure/">在Jenkins中使用Allure显示测试结果</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>allure 官网对自己的定义:</p>
<blockquote><p>Allure Framework is a flexible lightweight multi-language test report tool that not only shows a very concise representation of what have been tested in a neat web report form …</p>
</blockquote>

<h3 id="1）首先在开发机器中安装-allure，"><a href="#1）首先在开发机器中安装-allure，" class="headerlink" title="1）首先在开发机器中安装 allure，"></a>1）首先在开发机器中安装 allure，</h3><p>参考官方文档 <a target="_blank" rel="noopener" href="https://docs.qameta.io/allure/#_installing_a_commandline">https://docs.qameta.io/allure/#_installing_a_commandline</a> 安装 allure。这里要注意的是如果是通过下载压缩包解压进行的安装，那么需要把 allure 连接到/usr/bin/allsure 这样的系统目录，否则 allure-maven 插件运行时找不到 allure command。如果是 mac 系统，因为权限管理的问题，可以链接到/usr/local/bin/allure。</p>
<h3 id="2-配置-pom-文件保证-allure-在本地可工作。"><a href="#2-配置-pom-文件保证-allure-在本地可工作。" class="headerlink" title="2) 配置 pom 文件保证 allure 在本地可工作。"></a>2) 配置 pom 文件保证 allure 在本地可工作。</h3><p>配置 maven 项目使用的是哪种测试框架来配置 pom 文件，可参考：<a target="_blank" rel="noopener" href="https://docs.qameta.io/allure/#_java">https://docs.qameta.io/allure/#_java</a><br>运行以下命令确认本地环境可以正常生成 allure report。</p>
<pre><code>mvn clean test allure:report
mvn allure:serve
</code></pre>
<h3 id="3）在-jenkins-中安装-allure-插件并配置。"><a href="#3）在-jenkins-中安装-allure-插件并配置。" class="headerlink" title="3）在 jenkins 中安装 allure 插件并配置。"></a>3）在 jenkins 中安装 allure 插件并配置。</h3><p>如图，安装 allure plugin<br><img src="/2021/05/10/devops/jenkins_maven_allure/jenkins_install_allure_plugin.png" alt="安装allure插件"></p>
<p>如图，配置 allure tool，这里选择用到 allure 时自动下载。<br><img src="/2021/05/10/devops/jenkins_maven_allure/jenkins_config_allure_tool.png" alt="配置allure工具"></p>
<h3 id="4）修改-Jenkinsfile-添加-allure-相关-step。"><a href="#4）修改-Jenkinsfile-添加-allure-相关-step。" class="headerlink" title="4）修改 Jenkinsfile 添加 allure 相关 step。"></a>4）修改 Jenkinsfile 添加 allure 相关 step。</h3><p>allure 相关配置大致如下：</p>
<pre><code>post &#123;
    always &#123;
        junit testResults: &quot;**/target/surefire-reports/*.xml&quot;

        script &#123;
          allure includeProperties: false, jdk: &#39;&#39;, results: [[path: &#39;target/allure-results/&#39;]]
        &#125;
    &#125;

    success &#123;
        archiveArtifacts &#39;target/*.jar&#39;
    &#125;
&#125;
</code></pre>
<p>当把对 pom 和 jenkinsfile 的修改 push 到 GitLab 之后，因为之前已经配置了 pipeline 可被 gitlab 事件触发执行。顺利的话，就可在 Jenkins 中看到 allure 生成的报表了。</p>
<p>报表入口：<br>注意，生成的 allure-report.zip 并不能解压后直接通过浏览器查看，需要通过运行 allure open ./allure-report.zip 来查看。<br><img src="/2021/05/10/devops/jenkins_maven_allure/jenkins_allure_result0.png"></p>
<p>可视化图表：<br><img src="/2021/05/10/devops/jenkins_maven_allure/jenkins_allure_result2.png"></p>
<p>Reference:<br><a target="_blank" rel="noopener" href="https://docs.qameta.io/allure/">https://docs.qameta.io/allure/</a><br><a target="_blank" rel="noopener" href="https://github.com/jenkinsci/allure-plugin">https://github.com/jenkinsci/allure-plugin</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/jenkins_pipeline_maven" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-05-09T12:49:50.000Z"><a href="/2021/05/10/devops/jenkins_pipeline_maven/">2021-05-10</a></time>
      
      
  
    <h1 class="title"><a href="/2021/05/10/devops/jenkins_pipeline_maven/">通过Jenkins pipeline build Maven项目</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>如之前的文章<a href="/2021/03/05/devops/install_dockers_coredns_gitlab_jenkins/" title="安装 CoreDNS、GitLab、Jenkins 容器">安装 CoreDNS、GitLab、Jenkins 容器</a> 所述熟悉了基本的容器安装之后就可以配置 Jenkins pipeline 构建基于 maven 的 Java 项目了。</p>
<h3 id="1）安装-JDK-及-Maven"><a href="#1）安装-JDK-及-Maven" class="headerlink" title="1）安装 JDK 及 Maven"></a>1）安装 JDK 及 Maven</h3><p>不要通过 apt install 的方式安装，而通过下载 zip 解压的方式安装。</p>
<pre><code>mkdir -p /home/devops/dockerSrvStorage/jenkins/tools/
cd /home/devops/dockerSrvStorage/jenkins/tools/
wget https://download.java.net/openjdk/jdk11/ri/openjdk-11+28_linux-x64_bin.tar.gz
tar xvzf openjdk-11+28_linux-x64_bin.tar.gz
wget https://mirrors.bfsu.edu.cn/apache/maven/maven-3/3.8.1/binaries/apache-maven-3.8.1-bin.zip
unzip apache-maven-3.8.1-bin.zip
</code></pre>
<h3 id="2）启动-GitLab、Jenkins-容器。"><a href="#2）启动-GitLab、Jenkins-容器。" class="headerlink" title="2）启动 GitLab、Jenkins 容器。"></a>2）启动 GitLab、Jenkins 容器。</h3><p>停止并删除旧的 Jenkins, GitLab 容器：</p>
<pre><code>docker stop jenkins gitlab
docker rm jenkins gitlab
</code></pre>
<p>Jenkins 和 GitLab 容器的互联互通至少有下面两种方式。一种是通过先定义出一个 network，然后 Jenkins 和 GitLab 加入这个网络来完成，这时容器间的访问是在 docker 自己内部网络上完成的而与宿主机 IP 无关。。一种是通过外部 DNS Server 完成容器间域名字的解析，这时容器间的访问是通过宿主机的 IP+映射到宿主机的端口完成的。</p>
<p>docker 网络内部互联的方式，如果是跨主机容器间通讯可以通过 overlay 完成。（如果跨主机这种方式，就没有理由不上 K8S 了。）下面是用于在同一宿主机下的命令：<br>首先创建一个网络：</p>
<pre><code>docker network create devopNet
</code></pre>
<p>启动 Jenkins 和 GitLab 容器，注意这里通过–net 设定它们的网络都是 devNet</p>
<pre><code>docker run --detach \
--name jenkins \
--net devopNet \
--hostname jenkins.telbox.cn \
--publish 9183:8080 --publish 9184:50000 \
--restart always \
-v /home/devops/dockerSrvStorage/jenkins:/var/jenkins_home \
jenkins/jenkins:2.277.4-lts-jdk11

docker run --detach \
--name gitlab \
--net devopNet \
--hostname gitlab.telbox.cn \
--publish 9181:443 --publish 9180:80 --publish 9182:22 \
--restart always \
-v /home/devops/dockerSrvStorage/gitlab/config:/etc/gitlab \
-v /home/devops/dockerSrvStorage/gitlab/logs:/var/log/gitlab \
-v /home/devops/dockerSrvStorage/gitlab/data:/var/opt/gitlab \
gitlab/gitlab-ce:13.11.3-ce.0
</code></pre>
<p>通过 DNS 来通许的容器，相当于容器可以使用传入的 DNS 服务，也就可以通过 DNS 中定义的机器名通讯了。这样 jenkins 容器和 gitlab 容器运行在不同的主机，DNS 解析不同宿主机 IP/域名。这种情形， Jenkins 容器 ssh 到非 22 的 GitLab 上（假设 gitlab 容器映射 22 端口到其宿主机的 9182 端口），那么就需要设置 Jenkins 里 ssh config 文件。比如下面的/home/devops/dockerSrvStorage/jenkins/.ssh/config 这样：</p>
<pre><code>Host gitlab.telbox.cn
    Hostname gitlab.telbox.cn
    Port 9182
    User dhyuan
</code></pre>
<p>这样在 jenkins 容器的 ssh 才能默认连接到 gitlab 容器宿主机的 9182 端口。</p>
<pre><code>docker run --detach \
--name jenkins \
--dns 192.168.0.114 \
--hostname jenkins.telbox.cn \
--publish 9183:8080 --publish 9184:50000 \
--restart always \
-v /home/devops/dockerSrvStorage/jenkins:/var/jenkins_home \
jenkins/jenkins:2.277.4-lts-jdk11

docker run --detach \
--name gitlab \
--dns 192.168.0.114 \
--hostname gitlab.telbox.cn \
--publish 9181:443 --publish 9180:80 --publish 9182:22 \
--restart always \
-v /home/devops/dockerSrvStorage/gitlab/config:/etc/gitlab \
-v /home/devops/dockerSrvStorage/gitlab/logs:/var/log/gitlab \
-v /home/devops/dockerSrvStorage/gitlab/data:/var/opt/gitlab \
gitlab/gitlab-ce:13.11.3-ce.0
</code></pre>
<p>另外，之前使用的 GitLab 容器镜像 gitlab/gitlab-ce:13.9.2-ce.0 的 Integration-Jenkins CI 部分有 bug，换用 gitlab/gitlab-ce:13.11.3-ce.0 后 webhook 就可以工作了。</p>
<h3 id="3）配置-Jenkins-使用-JDK、Maven-如图："><a href="#3）配置-Jenkins-使用-JDK、Maven-如图：" class="headerlink" title="3）配置 Jenkins 使用 JDK、Maven, 如图："></a>3）配置 Jenkins 使用 JDK、Maven, 如图：</h3><p>配置 JDK<br><img src="/2021/05/09/devops/jenkins_pipeline_maven/jenkins_tool_jdk.png" alt="设置JDK"></p>
<p>配置 Maven<br><img src="/2021/05/09/devops/jenkins_pipeline_maven/jenkins_tool_maven.png" alt="设置JDK"></p>
<h3 id="4）通过-ssh-gen-生成-RSA-公私钥对，并配置-Jenkins-和-GitLab"><a href="#4）通过-ssh-gen-生成-RSA-公私钥对，并配置-Jenkins-和-GitLab" class="headerlink" title="4）通过 ssh-gen 生成 RSA 公私钥对，并配置 Jenkins 和 GitLab"></a>4）通过 ssh-gen 生成 RSA 公私钥对，并配置 Jenkins 和 GitLab</h3><pre><code>ssh-keygen -t rsa -b 2048 -C &quot;Used for dhyuan GitLab&quot;
</code></pre>
<p>把生成的私钥通过 Jenkins 界面：Dashboard –&gt; Credentials –&gt; System Global credentials 设置为 GitLab 账号的私钥。<br><img src="/2021/05/09/devops/jenkins_pipeline_maven/jenkins_to_gitlab_privatekey.png"></p>
<p>把生成的公钥通过 GitLab 界面进行设置, 如下图：<br><img src="/2021/05/09/devops/jenkins_pipeline_maven/jenkins_to_gitlab_publickey.png"></p>
<h3 id="4）创建一个-Pipeline-项目并以从-GitLab-获取-Jenkinsfile-的形式定义-pipeline。"><a href="#4）创建一个-Pipeline-项目并以从-GitLab-获取-Jenkinsfile-的形式定义-pipeline。" class="headerlink" title="4）创建一个 Pipeline 项目并以从 GitLab 获取 Jenkinsfile 的形式定义 pipeline。"></a>4）创建一个 Pipeline 项目并以从 GitLab 获取 Jenkinsfile 的形式定义 pipeline。</h3><p>设置 pipeline 文件来自 git 管理的仓库：<br><img src="/2021/05/09/devops/jenkins_pipeline_maven/pipeline_setting_jenkinsfile.png"></p>
<p>需要注意的是，如果 branch 设置为*/master，那么就不要勾选 Lightweight checkout。如果勾选了 Lightweight checkout<br>，可把 branch 设置为*/*。<br><img src="/2021/05/09/devops/jenkins_pipeline_maven/pipeline_setting_lightweight_checkout.png"></p>
<p>设置 pipeline 可由 GitLab 代码仓库事件触发执行，并在其高级选项中生成 Secret token。<br><img src="/2021/05/09/devops/jenkins_pipeline_maven/jenkins_pipeline_triggered_by_push.png"></p>
<h3 id="5-设置当-GitLab-发生-push-等操作是触发-Jenkins-Pipeline-运行。"><a href="#5-设置当-GitLab-发生-push-等操作是触发-Jenkins-Pipeline-运行。" class="headerlink" title="5) 设置当 GitLab 发生 push 等操作是触发 Jenkins Pipeline 运行。"></a>5) 设置当 GitLab 发生 push 等操作是触发 Jenkins Pipeline 运行。</h3><p>如图设置完毕就可以通过点击测试按钮发送“push”消息来触发 pipeline 的运行了。<br><img src="/2021/05/09/devops/jenkins_pipeline_maven/gitlab_webhook_to_jenkins.png"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-reactive/spring_security_reactive_csrf" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-04-16T12:49:09.000Z"><a href="/2021/04/17/reactive/spring_security_reactive_csrf/">2021-04-17</a></time>
      
      
  
    <h1 class="title"><a href="/2021/04/17/reactive/spring_security_reactive_csrf/">Spring响应式CSRF相关源码</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>上篇介绍了 CSRF 及 Spring Security 对防范 CSRF 所做的支持。Spring Security 实现了基于 Session 和 Cookie 的 Sychronizer Token Pattern，以防范 CSRF。并且默认是基于 session 的。</p>
<p>Spring Security 基于 Servlet 和 WebFlux 技术分别进行了实现。<br>其中，基于 Servlet 技术栈的实现代码是：</p>
<pre><code>CsrfFilter：执行过滤、验证。
CsrfTokenRepository：存储 csrf token 的接口。
CookieCsrfTokenRepository： 用 cookie 保存 csrf token
HttpSessionCsrfTokenRepository：用session 保存csrf token
CsrfAuthenticationStrategy.onAuthentication() 每次请求生成新 csrf token
</code></pre>
<p>基于 WebFlux 技术栈的实现代码没有与 CsrfAuthenticationStrategy 对应的类，而是直接在 CsrfWebFilter.filter()–&gt; continueFilterChain() –&gt; … this.csrfTokenRepository.loadToken(exchange).switchIfEmpty(generateToken(exchange)) 完成了。</p>
<p>Filter 和 TokenRepository 都有对应的类，如下：</p>
<pre><code>CsrfWebFilter
ServerCsrfTokenRepository
  CookieServerCsrfTokenRepository WebSessionServerCsrfTokenRepository
</code></pre>
<p>CookieServerCsrfTokenRepository WebSessionServerCsrfTokenRepository 的逻辑更直接一些。下面以注释的方式解读一下 CsrfWebFilter 代码。</p>
<p>除了基本的 fitler，flatMap 这些 operators，可以特别留意以下几个 operators：<br>switchIfEmpty()<br>filterWhen()<br>delayUntil()<br>Mono.defer()</p>
<pre><code>public class CsrfWebFilter implements WebFilter &#123;

  public static final ServerWebExchangeMatcher DEFAULT_CSRF_MATCHER = new DefaultRequireCsrfProtectionMatcher();

  /**
  * The attribute name to use when marking a given request as one that should not be
  * filtered.
  *
  * To use, set the attribute on your &#123;@link ServerWebExchange&#125;: &lt;pre&gt;
  *     CsrfWebFilter.skipExchange(exchange);
  * &lt;/pre&gt;
  */
  private static final String SHOULD_NOT_FILTER = &quot;SHOULD_NOT_FILTER&quot; + CsrfWebFilter.class.getName();

  private ServerWebExchangeMatcher requireCsrfProtectionMatcher = DEFAULT_CSRF_MATCHER;

  // 默认基于Session保存csrf token。
  private ServerCsrfTokenRepository csrfTokenRepository = new WebSessionServerCsrfTokenRepository();

  private ServerAccessDeniedHandler accessDeniedHandler = new HttpStatusServerAccessDeniedHandler(
      HttpStatus.FORBIDDEN);

  private boolean isTokenFromMultipartDataEnabled;

  public void setAccessDeniedHandler(ServerAccessDeniedHandler accessDeniedHandler) &#123;
    Assert.notNull(accessDeniedHandler, &quot;accessDeniedHandler&quot;);
    this.accessDeniedHandler = accessDeniedHandler;
  &#125;

  public void setCsrfTokenRepository(ServerCsrfTokenRepository csrfTokenRepository) &#123;
    Assert.notNull(csrfTokenRepository, &quot;csrfTokenRepository cannot be null&quot;);
    this.csrfTokenRepository = csrfTokenRepository;
  &#125;

  /**
  * 如果我们的应用GET，HEAD，TRACE，OPTIONS 这些方法会改变应用的状态，就需要自定义matcher。
  * 自定义的matcher可以有更复杂的匹配逻辑，而不仅仅限于DefaultRequireCsrfProtectionMatcher 中所用的request method。
  * 可参考 DefaultRequireCsrfProtectionMatcher。
  *
  * @param requireCsrfProtectionMatcher
  */
  public void setRequireCsrfProtectionMatcher(ServerWebExchangeMatcher requireCsrfProtectionMatcher) &#123;
    Assert.notNull(requireCsrfProtectionMatcher, &quot;requireCsrfProtectionMatcher cannot be null&quot;);
    this.requireCsrfProtectionMatcher = requireCsrfProtectionMatcher;
  &#125;

  /**
  * Specifies if the &#123;@code CsrfWebFilter&#125; should try to resolve the actual CSRF token
  * from the body of multipart data requests.
  * @param tokenFromMultipartDataEnabled true if should read from multipart form body,
  * else false. Default is false
  */
  public void setTokenFromMultipartDataEnabled(boolean tokenFromMultipartDataEnabled) &#123;
    this.isTokenFromMultipartDataEnabled = tokenFromMultipartDataEnabled;
  &#125;

  @Override
  public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123;
    // 如果代码通过调用 CsrfWebFilter.skipExchange(exchange) 设置无需进行CSRF保护，则继续chain的下一个节点。
    if (Boolean.TRUE.equals(exchange.getAttribute(SHOULD_NOT_FILTER))) &#123;
      return chain.filter(exchange).then(Mono.empty());
    &#125;

    return this.requireCsrfProtectionMatcher.matches(exchange) // 根据 requireCsrfProtectionMatcher 进行匹配
        .filter(MatchResult::isMatch) // 如果需要CSRF保护。
        // 这里matchResult只是个占位符。过滤出已经设置了CsrfToken的exchange。
        .filter((matchResult) -&gt; !exchange.getAttributes().containsKey(CsrfToken.class.getName()))
        // 验证这个csrf token，这个验证逻辑是CSRF的核心。根据csrf token是保存在session还是cookie，逻辑不同。
        // 详细逻辑参考 ServerCsrfTokenRepository 的两个实现 CookieServerCsrfTokenRepository WebSessionServerCsrfTokenRepository
        .flatMap((m) -&gt; validateToken(exchange))
        // 校验文csrf token，继续chain的下个节点处理。
        .flatMap((m) -&gt; continueFilterChain(exchange, chain))
        // switchIfEmpty实际是继续.filter(MatchResult::isMatch).filter((matchResult) -&gt; 。。。) 这两个filter之后的情况。
        .switchIfEmpty(continueFilterChain(exchange, chain).then(Mono.empty()))
        .onErrorResume(CsrfException.class, (ex) -&gt; this.accessDeniedHandler.handle(exchange, ex));
  &#125;

  public static void skipExchange(ServerWebExchange exchange) &#123;
    exchange.getAttributes().put(SHOULD_NOT_FILTER, Boolean.TRUE);
  &#125;

  private Mono&lt;Void&gt; validateToken(ServerWebExchange exchange) &#123;
    return this.csrfTokenRepository.loadToken(exchange) // 从session或者cookie中得到csrf token，作为比较基准。
        // 如果没有找到csrf token则抛出异常没有找到期望的csrf token。（之前版本的错误信息有误 https://github.com/spring-projects/spring-security/commit/a1083d9a5ce3fef8fa458a47e5a6b7a6576ec01e#diff-9c109ef13a33c07de3231051c08e424e664985d142f54ccd7830169d4adcadb1）
        // 注意这里用的defer而不是just用来避免不必要的对象创建。
        // switchIfEmpty() 感觉上就是reactive stream里的的if语句：如果是空流，则用另一个publisher。
        .switchIfEmpty(
            Mono.defer(() -&gt; Mono.error(new CsrfException(&quot;An expected CSRF token cannot be found&quot;))))
        /**
        * 判断用户从页面提交的csrf token和从session/cookie中保存的是否一致。
        * 注意，这里用了filterWhen而不是filter。表面的原因是containsValidCsrfToken()的返回值是Mono&lt;Boolean&gt;而不是Boolean。
        * 而更深层的原因应该是CsrfWebFilter不应该是阻塞的，因为这个filter要处理所有的request，所以需要异步地测试、过滤。
        * 感觉上也有点像flatMap，都是接收Publisher参数。
        **/
        .filterWhen((expected) -&gt; containsValidCsrfToken(exchange, expected))
        // 如果没有找到有效的csrf token，那么就抛出异常。
        .switchIfEmpty(Mono.defer(() -&gt; Mono.error(new CsrfException(&quot;Invalid CSRF Token&quot;)))).then();
  &#125;

  private Mono&lt;Boolean&gt; containsValidCsrfToken(ServerWebExchange exchange, CsrfToken expected) &#123;
    // 先从form里找用户提交的csrf token。
    return exchange.getFormData().flatMap((data) -&gt; Mono.justOrEmpty(data.getFirst(expected.getParameterName())))
        // form 表单里没有，就从header里找
        .switchIfEmpty(Mono.justOrEmpty(exchange.getRequest().getHeaders().getFirst(expected.getHeaderName())))
        // 最后从multipart里找
        .switchIfEmpty(tokenFromMultipartData(exchange, expected))
        // 如果找到了，则和从session或cookie里得到的csrf token做比较
        .map((actual) -&gt; equalsConstantTime(actual, expected.getToken()));
  &#125;

  private Mono&lt;String&gt; tokenFromMultipartData(ServerWebExchange exchange, CsrfToken expected) &#123;
    if (!this.isTokenFromMultipartDataEnabled) &#123;
      return Mono.empty();
    &#125;
    ServerHttpRequest request = exchange.getRequest();
    HttpHeaders headers = request.getHeaders();
    MediaType contentType = headers.getContentType();
    if (!contentType.includes(MediaType.MULTIPART_FORM_DATA)) &#123;
      return Mono.empty();
    &#125;
    return exchange.getMultipartData().map((d) -&gt; d.getFirst(expected.getParameterName())).cast(FormFieldPart.class)
        .map(FormFieldPart::value);
  &#125;

  private Mono&lt;Void&gt; continueFilterChain(ServerWebExchange exchange, WebFilterChain chain) &#123;
    return Mono.defer(() -&gt; &#123;
      Mono&lt;CsrfToken&gt; csrfToken = csrfToken(exchange);
      exchange.getAttributes().put(CsrfToken.class.getName(), csrfToken);
      return chain.filter(exchange);
    &#125;);
  &#125;

  private Mono&lt;CsrfToken&gt; csrfToken(ServerWebExchange exchange) &#123;
    // 如果从repository中找到了csrf token就返回，否则就生成一个token返回。
    return this.csrfTokenRepository.loadToken(exchange).switchIfEmpty(generateToken(exchange));
  &#125;

  /**
  * Constant time comparison to prevent against timing attacks.
  * @param expected
  * @param actual
  * @return
  */
  private static boolean equalsConstantTime(String expected, String actual) &#123;
    if (expected == actual) &#123;
      return true;
    &#125;
    if (expected == null || actual == null) &#123;
      return false;
    &#125;
    // Encode after ensure that the string is not null
    byte[] expectedBytes = Utf8.encode(expected);
    byte[] actualBytes = Utf8.encode(actual);
    return MessageDigest.isEqual(expectedBytes, actualBytes);
  &#125;

  private Mono&lt;CsrfToken&gt; generateToken(ServerWebExchange exchange) &#123;
    // 委托给csrfTokenRepository 产生一个新token。
    return this.csrfTokenRepository.generateToken(exchange)
        // 注意这里的delayUntil()用法：直到token保存好之后，上步由csrfTokenRepository产生的Mono&lt;CsrfToken&gt;才继续走流水线。
        .delayUntil((token) -&gt; this.csrfTokenRepository.saveToken(exchange, token));
  &#125;

  private static class DefaultRequireCsrfProtectionMatcher implements ServerWebExchangeMatcher &#123;

    // 如果我们应用在保证GET，HEAD，TRACE，OPTIONS等方法不改变系统状态，不需要进行CSRF保护，就可使用这个默认的matcher类。
    private static final Set&lt;HttpMethod&gt; ALLOWED_METHODS = new HashSet&lt;&gt;(
        Arrays.asList(HttpMethod.GET, HttpMethod.HEAD, HttpMethod.TRACE, HttpMethod.OPTIONS));

    @Override
    public Mono&lt;MatchResult&gt; matches(ServerWebExchange exchange) &#123;
      return Mono.just(exchange.getRequest()) // 从exchagne得到request对象
          .flatMap((r) -&gt; Mono.justOrEmpty(r.getMethod())) // 得到http request的method。
          .filter(ALLOWED_METHODS::contains) // 仅保留无需CSRF保护的方法
          .flatMap((m) -&gt; MatchResult.notMatch()) // 过滤后，有无需CSRF保护的方法则不匹配（无需CSRF保护）。
          .switchIfEmpty(MatchResult.match()); // 过滤后，没有匹配到方法，则匹配（需CSRF保护）。
    &#125;

  &#125;

&#125;
</code></pre>
<p>Reference：<br><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.4.5/reference/html5/#csrf">https://docs.spring.io/spring-security/site/docs/5.4.5/reference/html5/#csrf</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-reactive/webflux_csrf" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-04-14T13:05:54.000Z"><a href="/2021/04/15/reactive/webflux_csrf/">2021-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2021/04/15/reactive/webflux_csrf/">Spring对CSRF的防范</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>这篇基本上是<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.4.6/reference/html5/">Spring Security Reference</a>关于 CSRF 部分的一个笔记，只是记录一下核心逻辑。其它很多细节还是要参考官方文档。</p>
<h3 id="什么是-CSRF"><a href="#什么是-CSRF" class="headerlink" title="什么是 CSRF"></a>什么是 CSRF</h3><p>跨站请求伪造。经典场景是：</p>
<h5 id="1）受害者首先登录了银行网站"><a href="#1）受害者首先登录了银行网站" class="headerlink" title="1）受害者首先登录了银行网站"></a>1）受害者首先登录了银行网站</h5><h5 id="2）用户没有-longout-的情况下"><a href="#2）用户没有-longout-的情况下" class="headerlink" title="2）用户没有 longout 的情况下"></a>2）用户没有 longout 的情况下</h5><h5 id="3）用同一个浏览器访问了“坏”网站"><a href="#3）用同一个浏览器访问了“坏”网站" class="headerlink" title="3）用同一个浏览器访问了“坏”网站"></a>3）用同一个浏览器访问了“坏”网站</h5><h5 id="4）“坏”网站有一个向银行网站提交业务请求的页面"><a href="#4）“坏”网站有一个向银行网站提交业务请求的页面" class="headerlink" title="4）“坏”网站有一个向银行网站提交业务请求的页面"></a>4）“坏”网站有一个向银行网站提交业务请求的页面</h5><h5 id="5）诱使用户发送这个请求。"><a href="#5）诱使用户发送这个请求。" class="headerlink" title="5）诱使用户发送这个请求。"></a>5）诱使用户发送这个请求。</h5><p>实际上利用有 XSS 漏洞，完全可以无需受害者参与利用 javascript 而自动触发第 4 第 5 步。</p>
<h4 id="这个场景背后有些逻辑："><a href="#这个场景背后有些逻辑：" class="headerlink" title="这个场景背后有些逻辑："></a><strong>这个场景背后有些逻辑：</strong></h4><p>这里我们把浏览器等同于用户，有些数据是用户自己可见的，有些数据是浏览器自动处理、发送而用户对这些数据是无感知的（比如 SessionId）。<br>银行网站以 cookie 的形式把 sessionId 发送给浏览器（set-cookie），浏览器每次请求都会再自动带上 cookie（cookie）。<br>上面场景第 5 步虽然“坏”表单不是源于银行网站页面而是在第三方网站的页面上，但是<strong>浏览器</strong>发现目标地址是银行网站，因此会自动带上响应的 cookie，比如 JSESSION 就会随带着被发送了。从服务器的角度看，来自第 4 步的数据与正常数据没有任何差别，因为这个业务请求便会被执行。</p>
<p>归根结底，这种 CSRF 的问题是 cookie 和浏览器工作方式引起的。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>一个是主流的“Synchronizer Token Pattern”方法，另一个是渐成主流的“SameSite Attribute”。</p>
<p>因为<strong>SameSite Attribute</strong>的方式实施和理解比较容易，我们先说。<br>服务端利用 cookie 的 SameSite 属性可以禁止浏览器从外部站点发送请求时带上 cookie。比如下面的 cookie 就不会被放在由在第三方网页发起而目标是银行网站的请求上。这就自然解决了上面的 CSRF 的问题。</p>
<pre><code>Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax
</code></pre>
<p><strong>Synchronizer Token Pattern</strong><br>这个解决办法的原理是对来自浏览器的请求我们都回送一个随机数，下次浏览器再请求业务时需要在 header 里或者表单里带上这个随机数。这个随机数就是 csrf token。<br>这个办法之所以能防范 CSRF，是因为 sessionId 来自 cookie，而 csrf token 来自 header 或者 form。相当于分别在两条不同的路径上传递。</p>
<p>Spring Security 模块生成 csrf token 后可放在两个地方。Spring 默认的，随机数与 sessionId 关联，放在 session 里。另一个方式：随机数放在 cookie 里。</p>
<h3 id="基于-Session-保存-csrf-token"><a href="#基于-Session-保存-csrf-token" class="headerlink" title="基于 Session 保存 csrf token"></a>基于 Session 保存 csrf token</h3><p>与 session 关联比较容易理解，下次浏览器发送请求过来，服务端就可以从 header 或 form 里取出来的 csrf token 与 session 中的随机数相比较来进行判断。</p>
<h3 id="基于-Cookie-保存-csrf-token"><a href="#基于-Cookie-保存-csrf-token" class="headerlink" title="基于 Cookie 保存 csrf token"></a>基于 Cookie 保存 csrf token</h3><p>通过 cookie 保存 csrf 是怎么回事呢？如果 csrf token 通过 cookie 发送给浏览器，那这个随机数不就跟 JSESSIONID 一样了会被浏览器自动传回到服务器了吗？<br>是的，这个 csrf 会被浏览器传回给服务器，我们也正是利用这一点“保存”了 csrf token。之所以使用基于 cookie 的方式，是因为要针对前后端分离的情形让前端可以使用 javascript 获得 csrf token，并把这个 token 作为下次请求的 header 参数或者 form 参数传递给服务端。服务端所要做的就是对比来自 cookie 的 csrf token 和来自 header/form 里的 csrftoken 来做出判断。</p>
<p>下面代码设置使用 cookie 保存，注意使用 cookie 传递 token 需要把 cookie 的 HttpOnly 属性设置为 false，以便让 javascript 能读到此值。</p>
<pre><code>@EnableWebSecurity
public class WebSecurityConfig extends
        WebSecurityConfigurerAdapter &#123;

    @Override
    protected void configure(HttpSecurity http) &#123;
        http
            .csrf(csrf -&gt; csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            );
    &#125;
&#125;
</code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/4/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="as_sitesearch" value="dhyuan.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/AWS/">AWS</a><small>2</small></li>
  
    <li><a href="/tags/CAS/">CAS</a><small>5</small></li>
  
    <li><a href="/tags/Concurrency/">Concurrency</a><small>6</small></li>
  
    <li><a href="/tags/DevOps/">DevOps</a><small>31</small></li>
  
    <li><a href="/tags/FP/">FP</a><small>2</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
  
    <li><a href="/tags/Ingerss/">Ingerss</a><small>1</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>10</small></li>
  
    <li><a href="/tags/Kubernetes/">Kubernetes</a><small>3</small></li>
  
    <li><a href="/tags/Maven/">Maven</a><small>2</small></li>
  
    <li><a href="/tags/MicroService/">MicroService</a><small>3</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>6</small></li>
  
    <li><a href="/tags/Nginx/">Nginx</a><small>2</small></li>
  
    <li><a href="/tags/Reactive/">Reactive</a><small>8</small></li>
  
    <li><a href="/tags/SAGA/">SAGA</a><small>1</small></li>
  
    <li><a href="/tags/Scala/">Scala</a><small>7</small></li>
  
    <li><a href="/tags/Security/">Security</a><small>12</small></li>
  
    <li><a href="/tags/Spring/">Spring</a><small>14</small></li>
  
    <li><a href="/tags/android/">android</a><small>1</small></li>
  
    <li><a href="/tags/network/">network</a><small>2</small></li>
  
    <li><a href="/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><small>13</small></li>
  
    <li><a href="/tags/%E7%BD%91%E4%B8%8A%E5%A5%BD%E6%96%87/">网上好文</a><small>1</small></li>
  
  </ul>
</div>


  
  <div class="widget widget-archives">
    <h3 class="title">归档</h3>
    <div class="entry">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2025 Dahui
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
