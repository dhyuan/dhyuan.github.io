<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>第 5 页 | 浅流</title>
  <meta name="author" content="Dahui">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="浅流"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">浅流</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-notes/spring_tech4framework" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-12-13T08:48:43.000Z"><a href="/2020/12/13/notes/spring_tech4framework/">2020-12-13</a></time>
      
      
  
    <h1 class="title"><a href="/2020/12/13/notes/spring_tech4framework/">Spring 中的常用定式</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h4 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h4><p>对于 Restful API 来说，就是通过 RestCongtrollerAdvisor 注解实现。<br>对于 Spring MVC 来说，通过继承 ErrorController 实现 handleError()来实现统一 excepiton 处理。</p>
<p>就 Rest API 应用来说，一般把响应统一封装，常见的是封装成 BaseResponse of T。这种范型方式的使用对于 Feign 这种方式的 API 来说存在问题。<br>因为 Feign 是通过使用动态代理来执行请求 HTTP 服务、转换响应到对象的。而范型在运行时类型信息被擦除，所以 BaseResponse<T> 不能和 Feign 一起使用。</p>
<p>对于 BaseResponse，基本就是封装三个元素：resultCode、message、data、（exception）。对于 resultCode 可以结合 javax.servlet.http.HttpServletResponse 中定义的状态码来定义。</p>
<h4 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h4><h4 id="Feign-强类型客户端"><a href="#Feign-强类型客户端" class="headerlink" title="Feign 强类型客户端"></a>Feign 强类型客户端</h4><p>使用 Feign 基本就是两个步骤：<br>1）在启动类标注 @EnableFeignClient<br>2）在客户端类标注 @FeignClient(SERVICE_NAME) 并在方法名上标注@RequestMapping。<br>Feign 的实现就是通过使用动态代理来执行请求 HTTP 服务、转换响应到对象。也算是强类型的一种客户端。</p>
<h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><h4 id="利用线程池的异步处理"><a href="#利用线程池的异步处理" class="headerlink" title="利用线程池的异步处理"></a>利用线程池的异步处理</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="Swagger-RestDoc"><a href="#Swagger-RestDoc" class="headerlink" title="Swagger / RestDoc"></a>Swagger / RestDoc</h4>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-notes/about_shiro_path_filter" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-12-10T15:23:29.000Z"><a href="/2020/12/11/notes/about_shiro_path_filter/">2020-12-11</a></time>
      
      
  
    <h1 class="title"><a href="/2020/12/11/notes/about_shiro_path_filter/">关于Shiro中路径匹配与注解</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>Shiro 针对web的安全防护主要是通过各种Filter的操作完成的。其中 PathMatchingFilter来完成</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-Gradle-101" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-12-02T14:42:01.000Z"><a href="/2020/12/03/Gradle-101/">2020-12-03</a></time>
      
      
  
    <h1 class="title"><a href="/2020/12/03/Gradle-101/">Gradle 101</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <ol>
<li><p>确保团队使用统一的 gradle 版本。<br> 避免 Gradle 的版本兼容性问题，项目中应使用 gradldw 命令运行。因为 gradlew 会根据 gradle-wrapper.properties 定义的 gradle 分发 dizhi 去下载 gradle 到本地。</p>
<p> 在 build.gradle 中定义如下 task，生成两个文件：gradlew、gradlew.bat，一个目录：gradle。</p>
<pre><code> task genWrapper(type: Wrapper)&#123;
   gradleVersion=&#39;5.3.1&#39;
   distributionUrl=&#39;https://services.gradle.org/distributions/gradle-5.3.1-all.zip&#39;
   distributionBase=&#39;GRADLE_USER_HOME&#39;
   distributionPath=&#39;wrapper/dists&#39;
   archiveBase=&#39;GRADLE_USER_HOME&#39;
   archivePath=&#39;wrapper/dists&#39;
 &#125;
</code></pre>
<p> 对于不能访问互联网的内网，需要保证 distributionUrl 地址在私服上可用。执行 gradle genWrapper 后，把生成的内容作为项目文件提交到代码库。</p>
<p> 这样后面的同事，checkout 出代码后遵循使用 gradlew 构建项目的规则就可以避免 gradle 版本冲突的问题了。</p>
</li>
<li><p>Spring Boot 2.4 gradle 插件是需要 Gradle5.6 以上 或 Gradle6.3 版本以上的，否则报错如下。这也从一个方面证明 gradle 版本兼容问题是存在的，所以很有必要在团队中使用 gradlew。</p>
<p> An exception occurred applying plugin request [id: ‘org.springframework.boot’, version: ‘2.4.0’]</p>
<blockquote>
<p>Failed to apply plugin [id ‘org.springframework.boot’]<br>Spring Boot plugin requires Gradle 5 (5.6.x only) or Gradle 6 (6.3 or later). The current version is Gradle 5.3.1</p>
</blockquote>
</li>
</ol>
<p>Reference:</p>
<p>基本元素：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/itck/p/10478382.html">https://www.cnblogs.com/itck/p/10478382.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36850813/article/details/93996333">https://blog.csdn.net/qq_36850813/article/details/93996333</a></p>
<p>wrapper：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/davenkin/p/gradle-spring-boot.html">https://www.cnblogs.com/davenkin/p/gradle-spring-boot.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-开发环境setup" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-11-28T07:47:43.000Z"><a href="/2020/11/28/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83setup/">2020-11-28</a></time>
      
      
  
    <h1 class="title"><a href="/2020/11/28/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83setup/">开发环境setup</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h3 id="在-macOS-上安装-OpenJDK。"><a href="#在-macOS-上安装-OpenJDK。" class="headerlink" title="在 macOS 上安装 OpenJDK。"></a>在 macOS 上安装 OpenJDK。</h3><pre><code>brew tap AdoptOpenJDK/openjdk
brew search /adoptopenjdk
brew cask install adoptopenjdk8
</code></pre>
<h3 id="设置-Homebrew-使用国内源，加速-update"><a href="#设置-Homebrew-使用国内源，加速-update" class="headerlink" title="设置 Homebrew 使用国内源，加速 update"></a>设置 Homebrew 使用国内源，加速 update</h3><pre><code>cd /usr/local/Homebrew
git remote set-url origin http://mirrors.ustc.edu.cn/homebrew.git
</code></pre>
<h3 id="变更-Win10-上基于-WSL2-的-Docker-镜像位置"><a href="#变更-Win10-上基于-WSL2-的-Docker-镜像位置" class="headerlink" title="变更 Win10 上基于 WSL2 的 Docker 镜像位置"></a>变更 Win10 上基于 WSL2 的 Docker 镜像位置</h3><p>1）停止 Docker desktop<br>2）停止 WSL</p>
<pre><code>  wsl --shutdown
</code></pre>
<p>3）迁移</p>
<pre><code>wsl --export docker-desktop-data D:\docker\docker-desktop-data\docker-desktop-data.tar
wsl --unregister docker-desktop-data
wsl --import docker-desktop-data D:\docker\ D:\docker\docker-desktop-data\docker-desktop-data.tar --version 2
</code></pre>
<h3 id="运行-MySQL-docker-image"><a href="#运行-MySQL-docker-image" class="headerlink" title="运行 MySQL docker image"></a>运行 MySQL docker image</h3><pre><code>docker pull mysql:8.0.22
docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 \
 -v /home/mysql/conf/my.cnf:/etc/mysql/my.cnf \
 -v /home/mysql/logs:/logs \
 -v /home/mysql/data/mysql:/var/lib/mysql \
 -d mysql:8.0.22
</code></pre>
<h3 id="设置-MySQL-root-用户可以远程登录"><a href="#设置-MySQL-root-用户可以远程登录" class="headerlink" title="设置 MySQL root 用户可以远程登录"></a>设置 MySQL root 用户可以远程登录</h3><pre><code>docker run -it --rm mysql bash
ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;
</code></pre>
<h3 id="运行-MySQL-docker-image-1"><a href="#运行-MySQL-docker-image-1" class="headerlink" title="运行 MySQL docker image"></a>运行 MySQL docker image</h3><p>docker run -p 6379:6379 –name redis -v /Users/dahui/docker_env/redis/redis.conf:/etc/redis/redis.conf -v /Users/dahui/docker_env/redis/data:/data -d redis redis-server /etc/redis/redis.conf –appendonly yes –requirepass “password”</p>
<p>–appendonly yes ： 开启 redis 持久化<br>–requirepass “password” ： 密码</p>
<p>docker run –name redis -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 \n -v /Users/dahui/docker_env/mysql/conf/my.cnf:/etc/mysql/my.cnf \n -v /Users/dahui/docker_env/mysql/logs:/logs \n -v /Users/dahui/docker_env/mysql/mysql/data/mysql:/var/lib/mysql \n -d mysql:8.0.22</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-reactive/popular_reactive_libs" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-10-12T14:05:29.000Z"><a href="/2020/10/13/reactive/popular_reactive_libs/">2020-10-13</a></time>
      
      
  
    <h1 class="title"><a href="/2020/10/13/reactive/popular_reactive_libs/">Reactive Streams规范及常见库</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="什么是Reactive-Streams"><a href="#什么是Reactive-Streams" class="headerlink" title="什么是Reactive Streams:"></a>什么是<a target="_blank" rel="noopener" href="https://www.reactive-streams.org/">Reactive Streams</a>:</h2><blockquote>
<p>Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure. This encompasses efforts aimed at runtime environments (JVM and JavaScript) as well as network protocols.</p>
</blockquote>
<p>概括的说，Reactive Streams 是个(Java 世界里的)规范，它规范了“有非阻塞背压机制的异步的流处理”。挺简单的定义，但是能够真正正确理解异步、非阻塞并不容易，以后单独开写一篇。实际上 Reactive Streams 规范或者说其实现包含的内容更加丰富：除了 non-blocking，还有：Composable、Deferred、Flow Controll、Resilient、Interruptible。</p>
<p>其中 Composable 就是函数式编程思想的用武之地。 可体会下 Java8 里的 Stream API 各种算子的参数，所以 Lamda 表达式是进行 Reactive Streams 实现的基本前提，否则很难想象臃肿的面向对象的 Composable。有了 JDK8 的铺垫，Reactive Streams 接口被 JDK9 定义在 Flow 里才是可能的。</p>
<blockquote>
<p>As of August 23rd, 2019 we have released version 1.0.3 of Reactive Streams for the JVM, including Java API, a textual Specification, a TCK and implementation examples.</p>
</blockquote>
<p>这个规范由三部分组成：Java API（org.reactive-streams）、以文字描述的规范、技术兼容工具包。<br>Reactive Streams 规范 仅限于 Java（JavaScript、网络协议）世界，其它语言虽然也有 Reactive 这样的工具<a target="_blank" rel="noopener" href="https://github.com/ReactiveX">（参考这里： ReactiveX）</a>实现，但好像没有类似的规范。</p>
<h2 id="为什么要有-Reactive-Streams"><a href="#为什么要有-Reactive-Streams" class="headerlink" title="为什么要有 Reactive Streams"></a>为什么要有 Reactive Streams</h2><p>因为很多厂商开发了 reactive 库，但是它们直接很难/不可能互操作。用 Reactive Streams 进行规范就使得它们可以互操作，也就让它们串起来形成一个 reactive 链成为了可能。</p>
<h2 id="为什么要用-Reactive"><a href="#为什么要用-Reactive" class="headerlink" title="为什么要用 Reactive"></a>为什么要用 Reactive</h2><p>因为 reactive 可以榨干 CPU…，所以从老板的角度讲是省钱、从环保的角度讲是省电、从码农的角度讲是有意思。</p>
<h2 id="Java-世界里的-Reactive-库"><a href="#Java-世界里的-Reactive-库" class="headerlink" title="Java 世界里的 Reactive 库"></a>Java 世界里的 Reactive 库</h2><h3 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a><strong>RxJava</strong></h3><p>从 Reactive 宣言、到 Reactive Streams 规范，再到各种 Reactive 库是很自然的一个脉络。<br>但现实是大家先有了 Reactive 系统的思想，聪明的程序员开发出各种蕴含着 reactive 思想的库(比如 RxJava 1.0)。为了各个库之间的统一性、可操作行，大家一起协商出了 Reactive Streams 规范。继而这些已经存在的 reactive 库便改进自己的 API 设计，向 reactive streams 规范靠拢并提供各种转化 api 让用户在原生 api 和 reactive streams 接口直接转换。比如 RxJava 2.0 的 Flowable 就直接继承自 org.reactive-streams.Publisher 并提供了 toObservable() toFlowable()。因为各个库的实现细节不同，用到具体转换 api 需要参考其手册。</p>
<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a><strong>JDK</strong></h3><p>这个规范被的 API 形式定义从 JDK 9 这个版本开始，以 java.util.concurrent.Flow 静态子类的形式被定义。其实，既然已经有了 org.reactive-streams 这样的规范，为什么还要在 JDK 中弄出个 Flow 来再重新定义一次。难道就是要宣示 JDK 自身有支持 reactive streaming 的东西？这个思路的本意应该就像 JDBC 接口一样，让 Flow 里定义的接口成为 SPI，让不同的 reactive sreams 库供应商可互操作吧。所以 JDK 里的 Flow 中定义的东西不能算是库，而是个 SPI：Service Provider Interface。</p>
<h3 id="Vert-x、MongoDB-响应式流驱动"><a href="#Vert-x、MongoDB-响应式流驱动" class="headerlink" title="Vert.x、MongoDB 响应式流驱动"></a><strong>Vert.x、MongoDB 响应式流驱动</strong></h3><p>这些都做了改进以符合 org.reactive-streams 中的 API 定义。其中<a target="_blank" rel="noopener" href="https://vertx.io/">Vert.x</a>不仅提供了对 java 的 reactive 库，还有 JavaScritp、Ruby、Scala 等。</p>
<h3 id="Spring-的-Project-Reactor"><a href="#Spring-的-Project-Reactor" class="headerlink" title="Spring 的 Project Reactor"></a><strong>Spring 的 Project Reactor</strong></h3><p>Project Reactor 主页：<a target="_blank" rel="noopener" href="https://projectreactor.io/docs/core/release/reference/">https://projectreactor.io/docs/core/release/reference/</a><br>既然 Spring 都提供了对 Reactive Streams 的实现，感觉其实上面列出的几个库已经没有太多的意义。各家对 Reactive Streams 规范的实现在细节上都有很大不同，因为 Spring 的生态太强大了，如果没有特殊的需求，比如 JDK 小于 8，那么我们的项目基本于 Project Reactor，那么应该是较好的选择。这个网页 <a target="_blank" rel="noopener" href="https://tech.io/playgrounds/929/reactive-programming-with-reactor-3/Intro">https://tech.io/playgrounds/929/reactive-programming-with-reactor-3/Intro</a> 可以帮助操练 Reactor Api。</p>
<p>Project Reactor 到目前为止经历了 1.0, 2.0, 3.3。其中 1.0 这个阶段还没有 Reactive Stream 是规范。在 2.0 开始 follow 规范并基本定型。3.0 感觉是个重构版，形成 reactive-streams-commons 库。这里是 3.0 的 release 文档: <a target="_blank" rel="noopener" href="https://github.com/reactor/reactor-core/releases?after=v3.0.0.RELEASE">https://github.com/reactor/reactor-core/releases?after=v3.0.0.RELEASE</a> 。</p>
<p>有了 Project Reactor 这样的基础库，整个 Spring 组件基本都有了 Reactive Style 的版本，再这个基础上<br>用 Netty（或 Servet 3.1 Containe）+ Reactive Streams 适配层 + Spring Security Reactive + WebFlux + Spring Data Reactive Repository，就可以构建出重头到尾的 Reactive 应用。</p>
<p>从 Spring Cloud 的组件角度讲，也衍生出 Reactive Discovery Client, Reactive Load Balancer, Blockhound, Reactor Debug, Improved Reactor Micrometer Support, Reactor Netty Metric …</p>
<p>Stephane 是实现 Project Reactor 的主力，下面是他的两个视频：​<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Tr04KiJdAXQ">https://www.youtube.com/watch?v=Tr04KiJdAXQ</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=zls8ZLry68M">https://www.youtube.com/watch?v=zls8ZLry68M</a></p>
<h2 id="其它编程语言的-Reative-库"><a href="#其它编程语言的-Reative-库" class="headerlink" title="其它编程语言的 Reative 库"></a>其它编程语言的 Reative 库</h2><p>其它编程语言的 Reative 库可参考：<a target="_blank" rel="noopener" href="https://github.com/ReactiveX">https://github.com/ReactiveX</a><br>另，Akka Stream：<a target="_blank" rel="noopener" href="https://doc.akka.io/docs/akka/current/stream/stream-introduction.html">https://doc.akka.io/docs/akka/current/stream/stream-introduction.html</a></p>
<p><em>Reference:</em><br><a target="_blank" rel="noopener" href="https://www.reactive-streams.org/">https://www.reactive-streams.org/</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Cj4foJzPF80&amp;list=PLVoESeXbuo-yWN1HW5g45v6eGEPOcfWU0&amp;index=4&amp;t=2940s">https://www.youtube.com/watch?v=Cj4foJzPF80&amp;list=PLVoESeXbuo-yWN1HW5g45v6eGEPOcfWU0&amp;index=4&amp;t=2940s</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-reactive/about_reactive_stream" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-10-06T14:12:12.000Z"><a href="/2020/10/07/reactive/about_reactive_stream/">2020-10-07</a></time>
      
      
  
    <h1 class="title"><a href="/2020/10/07/reactive/about_reactive_stream/">从观察者模式到reactive stream规范</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>Reactive 的系统就是通过实现回弹性、弹性能够对客户请求进行及时响应的系统。</p>
<p>正如 Reactive Manifesto 说的：</p>
<blockquote>
<p>Systems built as Reactive Systems are more flexible, loosely-coupled and scalable.</p>
</blockquote>
<p>说到松耦合，最基本的模式之一就算是“观察者模式”了。从观察者模式更进一步，可以衍生出“发布订阅模式”。较之前者，发布订阅模式多了一个‘事件通道’的角色。通过这个通道，使得订阅者不必知道发布者——即两者解耦。Spring 在应用层面对“发布-订阅”模式进行了不错的支持(同步的、异步的)，诸如@EventListener 等的日常用法参见：<br><a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-events">https://www.baeldung.com/spring-events</a><br><a target="_blank" rel="noopener" href="https://reflectoring.io/spring-boot-application-events-explained/">https://reflectoring.io/spring-boot-application-events-explained/</a></p>
<p><strong>响应式流 = 观察者 + 迭代器</strong></p>
<p>从 Iterator 定义看，这是一个“拉”模型，当我们需要数据时通过调用 next()拉取，hasNext()是查询是否还有数据可用。如果上游数据有什么异常情况，只能是通过 next()抛出的异常感知甚至感知不知道。<br>public interface Iterator<E> {<br>E next();<br>boolean hasNext();<br>}</p>
<p>以 RxJava 的 RxObserver 为例，感受下其接口语义上的改进：</p>
<pre><code>public interface RxObserver&lt;T&gt; &#123;
  void onNext(T next);
  void onComplete();
  void onError();
&#125;
</code></pre>
<p>以 on 形式的前缀开头的方法名让我很明显的感受到一种“通知”的味道。上游组件告诉我们有新数据了、结束了、出错了！一种“推”的味道。</p>
<p>演进到这一步是不是就完美了呢？不。<br>如果 RxObserver 与上游组件是跨网络通信，那么我们可以想象每次的 onNext 通过网络一次处理一个数据的这种模式并不高效。而且 RxObserver 不能想上游表达自己的需求(比如需要几个数据？不再需要数据等)，这就很容易延伸到 RxObserver 作为消费者的处理速度与上游不匹配时如何与上游协调工作这样的问题。<br>Reactive Stream 规范对以上需求进行了标准化，如下。其中 Subscription 就可用于向上游 Publisher 表达是否还需要、需要多少数据这样的请求。如果每次 request(1)，整个模式就相当于“拉”模型；request(Integer.MAX_VALUE)就相当于“推”模型了。</p>
<pre><code>public interface Publisher&lt;T&gt; &#123;
    public void subscribe(Subscriber&lt;? super T&gt; s);
&#125;

public interface Subscriber&lt;T&gt; &#123;
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
&#125;

public interface Subscription &#123;
    public void request(long n);
    public void cancel();
&#125;

public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; &#123;
&#125;
</code></pre>
<hr>
<p><em>Reference：</em></p>
<p><a target="_blank" rel="noopener" href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md">https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md</a></p>
<p><a target="_blank" rel="noopener" href="http://reactivex.io/">http://reactivex.io/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=WKore-AkisY&list=PLVoESeXbuo-yWN1HW5g45v6eGEPOcfWU0&index=14">A Playful Introduction to Rx by Erik Meijer</a></p>
<p><a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-events">https://www.baeldung.com/spring-events</a><br><a target="_blank" rel="noopener" href="https://reflectoring.io/spring-boot-application-events-explained/">https://reflectoring.io/spring-boot-application-events-explained/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-reactive/about_reactive_manifesto" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-10-05T12:36:22.000Z"><a href="/2020/10/06/reactive/about_reactive_manifesto/">2020-10-06</a></time>
      
      
  
    <h1 class="title"><a href="/2020/10/06/reactive/about_reactive_manifesto/">关于 Reactive Manifesto</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>反应 or 响应？还是反应吧。Reactive Manifesto 的中文版都已经是“反应式宣言”了。看来公众号也要择机改名了。</p>
<p>反应式宣言英文版：<a target="_blank" rel="noopener" href="https://www.reactivemanifesto.org/">https://www.reactivemanifesto.org/</a><br>反应式宣言中文版：<a target="_blank" rel="noopener" href="https://www.reactivemanifesto.org/zh-CN">https://www.reactivemanifesto.org/zh-CN</a></p>
<p>前几年开始看到这些没有一行代码的宣言感觉好飘渺，但是随着自己看的代码、用的代码慢慢多起来，感觉这个宣言蛮不简单的。说上去就是这个几个词、几句话，但在实际项目中往往都对应着某个解决方案的思想原则。</p>
<p><img src="/2020/10/05/reactive/about_reactive_manifesto/reactive-traits.png" alt="反应式"></p>
<p>反应式宣言最关键的四个单词：Responsive、Resilient、Elastic、Message Driven。<br>其中<strong>Reponsive</strong>是我们的终极目标，我们理想的系统是能对用户的请求尽可能地做出及时的响应。因为一个系统如果没有响应了基本就意味挂了，因此能够及时响应用户的请求是一个系统健康运行的标志。<br>系统要满足可响应的特性，那么这个系统就应该能够有：“回弹性”<strong>Resilient</strong>、“弹性”<strong>Elastic</strong>。</p>
<p><strong>Resilient</strong>——回弹性，强调的是系统的子模块出现问题时系统仍旧能够响应客户请求。</p>
<blockquote>
<p>回弹性是通过复制、 遏制、 隔离以及委托来实现的。</p>
</blockquote>
<p>举个例子来说“隔离”，Spring Cloud 的 Hystrix 断路器模式就是使用了<strong>隔离</strong>的思路。被@HystrixCommand 标注了的方法实际上是被 spring 动态生成的代理包装并由一个单独的线程池上的线程驱动运行。这样如果被@HystrixCommand 标注的方法出现了问题，不会直接影响调用方。系统框架从更高的层次就能感知到这个调用失败从而进行必要的处理。</p>
<p><strong>Elastic</strong>——弹性，强调的是系统的负载发生变化时系统能够响应客户请求。之所以这里不用 Scalable，是想强调这里的负载可以是变大也可以是变小。</p>
<p><strong>Message Driven</strong>——消息驱动，因为消息驱动的特点，它是天然实现回弹性、弹性的技术手段。</p>
<blockquote>
<p>Reactive Systems rely on asynchronous message-passing to establish a boundary between components that ensures loose coupling, isolation and location transparency.</p>
</blockquote>
<p>反应式系统依赖异步地消息传递机制在组件间建立边界，这就保证了组件之间的松耦合、隔离、以及位置透明。【感觉官方中文版翻译的有问题 ：）】</p>
<p>组件之间的松耦合、隔离、位置透明是实现回弹性、回弹的条件。消息驱动是实现这些特性的很好的技术手段，但不是唯一的手段，比如就位置透明这点来说：Spring Cloud 的服务就是通过服务注册[使能 Eureka 服务、在服务的 bootstrap 文件中把服务注册到 Eureka]、服务发现[1, 原始的 EnableDiscoveryClient 到 2，@LoadBalanced+直接使用服务名的 rest template exchange]来对客户端实现了位置透明性。</p>
<p>从 Message Driven（异步非阻塞的消息）这点来讲，AKKA 才是最优的解决方案。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/install_dashboard_for_k8s_cluster" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-09-30T03:21:02.000Z"><a href="/2020/09/30/devops/install_dashboard_for_k8s_cluster/">2020-09-30</a></time>
      
      
  
    <h1 class="title"><a href="/2020/09/30/devops/install_dashboard_for_k8s_cluster/">安装k8s的Dashboard</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>安装 Dashboard 相较之前的步骤就容易很多了。</p>
<h3 id="下载-Dashboard-yaml"><a href="#下载-Dashboard-yaml" class="headerlink" title="下载 Dashboard yaml"></a>下载 Dashboard yaml</h3><p>这里使用 Dashboard 2.0.4。</p>
<pre><code>wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.4/aio/deploy/recommended.yaml

vi recommended.yml

# 设置node port，让集群外部通过node port可以访问Dashboard
    nodePort: 30443
type: NodePort
</code></pre>
<p><img src="/2020/09/30/devops/install_dashboard_for_k8s_cluster/dashboard_node_port.png" alt="Dashboard Home Page"></p>
<h3 id="安装-Dashboard"><a href="#安装-Dashboard" class="headerlink" title="安装 Dashboard"></a>安装 Dashboard</h3><pre><code>kubectl apply -f recommended.yaml
kubectl get pods -n kubernetes-dashboard
</code></pre>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>此时访问 <a target="_blank" rel="noopener" href="http://master_node_ip:30443/">http://master_node_ip:30443</a> 并用 kubeadmin init 输出的 token 可以登录到 Dashboard 管理界面。</p>
<h3 id="创建-Dashboard-专用登录用户"><a href="#创建-Dashboard-专用登录用户" class="headerlink" title="创建 Dashboard 专用登录用户"></a>创建 Dashboard 专用登录用户</h3><pre><code># 创建用户 devops
kubectl create serviceaccount devops -n kube-system

# 授权
kubectl create clusterrolebinding devops --clusterrole=cluster-admin --serviceaccount=kube-system:devops

kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk &#39;/devops/&#123;print $1&#125;&#39;)
</code></pre>
<p>访问 <a target="_blank" rel="noopener" href="http://master_node_ip:30443/">http://master_node_ip:30443</a> 并用 devops 的 token 登录。</p>
<p><img src="/2020/09/30/devops/install_dashboard_for_k8s_cluster/dashboard_home_page.png" alt="kubelet up"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/create_k8s_by_kubeadm" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-09-28T07:23:52.000Z"><a href="/2020/09/28/devops/create_k8s_by_kubeadm/">2020-09-28</a></time>
      
      
  
    <h1 class="title"><a href="/2020/09/28/devops/create_k8s_by_kubeadm/">使用kubeadm创建K8S单控制节点集群</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>在对 K8S 控制节点有 HA 方面需求的话，应考虑 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/</a> 提到的两种拓扑。</p>
<p>HA 的方式除了让 controll nodes 和 etcd 有多个节点外，另外一个就是对外需要 VIP + LoadBalance 的功能。<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubeadm/blob/master/docs/ha-considerations.md#options-for-software-load-balancing">https://github.com/kubernetes/kubeadm/blob/master/docs/ha-considerations.md#options-for-software-load-balancing</a> 讲述了如果使用 keepalived 和 haproxy 来实现这个前提。这个连接讲述了三个部署 keepalive, haproxy 的方式。推荐还是使用第二或第三种，第一种方式仅作为我们理解背后工作的逻辑就好。</p>
<p>因为这里只是开发环境使用的 k8s，所以就不以 HA 的方式安装 k8s 了。。无非就是多了两个步骤：<br>1）准备 VIP/LB;<br>2）kubeadm –init 时，用–control-plane flag 添加其它 CP 节点而已）。</p>
<h2 id="1）为-kubeadm-准备虚拟机和-docker"><a href="#1）为-kubeadm-准备虚拟机和-docker" class="headerlink" title="1）为 kubeadm 准备虚拟机和 docker"></a>1）为 kubeadm 准备虚拟机和 docker</h2><h3 id="准备开发用-KVM-HOST-并-创建网桥"><a href="#准备开发用-KVM-HOST-并-创建网桥" class="headerlink" title="准备开发用 KVM HOST 并 创建网桥"></a>准备开发用 KVM HOST 并 创建网桥</h3><p>步骤参考：<br>a) 准备 kvm：<a href="https://dhyuan.github.io/2020/09/19/devops/create_gust_hosts_on_kvm_by_ansible/">https://dhyuan.github.io/2020/09/19/devops/create_gust_hosts_on_kvm_by_ansible/</a><br>b) 创建网桥：<a href="https://dhyuan.github.io/2020/09/21/devops/create_bridge_on_centos7/">https://dhyuan.github.io/2020/09/21/devops/create_bridge_on_centos7/</a></p>
<h3 id="下载创建虚拟机的-CentOS7-镜像"><a href="#下载创建虚拟机的-CentOS7-镜像" class="headerlink" title="下载创建虚拟机的 CentOS7 镜像"></a>下载创建虚拟机的 CentOS7 镜像</h3><pre><code>curl -O https://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2

sudo mv -iv CentOS-7-x86_64-GenericCloud.qcow2 /var/lib/libvirt/images/
</code></pre>
<h3 id="得到一键安装-GuestHost-和-Docker-的-ansible-脚本。"><a href="#得到一键安装-GuestHost-和-Docker-的-ansible-脚本。" class="headerlink" title="得到一键安装 GuestHost 和 Docker 的 ansible 脚本。"></a>得到一键安装 GuestHost 和 Docker 的 ansible 脚本。</h3><p>注意这里是使用分支 devenv 上的代码。</p>
<pre><code>cd ~/devenv_bootstrap
git clone -b devenv https://github.com/dhyuan/virt-infra-ansible.git

cd ~/devenv_bootstrap/virt-infra-ansible/roles
git clone -b devenv https://github.com/dhyuan/ansible-role-virt-infra

ansible-galaxy install \
--roles-path ~/.ansible/roles/ \
git+https://github.com/haxorof/ansible-role-docker-ce.git,2.7.0
</code></pre>
<h3 id="根据自己的需求修改-K8S-master、nodes-节点的主机配置。"><a href="#根据自己的需求修改-K8S-master、nodes-节点的主机配置。" class="headerlink" title="根据自己的需求修改 K8S master、nodes 节点的主机配置。"></a>根据自己的需求修改 K8S master、nodes 节点的主机配置。</h3><p>注意：节点名称已经改为使用-而不是_以符合 DNS 规范。这点是 K8S 的要求，但是和 yaml 的格式规范使用下划线有点而冲突。</p>
<pre><code>cd ~/devenv_bootstrap
vi inventory/k8s-masters.yml
vi inventory/k8s-nodes.yml
</code></pre>
<h3 id="一键创建-master-nodes-虚拟机"><a href="#一键创建-master-nodes-虚拟机" class="headerlink" title="一键创建 master + nodes 虚拟机"></a>一键创建 master + nodes 虚拟机</h3><pre><code>ansible-playbook ./virt-infra.yml \
    --limit kvmhost,k8s-masters,k8s-nodes
</code></pre>
<h3 id="一键在-master、nodes-节点上安装-docker"><a href="#一键在-master、nodes-节点上安装-docker" class="headerlink" title="一键在 master、nodes 节点上安装 docker"></a>一键在 master、nodes 节点上安装 docker</h3><pre><code>ansible-playbook ./install_docker.yml \
--limit k8s-masters,k8s-nodes -v \
-e &#39;&#123;&quot;docker_repository_url&quot;: &#123;&quot;CentOS&quot;: &quot;http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&quot;&#125;&#125;&#39;
</code></pre>
<h3 id="验证环境"><a href="#验证环境" class="headerlink" title="验证环境"></a>验证环境</h3><p>在 KVM HOST 查看/etc/hosts 里面记录了各个主机节点 IP。<br>各节点互相 ping<br>登录到各主机检查 docker 引擎是否工作正常。<br><img src="/2020/09/28/devops/create_k8s_by_kubeadm/guest_hosts_created.png"></p>
<h2 id="2）安装-kubeadm，此步骤需要在各个-master、nodes-节点执行。"><a href="#2）安装-kubeadm，此步骤需要在各个-master、nodes-节点执行。" class="headerlink" title="2）安装 kubeadm，此步骤需要在各个 master、nodes 节点执行。"></a>2）安装 kubeadm，此步骤需要在各个 master、nodes 节点执行。</h2><p>下面基本参照官网 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/</a> 以及另阿良的<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/8JznAEKe6b-wE-kNx7_Svg">https://mp.weixin.qq.com/s/8JznAEKe6b-wE-kNx7_Svg</a> 来进行。</p>
<h3 id="设置-kubernets-yum-源"><a href="#设置-kubernets-yum-源" class="headerlink" title="设置 kubernets yum 源"></a>设置 kubernets yum 源</h3><pre><code>cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
# 使用阿里源
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg

enabled=1
gpgcheck=0
repo_gpgcheck=0
exclude=kubelet kubeadm kubectl
EOF
</code></pre>
<h3 id="确保将桥接的-IPv4-流量传递到-iptables-的链："><a href="#确保将桥接的-IPv4-流量传递到-iptables-的链：" class="headerlink" title="确保将桥接的 IPv4 流量传递到 iptables 的链："></a>确保将桥接的 IPv4 流量传递到 iptables 的链：</h3><p>加载 br_netfilter 模块加载：</p>
<pre><code>sudo modprobe br_netfilter
lsmod | grep br_netfilter
</code></pre>
<p>设置 br_netfilter，也可设置在/etc/sysctl.d/99-sysctl.conf 文件里。</p>
<pre><code>cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables=1
net.bridge.bridge-nf-call-iptables=1
EOF

sudo sysctl --system
</code></pre>
<h3 id="设置禁用-SELinux"><a href="#设置禁用-SELinux" class="headerlink" title="设置禁用 SELinux"></a>设置禁用 SELinux</h3><pre><code>sudo setenforce 0
sudo sed -i &#39;s/^SELINUX=enforcing$/SELINUX=disabled/&#39; /etc/selinux/config
</code></pre>
<h3 id="让各机器时间同步"><a href="#让各机器时间同步" class="headerlink" title="让各机器时间同步"></a>让各机器时间同步</h3><p>因为这里的环境是运行在 KVM 里的虚拟机，所以这一步可忽略。在生成环境中，各机器时间应该同步。</p>
<pre><code>yum install ntpdate -y
ntpdate time.windows.com
</code></pre>
<h3 id="安装-kubeadm"><a href="#安装-kubeadm" class="headerlink" title="安装 kubeadm"></a>安装 kubeadm</h3><pre><code>sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes
yum list installed | grep kube
</code></pre>
<p>此时可用的最新版本是 1.19.2。</p>
<h3 id="enable-kubelet"><a href="#enable-kubelet" class="headerlink" title="enable kubelet"></a>enable kubelet</h3><pre><code>sudo systemctl enable kubelet
sudo systemctl status kubelet
</code></pre>
<p>此时 kubelet 的状态是 failed，因为 api server 还没有起来。</p>
<h2 id="3）构建集群"><a href="#3）构建集群" class="headerlink" title="3）构建集群"></a>3）构建集群</h2><h3 id="在规划的-master-节点上首先初始化一个集群的-master-节点"><a href="#在规划的-master-节点上首先初始化一个集群的-master-节点" class="headerlink" title="在规划的 master 节点上首先初始化一个集群的 master 节点"></a>在规划的 master 节点上首先初始化一个集群的 master 节点</h3><p>这里要注意因为 gcr.io 被墙， 所以是使用 ali 镜像。各参数含义参考：<a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/</a><br>另外，关于 pod-network-cidr 的意义这篇文章非常好：<a target="_blank" rel="noopener" href="https://blog.csdn.net/shida_csdn/article/details/104334372">https://blog.csdn.net/shida_csdn/article/details/104334372</a><br>执行 kubeadm 时需要下载镜像，所以需要稍等一会儿。</p>
<pre><code>sudo kubeadm init \
--apiserver-advertise-address=192.168.1.11 \
--image-repository registry.aliyuncs.com/google_containers \
--kubernetes-version v1.19.2 \
--service-cidr=10.96.0.0/12 \
--pod-network-cidr=10.244.0.0/16
</code></pre>
<p>kubeadm init 命令输出大致如下，并且 kubelet 服务也已经正常。</p>
<pre><code>[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace
[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 192.168.1.11:6443 --token 67y1i4.686gqk1w73isp3op \
    --discovery-token-ca-cert-hash sha256:ccecf99d92615da1c67878029d79ae7323daac45476168091281ac80ddf0571d
[devops@k8s-master-0 ~]$
</code></pre>
<p>执行以下命令，让普通用户也能执行 kubectl 命令：</p>
<pre><code>mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<h3 id="安装网络插件-flannel"><a href="#安装网络插件-flannel" class="headerlink" title="安装网络插件 flannel"></a>安装网络插件 flannel</h3><pre><code>wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

# 替换 quay.io 为国内镜像 quay.mirrors.ustc.edu.cn

kubectl apply -f kube-flannel.yml

# 验证网络插件安装成功
kubectl get pods -n kube-system
</code></pre>
<p>如果需要，可以删除刚才安装的 flannel 插件：</p>
<pre><code>kubectl delete -f kube-flannel.yml
ip link
ip link delete cni0
ip link delete flannel.1
</code></pre>
<h3 id="把-nodes-加入集群"><a href="#把-nodes-加入集群" class="headerlink" title="把 nodes 加入集群"></a>把 nodes 加入集群</h3><p>在各个 node 节点运行以下命令：</p>
<pre><code>sudo kubeadm join 192.168.1.11:6443 --token 67y1i4.686gqk1w73isp3op \
        --discovery-token-ca-cert-hash sha256:ccecf99d92615da1c67878029d79ae7323daac45476168091281ac80ddf0571d
</code></pre>
<h3 id="在-master-节点，验证-nodes-都成功加入-K8S-集群："><a href="#在-master-节点，验证-nodes-都成功加入-K8S-集群：" class="headerlink" title="在 master 节点，验证 nodes 都成功加入 K8S 集群："></a>在 master 节点，验证 nodes 都成功加入 K8S 集群：</h3><pre><code>[devops@k8s-master-0 ~]$ kubectl get nodes
NAME           STATUS   ROLES    AGE     VERSION
k8s-master-0   Ready    master   72m     v1.19.2
k8s-node-0     Ready    &lt;none&gt;   4m41s   v1.19.2
k8s-node-1     Ready    &lt;none&gt;   76s     v1.19.2
k8s-node-2     Ready    &lt;none&gt;   89s     v1.19.2
[devops@k8s-master-0 ~]$
</code></pre>
<p><img src="/2020/09/28/devops/create_k8s_by_kubeadm/guest_hosts_created.png"></p>
<p><img src="/2020/09/28/devops/create_k8s_by_kubeadm/done.png"></p>
<p>至此，已经完成了 Kubernetes 集群的搭建。</p>
<hr>
<p><em>Reference:</em></p>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/8JznAEKe6b-wE-kNx7_Svg">https://mp.weixin.qq.com/s/8JznAEKe6b-wE-kNx7_Svg</a><br><a target="_blank" rel="noopener" href="https://my.oschina.net/u/3021599/blog/4308021">https://my.oschina.net/u/3021599/blog/4308021</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1525487">https://cloud.tencent.com/developer/article/1525487</a><br><a target="_blank" rel="noopener" href="https://galaxy.ansible.com/geerlingguy/docker">https://galaxy.ansible.com/geerlingguy/docker</a><br><a target="_blank" rel="noopener" href="https://galaxy.ansible.com/">https://galaxy.ansible.com/</a><br>在 CentOS7 上运行个 DHCP Server：<a target="_blank" rel="noopener" href="https://www.tecmint.com/install-dhcp-server-in-centos-rhel-fedora/">https://www.tecmint.com/install-dhcp-server-in-centos-rhel-fedora/</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hellxz/p/11044012.html">https://www.cnblogs.com/hellxz/p/11044012.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-devops/setup_local_docker_registry" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-09-27T13:17:11.000Z"><a href="/2020/09/28/devops/setup_local_docker_registry/">2020-09-28</a></time>
      
      
  
    <h1 class="title"><a href="/2020/09/28/devops/setup_local_docker_registry/">建立本地docker镜像中心</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>以下是在本地建立 docker registry 的过程，避免每次去互联网拉取镜像以及各种墙的问题。</p>
<h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><p>因为我们使用 registry 镜像安装镜像中心，所以需要首先安装 docker 引擎。</p>
<pre><code>sudo yum install -y yum-utils
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

sudo yum install docker-ce docker-ce-cli containerd.io
sudo systemctl enable docker
sudo systemctl start docker
sudo systemctl status docker
</code></pre>
<h2 id="运行-docker-registry"><a href="#运行-docker-registry" class="headerlink" title="运行 docker-registry"></a>运行 docker-registry</h2><p>sudo docker pull registry<br>sudo docker run –restart=always -d -p 15000:5000 -v /mnt/data/registry:/var/lib/registry registry</p>
<h2 id="TODO：添加镜像。。。"><a href="#TODO：添加镜像。。。" class="headerlink" title="TODO：添加镜像。。。"></a>TODO：添加镜像。。。</h2>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/4/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/6/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="as_sitesearch" value="dhyuan.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/AWS/">AWS</a><small>2</small></li>
  
    <li><a href="/tags/CAS/">CAS</a><small>5</small></li>
  
    <li><a href="/tags/Concurrency/">Concurrency</a><small>6</small></li>
  
    <li><a href="/tags/DevOps/">DevOps</a><small>31</small></li>
  
    <li><a href="/tags/FP/">FP</a><small>2</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
  
    <li><a href="/tags/Ingerss/">Ingerss</a><small>1</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>10</small></li>
  
    <li><a href="/tags/Kubernetes/">Kubernetes</a><small>3</small></li>
  
    <li><a href="/tags/Maven/">Maven</a><small>2</small></li>
  
    <li><a href="/tags/MicroService/">MicroService</a><small>3</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>6</small></li>
  
    <li><a href="/tags/Nginx/">Nginx</a><small>2</small></li>
  
    <li><a href="/tags/Reactive/">Reactive</a><small>8</small></li>
  
    <li><a href="/tags/SAGA/">SAGA</a><small>1</small></li>
  
    <li><a href="/tags/Scala/">Scala</a><small>7</small></li>
  
    <li><a href="/tags/Security/">Security</a><small>12</small></li>
  
    <li><a href="/tags/Spring/">Spring</a><small>14</small></li>
  
    <li><a href="/tags/android/">android</a><small>1</small></li>
  
    <li><a href="/tags/network/">network</a><small>2</small></li>
  
    <li><a href="/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><small>13</small></li>
  
    <li><a href="/tags/%E7%BD%91%E4%B8%8A%E5%A5%BD%E6%96%87/">网上好文</a><small>1</small></li>
  
  </ul>
</div>


  
  <div class="widget widget-archives">
    <h3 class="title">归档</h3>
    <div class="entry">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2025 Dahui
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
